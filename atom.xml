<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>木杉的博客</title>
  
  <subtitle>要么精通，要么死</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mushanshitiancai.github.io/"/>
  <updated>2018-08-07T14:58:53.561Z</updated>
  <id>http://mushanshitiancai.github.io/</id>
  
  <author>
    <name>木杉</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JDK源码阅读-ByteBuffer</title>
    <link href="http://mushanshitiancai.github.io/2018/08/07/java/language/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-ByteBuffer/"/>
    <id>http://mushanshitiancai.github.io/2018/08/07/java/language/JDK源码阅读-ByteBuffer/</id>
    <published>2018-08-07T14:45:27.000Z</published>
    <updated>2018-08-07T14:58:53.561Z</updated>
    
    <content type="html"><![CDATA[<p>Buffer是Java NIO中对于缓冲区的封装。在Java BIO中，所有的读写API，都是直接使用byte数组作为缓冲区的，简单直接。但是在Java NIO中，缓冲区这一概念变得复杂，可能是对应Java堆中的一块内存，也可能是对应本地内存中的一块内存。而byte数组只能用来指定Java堆中的一块内存，所以Java NIO中设计了一个新的缓冲区抽象，涵盖了不同类型缓冲区，这个抽象就是Buffer。</p><a id="more"></a><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>Buffer是Java NIO中对于缓冲区的抽象。是一个用于存储特定基本数据类型的容器。Buffer是特定基本数据类型的线性有限序列。</p><p>Java有8中基本类型：byte,short,int,long,float,double,char,boolean，除了boolean类型外，其他的类型都有对应的Buffer具体实现：</p><p><img src="/img/java/sourct/buffers.png" alt=""></p><p>Buffer抽象类定义了所有类型的Buffer都有的属性和操作，属性如下：</p><ul><li><code>capacity</code>：缓冲区的容量，在缓冲区建立后就不能改变</li><li><code>limit</code>：表示第一个不能读写的元素位置，limit不会大于capacity</li><li><code>position</code>：表示下一个要读写的元素位置，position不会大于limit</li><li><code>mark</code>：用于暂存一个元素位置，和书签一样，用于后续操作</li></ul><p>所有的Buffer操作都围绕这些属性进行。这些属性满足一个不变式：<code>0&lt;=mark&lt;=position&lt;=limit&lt;=capacity</code>。</p><p>新建的Buffer这些属性的取值为：</p><ul><li>position=0</li><li>limit=capacity=用户设置的容量</li><li>mark=-1</li></ul><p>直接看定义比较抽象，可以看一下示意图，下图是一个容量为10的Buffer：</p><p><img src="/img/java/source/buffer-init.png" alt=""></p><h2 id="ByteBuffer的具体实现"><a href="#ByteBuffer的具体实现" class="headerlink" title="ByteBuffer的具体实现"></a>ByteBuffer的具体实现</h2><p>所有Buffer实现中，最重要的实现是ByteBuffer，因为操作系统中所有的IO操作都是对字节的操作。当我们需要从字节缓冲区中读取别的数据类型才需要使用其他具体类型的Buffer实现。</p><p>ByteBuffer也是一个抽象类，具体的实现有HeapByteBuffer和DirectByteBuffer。分别对应Java堆缓冲区与堆外内存缓冲区。Java堆缓冲区本质上就是byte数组，所以实现会比较简单。而堆外内存涉及到JNI代码实现，较为复杂，本次我们以HeapByteBuffer为例来分析Buffer的相关操作，后续专门分析DirectByteBuffer。</p><p>ByteBuffer的类图如下：</p><p><img src="/img/java/source/bytebuffer-impl.png" alt=""></p><h2 id="读写Buffer"><a href="#读写Buffer" class="headerlink" title="读写Buffer"></a>读写Buffer</h2><p>Buffer作为缓冲区，最主要的作用是用于传递数据。Buffer提供了一系列的读取与写入操作。因为不同类型的Buffer读写的类型不同，所以具体的方法定义是定义在Buffer实现类中的。与读写相关的API如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">byte</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">byte</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">ByteBuffer <span class="title">get</span><span class="params">(<span class="keyword">byte</span>[] dst, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">ByteBuffer <span class="title">get</span><span class="params">(<span class="keyword">byte</span>[] dst)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span> b)</span></span></span><br><span class="line"><span class="function">ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">byte</span> b)</span></span></span><br><span class="line"><span class="function">ByteBuffer <span class="title">put</span><span class="params">(ByteBuffer src)</span> </span></span><br><span class="line"><span class="function">ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span>[] src, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br></pre></td></tr></table></figure><p>Buffer的读写操作可以按照两种维度分类：</p><ul><li>单个/批量：<ul><li>单个：一次读写一个字节</li><li>批量：一次读写多个字节</li></ul></li><li>相对/绝对：<ul><li>相对：从Buffer维护的position位置开始读写，读写时position会随之变化</li><li>绝对：直接指定读写的位置。指定index的API就是绝对API</li></ul></li></ul><p>接着我们来看看这些函数在HeapByteBuffer中是如何实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] hb;    <span class="comment">// 作为缓冲区的byte数组              </span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> offset;   <span class="comment">// 指定缓冲区的起始位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// get操作就是直接从数组中获取数据</span></span><br><span class="line">    <span class="keyword">return</span> hb[ix(nextGetIndex())];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从指定位置获取数据，是绝对操作，只需检查下标是否合法</span></span><br><span class="line">    <span class="keyword">return</span> hb[ix(checkIndex(i))];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取下一个要读取的元素的下标</span></span><br><span class="line"><span class="comment">// position的定义就是下一个要读写的元素位置，</span></span><br><span class="line"><span class="comment">// 所以这里是返回position的当前值，然后再对position进行加一操作</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextGetIndex</span><span class="params">()</span> </span>&#123;                          <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">if</span> (position &gt;= limit)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferUnderflowException();</span><br><span class="line">    <span class="keyword">return</span> position++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为支持偏移量，所以算出来的下标还需要加上偏移量</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">ix</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i + offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单字节put与get逻辑一样。看一下批量get是如何实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">get</span><span class="params">(<span class="keyword">byte</span>[] dst)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(dst, <span class="number">0</span>, dst.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">get</span><span class="params">(<span class="keyword">byte</span>[] dst, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查参数是否越界</span></span><br><span class="line">    checkBounds(offset, length, dst.length);</span><br><span class="line">    <span class="comment">// 检查要获取的长度是否大于Buffer中剩余的数据长度</span></span><br><span class="line">    <span class="keyword">if</span> (length &gt; remaining())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferUnderflowException();</span><br><span class="line">    <span class="comment">// 调用System.arraycopy进行数组内容拷贝</span></span><br><span class="line">    System.arraycopy(hb, ix(position()), dst, offset, length);</span><br><span class="line">    <span class="comment">// 更新position</span></span><br><span class="line">    position(position() + length);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，HeapByteBuffer是封装了对byte数组的简单操作。对缓冲区的写入和读取本质上是对数组的写入和读取。使用HeapByteBuffer的好处是我们不用做各种参数校验，也不需要另外维护数组当前读写位置的变量了。</p><p>同时我们可以看到，Buffer中对于position的操作没有使用锁进行保护，所以Buffer不是线程安全的。</p><h2 id="Buffer的模式"><a href="#Buffer的模式" class="headerlink" title="Buffer的模式"></a>Buffer的模式</h2><p>虽然JDK的Java Doc并没有提到Buffer有模式，但是Buffer提供了flip等操作用于切换Buffer的工作模式。在正确使用Buffer时，一定要注意Buffer的当前工作模式。否则会导致数据读写不符合你的预期。</p><p>Buffer有两种工作模式，一种是接收数据模式，一种是输出数据模式。</p><p>新建的Buffer处于接收数据的模式，可以向Buffer放入数据，放入一个对应基本类型的数据后，position加一，如果position已经等于limit了还进行put操作，则会抛出BufferOverflowException异常。</p><p>这种模式的Buffer可以用于Channel的read操作缓冲区，或者是用于相对put操作。</p><p>比如向一个接受数据模式的Buffer put5个byte后的示例图：</p><p><img src="/img/java/source/bytebuffer-flip.png" alt=""></p><p>因为Buffer的设计是读写的位置变量都使用position这个变量，所以如果要从Buffer中读取数据，要切换Buffer到输出数据模式。Buffer提供了flip方法用于这种切换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    limit = position;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切换后的效果图：</p><p><img src="/img/java/source/bytebuffer-afterflip.png" alt=""></p><p>然后就可以从Buffer中读取数据了。每次读取一个元素，position就会加一，如果position已经等于limit还进行读取，会抛出BufferUnderflowException异常。</p><p>可以看出Buffer本身没有一个用于存储模式的变量，模式的切换只是position和limit的变换而已。</p><p>flip方法只会把Buffer从接收模式切换到输出模式，如果要从输出模式切换到接收模式，可以使用<code>compact</code>或者<code>clear</code>方法，如果数据已经读取完毕或者数据不要了，使用<code>clear</code>方法，如果已读的数据需要保留，同时需要切换到接收数据模式，使用<code>compat</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压缩Buffer，去掉已经被读取的数据</span></span><br><span class="line"><span class="comment">// 压缩后的Buffer处于接收数据模式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">compact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.arraycopy(hb, ix(position()), hb, ix(<span class="number">0</span>), remaining());</span><br><span class="line">    position(remaining());</span><br><span class="line">    limit(capacity());</span><br><span class="line">    discardMark();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空Buffer，去掉所有数据(没有做清理工作，是指修改位置变量)</span></span><br><span class="line"><span class="comment">// 清空后的Buffer处于接收数据模式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Buffer是Java NIO对缓冲区的抽象</li><li>除了boolean类型，其他的基本类型都有对应的Buffer实现</li><li>最常用的Buffer实现是ByteBuffer，具体的实现有HeapByteBuffer和DirectByteBuffer，分别对应Java堆缓冲区与对外内存缓冲区</li><li>HeapByteBuffer是对byte数组的封装，方便使用</li><li>Buffer不是线程安全的</li><li>Buffer有两种模式一种是接收数据模式，一种是输出数据模式。新建的Buffer处于接收数据模式，使用<code>flip</code>方法可以切换Buffer到输出数据模式。使用<code>compact</code>或者<code>clear</code>方法可以切换到接收数据模式。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[堆外内存 之 DirectByteBuffer 详解 - 简书</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Buffer是Java NIO中对于缓冲区的封装。在Java BIO中，所有的读写API，都是直接使用byte数组作为缓冲区的，简单直接。但是在Java NIO中，缓冲区这一概念变得复杂，可能是对应Java堆中的一块内存，也可能是对应本地内存中的一块内存。而byte数组只能用来指定Java堆中的一块内存，所以Java NIO中设计了一个新的缓冲区抽象，涵盖了不同类型缓冲区，这个抽象就是Buffer。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://mushanshitiancai.github.io/categories/Java/"/>
    
      <category term="JDK源码阅读" scheme="http://mushanshitiancai.github.io/categories/Java/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="java" scheme="http://mushanshitiancai.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码阅读-InterruptibleChannel与可中断IO</title>
    <link href="http://mushanshitiancai.github.io/2018/08/01/java/language/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-InterruptibleChannel%E4%B8%8E%E5%8F%AF%E4%B8%AD%E6%96%ADIO/"/>
    <id>http://mushanshitiancai.github.io/2018/08/01/java/language/JDK源码阅读-InterruptibleChannel与可中断IO/</id>
    <published>2018-08-01T15:04:52.000Z</published>
    <updated>2018-08-07T14:41:44.378Z</updated>
    
    <content type="html"><![CDATA[<p>Java传统IO是不支持中断的，所以如果代码在read/write等操作阻塞的话，是无法被中断的。这就无法和Thead的interrupt模型配合使用了。JavaNIO众多的升级点中就包含了IO操作对中断的支持。InterruptiableChannel表示支持中断的Channel。我们常用的FileChannel，SocketChannel，DatagramChannel都实现了这个接口。</p><a id="more"></a><h2 id="InterruptibleChannel接口"><a href="#InterruptibleChannel接口" class="headerlink" title="InterruptibleChannel接口"></a>InterruptibleChannel接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterruptibleChannel</span> <span class="keyword">extends</span> <span class="title">Channel</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭当前Channel</span></span><br><span class="line"><span class="comment">     *     </span></span><br><span class="line"><span class="comment">     * 任何当前阻塞在当前channel执行的IO操作上的线程，都会收到一个AsynchronousCloseException异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InterruptibleChannel接口没有定义任何方法，其中的close方法是父接口就有的，这里只是添加了额外的注释。</p><p>AbstractInterruptibleChannel实现了InterruptibleChannel接口，并提供了实现可中断IO机制的重要的方法，比如<code>begin()</code>，<code>end()</code>。</p><p>在解读这些方法的代码前，先了解一下NIO中，支持中断的Channel代码是如何编写的。</p><p>第一个要求是要正确使用<code>begin()</code>和<code>end()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> completed = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    begin();</span><br><span class="line">    completed = ...;    <span class="comment">// 执行阻塞IO操作</span></span><br><span class="line">    <span class="keyword">return</span> ...;         <span class="comment">// 返回结果</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    end(completed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NIO规定了，在阻塞IO的语句前后，需要调用<code>begin()</code>和<code>end()</code>方法，为了保证<code>end()</code>方法一定被调用，要求放在finally语句块中。</p><p>第二个要求是Channel需要实现<code>java.nio.channels.spi.AbstractInterruptibleChannel#implCloseChannel</code>这个方法。AbstractInterruptibleChannel在处理中断时，会调用这个方法，使用Channel的具体实现来关闭Channel。</p><p>接下来我们具体看一下<code>begin()</code>和<code>end()</code>方法是如何实现的。</p><h2 id="begin方法"><a href="#begin方法" class="headerlink" title="begin方法"></a>begin方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存中断处理对象实例</span></span><br><span class="line"><span class="keyword">private</span> Interruptible interruptor;</span><br><span class="line"><span class="comment">// 保存被中断线程实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Thread interrupted;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化中断处理对象，中断处理对象提供了中断处理回调</span></span><br><span class="line">    <span class="comment">// 中断处理回调登记被中断的线程，然后调用implCloseChannel方法，关闭Channel</span></span><br><span class="line">    <span class="keyword">if</span> (interruptor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        interruptor = <span class="keyword">new</span> Interruptible() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">(Thread target)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (closeLock) &#123;</span><br><span class="line">                    <span class="comment">// 如果当前Channel已经关闭，则直接返回</span></span><br><span class="line">                    <span class="keyword">if</span> (!open)</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 设置标志位，同时登记被中断的线程</span></span><br><span class="line">                    open = <span class="keyword">false</span>;</span><br><span class="line">                    interrupted = target;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 调用具体的Channel实现关闭Channel</span></span><br><span class="line">                        AbstractInterruptibleChannel.<span class="keyword">this</span>.implCloseChannel();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException x) &#123; &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 登记中断处理对象到当前线程</span></span><br><span class="line">    blockedOn(interruptor);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断当前线程是否已经被中断，如果已经被中断，可能登记的中断处理对象没有被执行，这里手动执行一下</span></span><br><span class="line">    Thread me = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (me.isInterrupted())</span><br><span class="line">        interruptor.interrupt(me);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>begin()</code>方法中，我们可以看出NIO实现可中断IO操作的思路，是在Thread的中断逻辑中，挂载自定义的中断处理对象，这样Thread对象在被中断时，会执行中断处理对象中的回调，这个回调中，执行关闭Channel的操作。这样就实现了Channel对线程中断的响应了。</p><p>接下来重点就是研究“Thread添加中断处理逻辑”这个机制是如何实现的了，是通过<code>blockedOn</code>方法实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">blockedOn</span><span class="params">(Interruptible intr)</span> </span>&#123;         <span class="comment">// package-private</span></span><br><span class="line">    sun.misc.SharedSecrets.getJavaLangAccess().blockedOn(Thread.currentThread(),intr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>blockedOn</code>方法使用的是<code>JavaLangAccess</code>的<code>blockedOn</code>方法。</p><p><code>SharedSecrets</code>是一个神奇而糟糕的类，为啥说是糟糕呢，因为这个方法的存在，就是为了访问JDK类库中一些因为类作用域限制而外部无法访问的类或者方法。JDK很多类与方法是私有或者包级别私有的，外部是无法访问的，但是JDK在本身实现的时候又存在互相依赖的情况，所以为了外部可以不依赖反射访问这些类或者方法，在sun包下，存在这么一个类，提供了各种超越限制的方法。</p><p><code>SharedSecrets.getJavaLangAccess()</code>方法返回<code>JavaLangAccess</code>对象。<code>JavaLangAccess</code>对象就和名称所说的一样，提供了<code>java.lang</code>包下一些非公开的方法的访问。这个类在System初始化时被构造：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.lang.System#setJavaLangAccess</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setJavaLangAccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sun.misc.SharedSecrets.setJavaLangAccess(<span class="keyword">new</span> sun.misc.JavaLangAccess()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">blockedOn</span><span class="params">(Thread t, Interruptible b)</span> </span>&#123;</span><br><span class="line">            t.blockedOn(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，<code>sun.misc.JavaLangAccess#blockedOn</code>保证的就是<code>java.lang.Thread#blockedOn</code>这个包级别私有的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The object in which this thread is blocked in an interruptible I/O</span></span><br><span class="line"><span class="comment"> * operation, if any.  The blocker's interrupt method should be invoked</span></span><br><span class="line"><span class="comment"> * after setting this thread's interrupt status.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Interruptible blocker;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object blockerLock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the blocker field; invoked via sun.misc.SharedSecrets from java.nio code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blockedOn</span><span class="params">(Interruptible b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 串行化blocker相关操作</span></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        blocker = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这个方法也非常简单，就是设置<code>java.lang.Thread#blocker</code>变量为之前提到的中断处理对象。而且从注释中可以看出，这个方法就是专门为NIO设计的，注释都非常直白的提到了，NIO的代码会通过<code>sun.misc.SharedSecrets</code>调用到这个方法。。</p><p>接下来就是重头戏了，看一下Thread在中断时，如何调用NIO注册的中断处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        Interruptible b = blocker;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果NIO设置了中断处理器，则只需Thread本身的中断逻辑后，调用中断处理器的回调函数</span></span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interrupt0();           <span class="comment">// 这一步会设置interrupt标志位</span></span><br><span class="line">            b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果没有的话，就走普通流程</span></span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程中断是如何触发IO中断的时序图：</p><p><img src="/img/java/source/interruptible-1.png.png" alt=""></p><h2 id="end方法"><a href="#end方法" class="headerlink" title="end方法"></a>end方法</h2><p><code>begin()</code>方法负责添加Channel的中断处理器到当前线程。<code>end()</code>是在IO操作执行完/中断完后的操作，负责判断中断是否发生，如果发生判断是当前线程发生还是别的线程中断把当前操作的Channel给关闭了，对于不同的情况，抛出不同的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">(<span class="keyword">boolean</span> completed)</span> <span class="keyword">throws</span> AsynchronousCloseException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 清空线程的中断处理器引用，避免线程一直存活导致中断处理器无法被回收</span></span><br><span class="line">    blockedOn(<span class="keyword">null</span>);</span><br><span class="line">    Thread interrupted = <span class="keyword">this</span>.interrupted;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (interrupted != <span class="keyword">null</span> &amp;&amp; interrupted == Thread.currentThread()) &#123;</span><br><span class="line">        interrupted = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClosedByInterruptException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果这次没有读取到数据，并且Channel被另外一个线程关闭了，则排除Channel被异步关闭的异常</span></span><br><span class="line">    <span class="comment">// 但是如果这次读取到了数据，就不能抛出异常，因为这次读取的数据是有效的，需要返回给用户的(重要逻辑)</span></span><br><span class="line">    <span class="keyword">if</span> (!completed &amp;&amp; !open)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AsynchronousCloseException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过代码可以看出，如果是当前线程被中断，则抛出<code>ClosedByInterruptException</code>异常，表示Channel因为线程中断而被关闭了，IO操作也随之中断了。</p><p>如果是当前线程发现Channel被关闭了，并且是读取还未执行完毕的情况，则抛出<code>AsynchronousCloseException</code>异常，表示Channel被异步关闭了。</p><p><code>end()</code>逻辑的活动图如下：</p><p><img src="/img/java/source/interruptible-2.png" alt=""></p><h2 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h2><p>并发的场景分析起来就是复杂，上面的代码不多，但是场景很多，我们以<code>sun.nio.ch.FileChannelImpl#read(java.nio.ByteBuffer)</code>为例分析一下可能的场景：</p><ol><li>A线程read，B线程中断A线程：A线程抛出ClosedByInterruptException异常</li><li>A，B线程read，C线程中断A线程<ol><li>A被中断时，B刚刚进入read方法：A线程抛出ClosedByInterruptException异常，B线程<code>ensureOpen</code>方法抛出ClosedChannelException异常</li><li>A被中断时，B阻塞在底层read方法中：A线程抛出ClosedByInterruptException异常，B线程底层方法抛出异常返回，<code>end</code>方法中抛出AsynchronousCloseException异常</li><li>A被中断时，B已经读取到数据：A线程抛出ClosedByInterruptException异常，B线程正常返回</li></ol></li></ol><p><code>sun.nio.ch.FileChannelImpl#read(java.nio.ByteBuffer)</code>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ensureOpen();  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (!readable) <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NonReadableChannelException();</span><br><span class="line">    <span class="keyword">synchronized</span> (positionLock) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ti = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;            </span><br><span class="line">            begin();</span><br><span class="line">            ti = threads.add();</span><br><span class="line">            <span class="keyword">if</span> (!isOpen())</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 3</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                n = IOUtil.read(fd, dst, -<span class="number">1</span>, nd); <span class="comment">// 4</span></span><br><span class="line">            &#125; <span class="keyword">while</span> ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span><br><span class="line">            <span class="keyword">return</span> IOStatus.normalize(n);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threads.remove(ti);</span><br><span class="line">            end(n &gt; <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">assert</span> IOStatus.check(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在JavaIO时期，人们为了中断IO操作想了不少方法，核心操作就是关闭流，促使IO操作抛出异常，达到中断IO的效果。NIO中，将这个操作植入了<code>java.lang.Thread#interrupt</code>方法，免去用户自己编码特定代码的麻烦。使IO操作可以像其他可中断方法一样，在中断时抛出<code>ClosedByInterruptException</code>异常，业务程序捕获该异常即可对IO中断做出响应。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://stackoverflow.com/questions/8544891/what-does-javalangaccess-blockedonthread-t-interruptible-b-do" target="_blank" rel="noopener">java - What does JavaLangAccess.blockedOn(Thread t, Interruptible b) do? - Stack Overflow</a></li><li><a href="https://www.oschina.net/question/138146_26027" target="_blank" rel="noopener">Java NIO 那些躲在角落的细节</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java传统IO是不支持中断的，所以如果代码在read/write等操作阻塞的话，是无法被中断的。这就无法和Thead的interrupt模型配合使用了。JavaNIO众多的升级点中就包含了IO操作对中断的支持。InterruptiableChannel表示支持中断的Channel。我们常用的FileChannel，SocketChannel，DatagramChannel都实现了这个接口。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://mushanshitiancai.github.io/categories/Java/"/>
    
      <category term="JDK源码阅读" scheme="http://mushanshitiancai.github.io/categories/Java/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="java" scheme="http://mushanshitiancai.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java日志-Log4j实现运行时修改日志级别</title>
    <link href="http://mushanshitiancai.github.io/2018/07/28/java/language/Java%E6%97%A5%E5%BF%97-Log4j%E5%AE%9E%E7%8E%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E4%BF%AE%E6%94%B9%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB/"/>
    <id>http://mushanshitiancai.github.io/2018/07/28/java/language/Java日志-Log4j实现运行时修改日志级别/</id>
    <published>2018-07-28T09:18:54.000Z</published>
    <updated>2018-07-29T04:07:20.186Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://imushan.com/2018/07/28/java/language/Java%E6%97%A5%E5%BF%97-Log4j%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">源码分析</a>后，实现Log4j运行时修改日志级别思路就非常清晰了。</p><a id="more"></a><p>全局的日志级别保存在<code>org.apache.log4j.Hierarchy#threshold</code>中，是通过<code>log4j.threshold</code>配置项设置的，因我们基本不会配置这个配置项，所以可以不用管。</p><p>剩下的日志级别配置在Logger上。我们只要获取对应的Logger，设置其level属性即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Logger rootLogger = Logger.getRootLogger();</span><br><span class="line">rootLogger.setLevel(Level.DEBUG);</span><br></pre></td></tr></table></figure><p>嗯，就是这么简单。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://imushan.com/2018/07/28/java/language/Java%E6%97%A5%E5%BF%97-Log4j%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源码分析&lt;/a&gt;后，实现Log4j运行时修改日志级别思路就非常清晰了。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://mushanshitiancai.github.io/categories/Java/"/>
    
      <category term="掌握Java" scheme="http://mushanshitiancai.github.io/categories/Java/%E6%8E%8C%E6%8F%A1Java/"/>
    
    
      <category term="java" scheme="http://mushanshitiancai.github.io/tags/java/"/>
    
      <category term="log4j" scheme="http://mushanshitiancai.github.io/tags/log4j/"/>
    
  </entry>
  
  <entry>
    <title>Java日志-Log4j源码分析</title>
    <link href="http://mushanshitiancai.github.io/2018/07/28/java/language/Java%E6%97%A5%E5%BF%97-Log4j%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://mushanshitiancai.github.io/2018/07/28/java/language/Java日志-Log4j源码分析/</id>
    <published>2018-07-28T04:05:20.000Z</published>
    <updated>2018-07-28T09:19:13.620Z</updated>
    
    <content type="html"><![CDATA[<p>Log4j是一个历史非常悠久的库首次发布与2001年1月，有17年历史了，那个时候Java才发布1.3版本，所以也可以从Log4j的代码中看到他使用了很多古老的JDK类，比如Hashtable，可能是因为兼容性的考虑，后续的版本也一直没有升级这些地方。虽然Log4j历史悠久，但是应该还是使用最广泛的日志实现，我们分析其实现，还是能学到很多东西的，对于后续分析Log4j2或者Logback，都是有帮助的。</p><a id="more"></a><p>在读源码之前有几个疑问：</p><ul><li>Log4j支持什么类型的配置文件？这些配置文件同时存在于classpath中是什么效果？</li><li>Log4j是如何实现其日志继承的模型的？</li><li>Log4j是输出日志是写入内存缓存，还是直接写入操作系统？刷新到文件中的时机是如何的？</li></ul><p>我们分为几个部分来了解Log4j的实现：</p><ul><li>Log4j的整体结构</li><li>Log4j初始化读取配置的流程</li><li>Log4j打印日志的流程</li></ul><h2 id="Log4j的整体结构"><a href="#Log4j的整体结构" class="headerlink" title="Log4j的整体结构"></a>Log4j的整体结构</h2><p><img src="/img/java/log/log4j-main.png" alt=""></p><p>上图为Log4j的整体结构。Log4j中最重要的三个角色：</p><ul><li>Logger：日志类，用户操作的入口，提供获取日志类的静态方法与打印日志的方法</li><li>Appender：日志输出器，根据配置，可以输出日志到不同的地方，比如文件，数据库</li><li>Layout：日志格式化器，根据配置，可以按不同的方式格式化日志</li></ul><p>这几个关键类和Log4j的配置项是一一对应的。Log4j在初始化时会解析配置，生成具体的Appender和Layout实现类，关联到指定的Logger上。同理，我们也可以在代码中直接配置。</p><p>比如<code>BasicConfigurator.configure()</code>这个Log4j提供的简化配置方法，可以在没有配置文件的情况下，把日志输出到控制台中，他就是直接使用代码配置的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Logger root = Logger.getRootLogger();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置RootLogger的Appender为ConsoleAppender</span></span><br><span class="line">    <span class="comment">// 设置Layout为PatternLayout</span></span><br><span class="line">    root.addAppender(<span class="keyword">new</span> ConsoleAppender(</span><br><span class="line">        <span class="keyword">new</span> PatternLayout(PatternLayout.TTCC_CONVERSION_PATTERN)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Logger是一个树结构的关系。根节点是RootLogger，这个是固定的。这个树结构和我们数据结构中学的树有一点不一样的地方，不是父节点中保存子节点的连接，而是子节点中保存父节点的连接。这和Logger的场景是匹配的，打印日志时，<code>x.y</code>的Logger，首先查看自己身上是否配置有日志级别和Appender，如果有输出，然后查看其父Logger<code>x</code>，查看是否配置有日志级别和Appender，如果有输出，然后再查看<code>x</code>的父Logger，也就是RootLogger，RootLogger一定会配置有日志级别，根据级别与Appender进行相应的操作。日志的继承关系是Log4j的核心。</p><p>除了每个Logger通过<code>parent</code>属性管理父Logger之外。还需要一个地方来保存所有的Logger，否则在新建Logger的时候，没法去查询对应的父Logger实例了。保存所有Logger的地方就在日志仓库LoggerRepository中，具体的实现类为Hierachy，这个类如其名，就是根据继承关系来管理Logger的日志仓库。其中有一个Hashtable来保存所有的Logger，key为Logger的name，value为Logger实例。</p><p>大致的结构说完了，我们来看一下一些场景的具体实现。</p><h2 id="Log4j初始化加载日志的流程"><a href="#Log4j初始化加载日志的流程" class="headerlink" title="Log4j初始化加载日志的流程"></a>Log4j初始化加载日志的流程</h2><p>Log4j的初始化过程发生在LogManager的静态代码块中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_CONFIGURATION_FILE = <span class="string">"log4j.properties"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_XML_CONFIGURATION_FILE = <span class="string">"log4j.xml"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 实例化Hierarchy，设置RootLogger，并关联到LogManager上    </span></span><br><span class="line">    <span class="comment">// 这里新建RootLogger设置的日志级别为DEBUG，也就是说如果你在日志中没有配置RootLogger，则他的日志级别为DEBUG</span></span><br><span class="line">    Hierarchy h = <span class="keyword">new</span> Hierarchy(<span class="keyword">new</span> RootLogger((Level) Level.DEBUG));</span><br><span class="line">    repositorySelector = <span class="keyword">new</span> DefaultRepositorySelector(h);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 从classpath中获取log4j.xml文件</span></span><br><span class="line">    <span class="comment">// 如果不存在，则尝试获取log4j.properties文件</span></span><br><span class="line">    URL url = <span class="keyword">null</span>;</span><br><span class="line">    url = Loader.getResource(DEFAULT_XML_CONFIGURATION_FILE);</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">        url = Loader.getResource(DEFAULT_CONFIGURATION_FILE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (url != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 配置文件存在，进入配置文件解析流程</span></span><br><span class="line">            OptionConverter.selectAndConfigure(url, configuratorClassName,</span><br><span class="line">                                               LogManager.getLoggerRepository());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoClassDefFoundError e) &#123;</span><br><span class="line">            LogLog.warn(<span class="string">"Error during default initialization"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LogLog.debug(<span class="string">"Could not find resource: ["</span> + configurationOptionStr + <span class="string">"]."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化的过程，先实例化Hierarchy类，设置好RootLogger，后续就是尝试读取两种可能的配置文件了，可以看出<code>log4j.xml</code>的优先级是要高于<code>log4j.properties</code>的。</p><p><code>OptionConverter.selectAndConfigure()</code>方法根据不同的配置文件类型，使用<code>PropertyConfigurator</code>或者<code>DOMConfigurator</code>类对配置文件进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectAndConfigure</span><span class="params">(URL url, String clazz, LoggerRepository hierarchy)</span> </span>&#123;</span><br><span class="line">    Configurator configurator = <span class="keyword">null</span>;</span><br><span class="line">    String filename = url.getFile();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是xml文件，使用DOMConfigurator类</span></span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span> &amp;&amp; filename != <span class="keyword">null</span> &amp;&amp; filename.endsWith(<span class="string">".xml"</span>)) &#123;</span><br><span class="line">        clazz = <span class="string">"org.apache.log4j.xml.DOMConfigurator"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">        LogLog.debug(<span class="string">"Preferred configurator class: "</span> + clazz);</span><br><span class="line">        configurator = (Configurator) instantiateByClassName(clazz,</span><br><span class="line">                                                             Configurator.class,</span><br><span class="line">                                                             <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (configurator == <span class="keyword">null</span>) &#123;</span><br><span class="line">            LogLog.error(<span class="string">"Could not instantiate configurator ["</span> + clazz + <span class="string">"]."</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其他情况使用PropertyConfigurator类</span></span><br><span class="line">        configurator = <span class="keyword">new</span> PropertyConfigurator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    configurator.doConfigure(url, hierarchy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置处理器的类图：</p><p><img src="/img/java/log/log4j-property-configutator.png" alt=""></p><p>这里以<code>PropertyConfigutator为</code>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doConfigure</span><span class="params">(Properties properties, LoggerRepository hierarchy)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置RootLogger</span></span><br><span class="line">    configureRootCategory(properties, hierarchy);</span><br><span class="line">    <span class="comment">// 设置LoggerFactory，基本用不上</span></span><br><span class="line">    configureLoggerFactory(properties);</span><br><span class="line">    <span class="comment">// 设置其他Logger</span></span><br><span class="line">    parseCatsAndRenderers(properties, hierarchy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从配置设置Logger的细节很多这里就不看了，主要的步骤就是根据Log4j的配置规则，读取配置，新建Logger，设置Logger的name，level，appender，layout等，新建后的Logger会存入LogRepository中。</p><p>上面的初始化过程发生在LogManager第一次被加载时。而用户一般是不用与LogManager直接打交道的，用户通过<code>Logger.getLogger()</code>来获取Logger，这个方法代理调用<code>LogManger.getLogger()</code>，时序图如下：</p><p><img src="/img/java/log/log4j-getlogger.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.log4j.LogManager#getLogger(java.lang.Class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getLogger</span><span class="params">(<span class="keyword">final</span> Class clazz)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取日志仓库，通过日志仓库获取Logger</span></span><br><span class="line">    <span class="keyword">return</span> getLoggerRepository().getLogger(clazz.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.log4j.Hierarchy#getLogger(java.lang.String, org.apache.log4j.spi.LoggerFactory)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Logger <span class="title">getLogger</span><span class="params">(String name, LoggerFactory factory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存在Hashtable中的Key对象</span></span><br><span class="line">    CategoryKey key = <span class="keyword">new</span> CategoryKey(name);</span><br><span class="line">    Logger logger;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取ht的锁，串行化getLogger流程</span></span><br><span class="line">    <span class="keyword">synchronized</span> (ht) &#123;</span><br><span class="line">        Object o = ht.get(key);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 1. Hashtable中没有该Logger，新建Logger</span></span><br><span class="line">            <span class="comment">// 新建后的Logger需要关联好其父Logger，</span></span><br><span class="line">            <span class="comment">// 如果没有发现父Logger配置，则其父Logger为RootLogger</span></span><br><span class="line">            logger = factory.makeNewLoggerInstance(name);</span><br><span class="line">            logger.setHierarchy(<span class="keyword">this</span>);</span><br><span class="line">            ht.put(key, logger);</span><br><span class="line">            updateParents(logger);</span><br><span class="line">            <span class="keyword">return</span> logger;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Logger) &#123;</span><br><span class="line">            <span class="comment">// 2. Hashtable中已经有缓存该Logger，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> (Logger) o;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> ProvisionNode) &#123;</span><br><span class="line">            <span class="comment">// 3. Hashtable中存在该name的ProvisionNode对象</span></span><br><span class="line">            <span class="comment">// ProvisionNode对象是一个占位对象，比如配置了x.y Logger，</span></span><br><span class="line">            <span class="comment">// 在初始化这个Logger时，会去寻找x Logger，但是x Logger不存在，</span></span><br><span class="line">            <span class="comment">// 这个时候就会新建一个ProvisionNode对象，保存x对应的所有子Logger，</span></span><br><span class="line">            <span class="comment">// 如果后续配置上x Logger，则可以通过ProvisionNode中的信息，建立x Logger</span></span><br><span class="line">            <span class="comment">// 与所有其子Logger的父子关系</span></span><br><span class="line">            logger = factory.makeNewLoggerInstance(name);</span><br><span class="line">            logger.setHierarchy(<span class="keyword">this</span>);</span><br><span class="line">            ht.put(key, logger);</span><br><span class="line">            updateChildren((ProvisionNode) o, logger);</span><br><span class="line">            updateParents(logger);</span><br><span class="line">            <span class="keyword">return</span> logger;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不会进入的分支</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果日志文件中配置了<code>x.y</code> Logger，则在读取配置时，这个Logger就新建好了，<code>Logger.getLogger(&quot;x.y&quot;)</code>会直接从Hashtable中获取到。如果<code>Logger.getLogger(&quot;x.y.z&quot;)</code>，则会新建这个Logger，并设置Parent Logger为<code>x.y</code>，然后返回。</p><h2 id="Log4j打印日志的流程"><a href="#Log4j打印日志的流程" class="headerlink" title="Log4j打印日志的流程"></a>Log4j打印日志的流程</h2><p>Log4j打印日志一般是使用具体的日志级别方法，比如<code>logger.debug(&quot;hello&quot;)</code>，这背后是什么流程呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(Object message)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断全局日志级别，全局日志级别由配置项log4j.threshold设置</span></span><br><span class="line">    <span class="keyword">if</span> (repository.isDisabled(Level.DEBUG_INT))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 判断该Logger的日志级别，如果该Logger没有设置level，则查询父Logger的level，直到RootLogger</span></span><br><span class="line">    <span class="keyword">if</span> (Level.DEBUG.isGreaterOrEqual(<span class="keyword">this</span>.getEffectiveLevel())) &#123;</span><br><span class="line">        forcedLog(FQCN, Level.DEBUG, message, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">forcedLog</span><span class="params">(String fqcn, Priority level, Object message, Throwable t)</span> </span>&#123;</span><br><span class="line">    callAppenders(<span class="keyword">new</span> LoggingEvent(fqcn, <span class="keyword">this</span>, level, message, t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callAppenders</span><span class="params">(LoggingEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> writes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历处理该Logger，与其父Logger</span></span><br><span class="line">    <span class="keyword">for</span> (Category c = <span class="keyword">this</span>; c != <span class="keyword">null</span>; c = c.parent) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c.aai != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 调用Logger关联的所有Appender进行输出</span></span><br><span class="line">                writes += c.aai.appendLoopOnAppenders(event);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果设置additivity=false，则不会调用父Logger！</span></span><br><span class="line">            <span class="keyword">if</span> (!c.additive) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (writes == <span class="number">0</span>) &#123;</span><br><span class="line">        repository.emitNoAppenderWarning(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Logger除了本身输出日志，还会调用父Logger进行输出，同时一些属性如果子Logger没有设置，也会使用父Logger的配置，Log4j官方的一张图片表示了这个关系：</p><p><img src="https://logging.apache.org/log4j/1.2/images/od.gif" alt="img"></p><p>上面代码可以看到重要配置项<code>additivity</code>的作用，如果<code>additivity=true</code>，也就是默认不配置时的效果，Logger的所有父Logger都会进行输出，如果<code>additivity=false</code>，则处理完这个Logger，就直接返回了。</p><p>日志输出的任务是交给Appender来处理的，我们这里以常用的FileAppender为例子。从前文的类图中可以看出FileAppender继承于WriterAppender。FileAppender的输出使用WriterAppender的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriterAppender</span> <span class="keyword">extends</span> <span class="title">AppenderSkeleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> QuietWriter qw;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每次输出日志，是否调用Writer的flush方法。默认是每次都会调用</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> immediateFlush = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subAppend</span><span class="params">(LoggingEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用layout格式化消息，然后调用Writer的write方法输出日志</span></span><br><span class="line">        <span class="keyword">this</span>.qw.write(<span class="keyword">this</span>.layout.format(event));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断是否设置了每次都调用flush方法，如果设置了，则调用flush方法</span></span><br><span class="line">        <span class="keyword">if</span> (shouldFlush(event)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.qw.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WriterAppender的逻辑很直接，就是调用Writer的wter方法，然后根据配置判断是否需要跟着调用flush方法，默认情况下是每次都会调用flush的，也就是说，默认情况下，我们不用担心日志被Java框架层的缓存缓存住而导致刷新到文件中的时间较为滞后。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileAppender</span> <span class="keyword">extends</span> <span class="title">WriterAppender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否使用缓冲IO，默认为false</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> bufferedIO = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setFile</span><span class="params">(String fileName, <span class="keyword">boolean</span> append, <span class="keyword">boolean</span> bufferedIO, <span class="keyword">int</span> bufferSize)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果使用缓冲IO，就不需要每次flush</span></span><br><span class="line">        <span class="keyword">if</span> (bufferedIO) &#123;</span><br><span class="line">            setImmediateFlush(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        reset();</span><br><span class="line">        FileOutputStream ostream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ostream = <span class="keyword">new</span> FileOutputStream(fileName, append);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException ex) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用FileOutputStream新建Writer，核心逻辑是new OutputStreamWriter()</span></span><br><span class="line">        Writer fw = createWriter(ostream);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果配置指定要使用缓冲IO，则使用BufferedWriter进行内存缓冲</span></span><br><span class="line">        <span class="keyword">if</span> (bufferedIO) &#123;</span><br><span class="line">            fw = <span class="keyword">new</span> BufferedWriter(fw, bufferSize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.setQWForFiles(fw);</span><br><span class="line">        <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">        <span class="keyword">this</span>.fileAppend = append;</span><br><span class="line">        <span class="keyword">this</span>.bufferedIO = bufferedIO;</span><br><span class="line">        <span class="keyword">this</span>.bufferSize = bufferSize;</span><br><span class="line">        writeHeader();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面的分析，我们得出以下结论：</p><ul><li>FileAppender及其子类，比如我们常用的<code>RollingFileAppender</code>，<code>DailyRollingFileAppender</code>，会根据配置的文件名新建FileOutputStream，然后进一步新建OutputStreamWriter，后续的日志操作，就是调用<code>Writer.write()</code>进行的</li><li>FileAppender系列Appender，默认没有开启缓冲IO，也就是说不会使用BufferedWriter。可以使用<code>log4j.appender.{appenderName}.bufferedIO=true</code>配置项来开启缓冲区IO。开启缓冲区IO能提高打印日志的性能，但是会增加日志打印到日志写入文件的延迟。同时有一个需要关注的点是，如果开启缓冲区IO，如果程序异常退出，还未写入操作系统的日志就丢失了。而关闭缓冲IO的情况下，每次写入日志，都会调用操作系统的read系统调用，虽然这会儿日志内容不一定写到硬盘上，可能会存在于操作系统的页缓冲区中，但即使Java程序崩溃，只要操作系统不崩溃，日志是不会丢失的。这一块内容可以结合<a href="http://imushan.com/2018/06/17/linux/Linux-UNIX%E7%BC%96%E7%A8%8B%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%96%87%E4%BB%B6%E8%90%BD%E7%9B%98/" target="_blank" rel="noopener">Linux/UNIX编程如何保证文件落盘</a>和<a href="http://imushan.com/2018/06/18/java/language/Java%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%96%87%E4%BB%B6%E8%90%BD%E7%9B%98%EF%BC%9F/" target="_blank" rel="noopener">Java如何保证文件落盘？</a>这两篇文章来学习。</li></ul><p>根据以上分析，我们知道了日志打印时，Log4j先判断日志级别是否打开，然后交给Logger配置的Appender来输出日志。Appender先调用配置的Layout格式化日志，然后输出日志到具体的地方。比如FileAppender系列Appender会输出日志到文件，是通过OutputStreamWriter进行输出的。这个过程会在Logger的所有父Logger上进行，除非Logger本身配置了<code>additivity=false</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Logger的继承关系是Log4j的核心设计思想</li><li>Logger是一棵树的关系，每个节点通过parent持有其父Logger的引用。根节点是RootLogger，是在Log4j初始化时就会新建的Logger</li><li>子Logger会从父Logger中继承配置，子Logger输出日志会调用所有父Logger输出日志，除非子Logger配置了<code>additivity=false</code></li><li>FileAppender系列Appender，默认没有开启缓冲IO，也就是说不会使用BufferedWriter。可以使用<code>log4j.appender.{appenderName}.bufferedIO=true</code>配置项来开启缓冲区IO。开启缓冲区IO能提高打印日志的性能，但是会增加日志打印到日志写入文件的延迟。同时有一个需要关注的点是，如果开启缓冲区IO，如果程序异常退出，还未写入操作系统的日志就丢失了。而关闭缓冲IO的情况下，每次写入日志，都会调用操作系统的read系统调用，虽然这会儿日志内容不一定写到硬盘上，可能会存在于操作系统的页缓冲区中，但即使Java程序崩溃，只要操作系统不崩溃，日志是不会丢失的。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Log4j是一个历史非常悠久的库首次发布与2001年1月，有17年历史了，那个时候Java才发布1.3版本，所以也可以从Log4j的代码中看到他使用了很多古老的JDK类，比如Hashtable，可能是因为兼容性的考虑，后续的版本也一直没有升级这些地方。虽然Log4j历史悠久，但是应该还是使用最广泛的日志实现，我们分析其实现，还是能学到很多东西的，对于后续分析Log4j2或者Logback，都是有帮助的。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://mushanshitiancai.github.io/categories/Java/"/>
    
      <category term="掌握Java" scheme="http://mushanshitiancai.github.io/categories/Java/%E6%8E%8C%E6%8F%A1Java/"/>
    
    
      <category term="java" scheme="http://mushanshitiancai.github.io/tags/java/"/>
    
      <category term="log4j" scheme="http://mushanshitiancai.github.io/tags/log4j/"/>
    
  </entry>
  
  <entry>
    <title>Java日志-SLF4J使用与源码分析</title>
    <link href="http://mushanshitiancai.github.io/2018/07/22/java/language/Java%E6%97%A5%E5%BF%97-SLF4J%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://mushanshitiancai.github.io/2018/07/22/java/language/Java日志-SLF4J使用与源码分析/</id>
    <published>2018-07-22T13:22:13.000Z</published>
    <updated>2018-07-28T09:16:37.585Z</updated>
    
    <content type="html"><![CDATA[<p>SLF4J全称The Simple Logging Facade for Java，Java简易日志门面，将接口抽象与实现隔离开，在不修改代码的情况下使用不同的日志实现。</p><a id="more"></a><p>SLF4J支持的日志实现有：</p><ul><li>log4j</li><li>logback（推荐实现）</li><li>java.util.logging</li><li>simple（全部输出到System.err）</li><li>Jakarta Commons Logging</li><li>nop（忽略所有日志）</li></ul><h2 id="使用SLF4J"><a href="#使用SLF4J" class="headerlink" title="使用SLF4J"></a>使用SLF4J</h2><p>只要在项目中引入SLF4J的jar包就能开启SLF4J：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后写一个最简单的输出日志的程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    </span><br><span class="line">        Logger logger = LoggerFactory.getLogger(HelloWorld.class);</span><br><span class="line">        String name = <span class="string">"mushan"</span>;    </span><br><span class="line">        logger.info(<span class="string">"Hello &#123;&#125;"</span>, name);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行会在控制台打印：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span></span><br></pre></td></tr></table></figure><p>因为slf4j在classpath中没有找到任何一个slf4j binding，所以会提示一个错误信息，并提示会使用NOP logger，这个logger的行为就是忽略所有输出。</p><h2 id="绑定日志实现"><a href="#绑定日志实现" class="headerlink" title="绑定日志实现"></a>绑定日志实现</h2><p>之前提到了slf4j支持很多日志实现，slf4j包含了一些日志实现的桥接库，称为<code>SLF4J bindings</code>，官方提供的binding有：</p><ul><li><code>slf4j-log4j12-1.8.0-beta2.jar</code><br>log4j1.2.x的binding，应该是使用最广的了。需要引入log4j。<br>Binding for log4j version 1.2, a widely used logging framework. You also need to place log4j.jar on your class path.</li><li><code>slf4j-jdk14-1.8.0-beta2.jar</code><br>JDK1.4提供的<code>java.util.logging</code>的binding</li><li><code>slf4j-nop-1.8.0-beta2.jar</code><br>NOP的binding，忽略所有日志</li><li><code>slf4j-simple-1.8.0-beta2.jar</code><br>简单日志实现，输出所有日志到System.err，只会输出大于等于INFO级别的日志。小程序可以用这个实现。</li><li><code>slf4j-jcl-1.8.0-beta2.jar</code><br>Jakarta Commons Logging日志库的binding，这个binding会代理所有的日志操作到JCL。JCL也是一个日志门面，但是目前已经被slf4j取代了。</li><li><code>logback-classic-1.0.13.jar</code> (requires logback-core-1.0.13.jar)<br>这是slf4j的官方日志实现（其实log4j，slf4j，logback都是一家出品），logback就是按照slf4j的API直接实现的，所以不需要中间的binding。所以用这个官方实现，中间的损耗也是最小的。</li></ul><p>切换日志实现，只要使用不同的binding jar包即可。不同于JCL，slf4j没有使用类加载器，而是在binding中硬绑定具体的实现。所以classpath中同时只能存在一个实现的binding。所以slf4j没有JCL可能的类加载器问题和内存损耗问题。</p><p>slf4j1.6之前，如果没有找到binding，slf4j会抛出<code>NoClassDefFoundError</code>异常，1.6之后，即使没有binding，slf4j也不会抛出异常，只是提示没有找到binding。所以对于库或者框架的作者来说，一定不要在项目中添加具体的slf4j binding，只要添加slf4j本身即可，让用户有机会选择具体的实现。</p><p>slf4j，slf4j binding，日志实现之间的关系见下图：</p><p><img src="https://www.slf4j.org/images/concrete-bindings.png" alt=""></p><p>所以官方推荐的使用方法是只要在pom引入具体的slf4j binding依赖即可，slf4j binding会引入slf4j-api和具体的日志实现的依赖，而且版本都不会有问题。手动引入这些当然也是可以，只是要注意这三者的版本兼容性。</p><p>我们引入<code>slf4j-log4j12</code>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再次运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log4j:WARN No appenders could be found for logger (com.mushan.blog.Main).</span><br><span class="line">log4j:WARN Please initialize the log4j system properly.</span><br><span class="line">log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.</span><br></pre></td></tr></table></figure><p>可以看到提示的是log4j没有配置的信息，slf4j已经成功使用log4j实现了。</p><h2 id="关于参数"><a href="#关于参数" class="headerlink" title="关于参数"></a>关于参数</h2><p>上面的例子，使用到了<code>{}</code>占位符，这是slf4j的参数占位符，效果与使用<code>+</code>进行字符串拼接是一样的，项目中也经常会看到使用<code>+</code>的例子，这是不好的，因为有性能问题。</p><p>比如这样的一个日志语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.debug(<span class="string">"Entry number: "</span> + i + <span class="string">" is "</span> + String.valueOf(entry[i]));</span><br></pre></td></tr></table></figure><p>为了调用debug函数，需要执行这个字符串拼接语句，需要把<code>i</code>和<code>entry[i]</code>转为字符串，然后拼接。如果日志没有开启，或者日志级别高于debug，日志是不需要打印的，但是这个拼接消耗却是没有办法避免的。</p><p>所以日志框架后面想出了一个办法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(logger.isDebugEnabled()) &#123;</span><br><span class="line">  logger.debug(<span class="string">"Entry number: "</span> + i + <span class="string">" is "</span> + String.valueOf(entry[i]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先使用<code>logger.isDebugEnabled()</code>方法检测对应的日志级别是否打开，打开了我才调用日志打印函数。但是这样做的问题是：1.麻烦，每次需要打印日志都要写一句检测判断 2.如果日志是开启了debug日志级别，但是日志本身是disable的话，依然有不必要的参数拼接消耗。</p><p>所有slf4j推荐的使用方式是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object entry = <span class="keyword">new</span> SomeObject();</span><br><span class="line">logger.debug(<span class="string">"The entry is &#123;&#125;."</span>, entry);</span><br></pre></td></tr></table></figure><p>日志实现在必要的时候才会替换日志中的<code>{}</code>占位符为具体的参数，所有不会有无意义的消耗。</p><p>按slf4j官网的说法，下面两种写法在日志被禁用的情况下，性能查了30倍（有点意外）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logger.debug(<span class="string">"The new entry is "</span>+entry+<span class="string">"."</span>);</span><br><span class="line">logger.debug(<span class="string">"The new entry is &#123;&#125;."</span>, entry);</span><br></pre></td></tr></table></figure><p>如果你需要在日志中输出<code>{}</code>本身，可以使用<code>\</code>进行转义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.debug(<span class="string">"Set \\&#123;&#125; differs from &#123;&#125;"</span>, <span class="string">"3"</span>);</span><br></pre></td></tr></table></figure><p>这样会输出：<code>Set {} differs from 3</code>。</p><h2 id="SLF4J源码分析"><a href="#SLF4J源码分析" class="headerlink" title="SLF4J源码分析"></a>SLF4J源码分析</h2><p>slf4j是如何实现部署时绑定日志实现呢？我们来分析一下他的代码，以下分析基于slf4j 1.7.25。</p><p>顺便说一句，在网上看到很多分析slf4j的文章，得到的结论是使用类加载器来加载具体实现，这个是完全错误的。slf4j的官网已经明确说明slf4j不使用任何类加载器，这是他的一个优点，不会有类加载器冲突，不会有内存占用问题。</p><p>先看一下slf4j的整体类图：</p><p><img src="/img/java/log/slf4j-logger.png" alt=""></p><p>我们获取Logger的方法是<code>LoggerFactory.getLogger(name)</code>，所以入口方法就是这个工厂方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getLogger</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    ILoggerFactory iLoggerFactory = getILoggerFactory();</span><br><span class="line">    <span class="keyword">return</span> iLoggerFactory.getLogger(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出LoggerFactory不是真正的日志类工厂，真正的日志类工厂获取流程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用一个变量表示当前的初始化状态，因为可能多线程同时初始化，所以该状态变量声明为volatile</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> INITIALIZATION_STATE = UNINITIALIZED;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ILoggerFactory <span class="title">getILoggerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果还未进行初始化，则进行初始化，这里使用了多线程常用的double-check技术</span></span><br><span class="line">    <span class="keyword">if</span> (INITIALIZATION_STATE == UNINITIALIZED) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LoggerFactory.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (INITIALIZATION_STATE == UNINITIALIZED) &#123;</span><br><span class="line">                INITIALIZATION_STATE = ONGOING_INITIALIZATION;</span><br><span class="line">                <span class="comment">// 初始化，绑定具体日志实现的逻辑在此</span></span><br><span class="line">                performInitialization();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据不同的初始化结果，返回不同的LoggerFactory</span></span><br><span class="line">    <span class="keyword">switch</span> (INITIALIZATION_STATE) &#123;</span><br><span class="line">    <span class="keyword">case</span> SUCCESSFUL_INITIALIZATION:</span><br><span class="line">        <span class="comment">// 初始化成功，返回具体的日志实现提供的LoggerFactory</span></span><br><span class="line">        <span class="keyword">return</span> StaticLoggerBinder.getSingleton().getLoggerFactory();</span><br><span class="line">    <span class="keyword">case</span> NOP_FALLBACK_INITIALIZATION:</span><br><span class="line">        <span class="comment">// 初始化失败，返回NOPLogger</span></span><br><span class="line">        <span class="keyword">return</span> NOP_FALLBACK_FACTORY;</span><br><span class="line">    <span class="keyword">case</span> FAILED_INITIALIZATION:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(UNSUCCESSFUL_INIT_MSG);</span><br><span class="line">    <span class="keyword">case</span> ONGOING_INITIALIZATION:</span><br><span class="line">        <span class="comment">// 防止初始化日志过程中出现递归初始化的问题</span></span><br><span class="line">        <span class="comment">// See also http://jira.qos.ch/browse/SLF4J-97</span></span><br><span class="line">        <span class="keyword">return</span> SUBST_FACTORY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unreachable code"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们进一步来看slf4j如何绑定日志实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">performInitialization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 绑定逻辑在此</span></span><br><span class="line">    bind();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定后的版本兼容性检查</span></span><br><span class="line">    <span class="keyword">if</span> (INITIALIZATION_STATE == SUCCESSFUL_INITIALIZATION) &#123;</span><br><span class="line">        versionSanityCheck();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Set&lt;URL&gt; staticLoggerBinderPathSet = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 检测classpath是否存在多个slf4j binding，如果存在多个，则打印提示</span></span><br><span class="line">        <span class="comment">// 这里有一个优化，就是如果是安卓平台，就跳过检查，因为安卓打包后不会有重复的类</span></span><br><span class="line">        <span class="keyword">if</span> (!isAndroid()) &#123;</span><br><span class="line">            staticLoggerBinderPathSet = findPossibleStaticLoggerBinderPathSet();</span><br><span class="line">            reportMultipleBindingAmbiguity(staticLoggerBinderPathSet);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这就是slf4j绑定具体日志实现的逻辑，就一句话！</span></span><br><span class="line">        StaticLoggerBinder.getSingleton();</span><br><span class="line"></span><br><span class="line">        INITIALIZATION_STATE = SUCCESSFUL_INITIALIZATION;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果classpath中存在多个slf4j binding，则在此打印出最终使用的binding</span></span><br><span class="line">        reportActualBinding(staticLoggerBinderPathSet);</span><br><span class="line">        fixSubstituteLoggers();</span><br><span class="line">        replayEvents();</span><br><span class="line">        <span class="comment">// release all resources in SUBST_FACTORY</span></span><br><span class="line">        SUBST_FACTORY.clear();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoClassDefFoundError ncde) &#123;</span><br><span class="line">        <span class="comment">// 如果classpath不存在任何slf4j binding，则找不到StaticLoggerBinder类</span></span><br><span class="line">        <span class="comment">// 会抛出NoClassDefFoundError，这捕获改异常，如果没有找到binding，则使用NOPLogger</span></span><br><span class="line">        String msg = ncde.getMessage();</span><br><span class="line">        <span class="keyword">if</span> (messageContainsOrgSlf4jImplStaticLoggerBinder(msg)) &#123;</span><br><span class="line">            INITIALIZATION_STATE = NOP_FALLBACK_INITIALIZATION;</span><br><span class="line">            Util.report(<span class="string">"Failed to load class \"org.slf4j.impl.StaticLoggerBinder\"."</span>);</span><br><span class="line">            Util.report(<span class="string">"Defaulting to no-operation (NOP) logger implementation"</span>);</span><br><span class="line">            Util.report(<span class="string">"See "</span> + NO_STATICLOGGERBINDER_URL + <span class="string">" for further details."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            failedBinding(ncde);</span><br><span class="line">            <span class="keyword">throw</span> ncde;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.lang.NoSuchMethodError nsme) &#123;</span><br><span class="line">        String msg = nsme.getMessage();</span><br><span class="line">        <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.contains(<span class="string">"org.slf4j.impl.StaticLoggerBinder.getSingleton()"</span>)) &#123;</span><br><span class="line">            INITIALIZATION_STATE = FAILED_INITIALIZATION;</span><br><span class="line">            Util.report(<span class="string">"slf4j-api 1.6.x (or later) is incompatible with this binding."</span>);</span><br><span class="line">            Util.report(<span class="string">"Your binding is version 1.5.5 or earlier."</span>);</span><br><span class="line">            Util.report(<span class="string">"Upgrade your binding to version 1.6.x."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> nsme;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        failedBinding(e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected initialization failure"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最关键的一句话是最简单的一句话:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StaticLoggerBinder.getSingleton();</span><br></pre></td></tr></table></figure><p>这里slf4j要求所有的binding必须实现一个<code>org.slf4j.impl.StaticLoggerBinder</code>类，slf4j就用最普通的方式实例化这个类。存在三种情况：</p><ol><li>classpath中不存在这个类。这种情况是没有添加任何binding的情况，这种情况下这句话抛出<code>NoClassDefFoundError</code>异常，slf4j捕获异常，返回NOPLoggerFactory。</li><li>classpath存在这个类，且只有一个。slf4j实例化这个类，并调用<code>StaticLoggerBinder.getSingleton().getLoggerFactory()</code>方法得到具体的实现的LoggerFactory。</li><li>classpath存在多个同样全限定名的类。JVM是允许这种情况的，这种情况下，会使用更靠前的那个类，因为JVM是从前往后搜索类的。slf4j在这种情况下，为了提醒用户，会答应出classpath存在的类，与最终使用的binding。</li></ol><p>所以，通过这种方式，slf4j不需要自定义类加载器就能绑定不同的日志实现。优点是实现简单，性能高，兼容性高，缺点是无法在运行时切换日志实现，不过这个基本上也用不到。</p><p>还有一个问题，slf4j-api项目本身，存在<code>org.slf4j.impl.StaticLoggerBinder</code>这个类吗？不存在的话，编译是没法通过的，如果存在这个类，可能会覆盖binding中的类，这个问题如何解决？</p><p>在slf4j-api项目的pom中发现了这么一个配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-antrun-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">phase</span>&gt;</span>process-classes<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tasks</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">echo</span>&gt;</span>Removing slf4j-api's dummy StaticLoggerBinder and StaticMarkerBinder<span class="tag">&lt;/<span class="name">echo</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">delete</span> <span class="attr">dir</span>=<span class="string">"target/classes/org/slf4j/impl"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tasks</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用maven的ant插件，在打包前删除了<code>target/classes/org/slf4j/impl</code>下的class文件，这样发布出去的slf4j就不存在这个类了，真是太机智了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>slf4j是Java简易日志门面，可以在不修改代码的情况下，在部署时使用不同的日志实现</li><li>slf4j支持参数化消息，在日志关闭的情况下，减少不必要的字符串拼接和类型转换，提高性能</li><li>slf4j使用静态绑定的方式绑定具体的日志binding，依赖binding实现的<code>org.slf4j.impl.StaticLoggerBinder</code>类，没有使用自定义类加载器</li><li>slf4j允许classpath存在多个slf4j binding，但是只会使用其中一个</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.slf4j.org/manual.html" target="_blank" rel="noopener">SLF4J Manual</a></li><li><a href="https://www.slf4j.org/faq.html#logging_performance" target="_blank" rel="noopener">SLF4J FAQ</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SLF4J全称The Simple Logging Facade for Java，Java简易日志门面，将接口抽象与实现隔离开，在不修改代码的情况下使用不同的日志实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://mushanshitiancai.github.io/categories/Java/"/>
    
      <category term="掌握Java" scheme="http://mushanshitiancai.github.io/categories/Java/%E6%8E%8C%E6%8F%A1Java/"/>
    
    
      <category term="java" scheme="http://mushanshitiancai.github.io/tags/java/"/>
    
      <category term="log4j" scheme="http://mushanshitiancai.github.io/tags/log4j/"/>
    
  </entry>
  
  <entry>
    <title>自己动手写操作系统-计算机通电之后的操作</title>
    <link href="http://mushanshitiancai.github.io/2018/07/11/os/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E7%94%B5%E4%B9%8B%E5%90%8E%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <id>http://mushanshitiancai.github.io/2018/07/11/os/自己动手写操作系统-计算机通电之后的操作/</id>
    <published>2018-07-11T14:50:46.000Z</published>
    <updated>2018-07-22T13:14:01.134Z</updated>
    
    <content type="html"><![CDATA[<p>以前每次开机，先是看到一个黑屏幕上显示一些字符，然后会进入windows经典的启动界面。对于要编写操作系统来说，这种表面的认识是不够的，得需要知道一下通电后，执行的入口是哪里，启动的流程是如何跑起来的。</p><a id="more"></a><p>先说结论：通电后，CPU的cs:ip寄存器被强制初始化为0xF000:0xFFF0。</p><p>接下来，为了理解CPU的cs:ip寄存器被初始化后的效果，需要学习一些准备知识：</p><ul><li>什么是分段访问</li><li>什么是cs:ip寄存器</li><li>什么是实模式</li><li>实模式下的内存布局是如何的</li><li>0xF000:0xFFF0地址有什么特别意义</li><li>cs:ip寄存器初始化为0xF000:0xFFF0后续操作是什么</li></ul><h2 id="什么是分段访问"><a href="#什么是分段访问" class="headerlink" title="什么是分段访问"></a>什么是分段访问</h2><p>8086的地址线有20位，也就是说8086可以寻址的范围是00000-FFFFF，1MB的内存。但是8086的寄存只有16位，直接使用一个寄存器只能寻址64KB的内存。</p><p>为了能访问到1MB的内存，8086引入了段的概念，把内存区域划分为一个一个的段：</p><p><img src="/img/os/segment.png" alt=""></p><p>用一个寄存器，存放段的起始位置，称为段基址，另外一个寄存器存放偏移量，称为段内偏移。起始位置+偏移量=最终的地址。这里需要注意的是，起始位置必须是20位的，否则两个16位的数字相加，区间为FFFF+FFFF=1FFFE，也是无法寻址20位地址的空间的。8086想的方法是存放段基址的寄存器左移4位实现20位，然后再加上偏移量。</p><p>所以最终物理地址的计算公式为：段基址*16+段内偏移</p><h2 id="什么是cs-ip寄存器"><a href="#什么是cs-ip寄存器" class="headerlink" title="什么是cs:ip寄存器"></a>什么是cs:ip寄存器</h2><p>大家知道CPU可以执行机器码，这些机器码包含了操作码和操作数或操作寄存器。</p><p>机器码是我们的程序编译后生成的，保存在持久化设备中，比如软盘，硬盘。但是CPU不会直接与硬盘交互，只会与内存交互，所以有一个过程，会把程序加载到内存中，然后CPU来读取，来执行。问题是CPU如何知道自己从内存的哪个位置读取机器码呢？答案就是cs:ip寄存器。</p><p>cs是代码段寄存器，存放代码段段基址，ip是指令寄存器，存放段内偏移。cs:ip永远保存<strong>下一条</strong>要被执行的机器码的地址。</p><p>只要给CPU一个cs:ip后，CPU取出机器码执行，同时会对ip加上机器码的长度，执行完当前机器码后，会根据cs:ip再次取出机器码，周而复始，直到关机断电。</p><p>我们无法直接操作ip寄存器，但是可以通过jmp等跳转相关指令修改cs:ip寄存器的值，实现分支等逻辑。</p><h2 id="什么是实模式"><a href="#什么是实模式" class="headerlink" title="什么是实模式"></a>什么是实模式</h2><p>8086中只有一种模式，80286中出现了保护模式，同时把8086的模式称为实模式。</p><p>实模式的特点是：</p><ul><li>实模式使用20位地址线，可以寻址1MB内存。</li><li>实模式下寻址的地址如果超过20位，则会卷回到低地址，也就是取模的效果。</li><li>在实模式下，所有的段都是可以读、写和执行的。 </li></ul><p>8086以及之后的CPU启动后进入的都是实模式。操作系统需要在实模式下引导系统启动。所以即使实模式是历史久远的落后模式，我们依然要学习如何在实模式下编程。</p><h2 id="实模式下的内存布局是如何的"><a href="#实模式下的内存布局是如何的" class="headerlink" title="实模式下的内存布局是如何的"></a>实模式下的内存布局是如何的</h2><p>实模式下可以寻址1MB的内存，不过这个内存不是完全对应插在主机内存插槽上的内存。这个物理的内存称为DRAM。这1MB的区域只有一部分是对应到DRAM上的，其他的地址对应到BIOS的ROM，内卡的ROM。具体见下表：</p><table><thead><tr><th><strong>起始</strong></th><th><strong>结束</strong></th><th><strong>大小</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr><td>FFFF0</td><td>FFFFF</td><td>16B</td><td>BIOS入口地址，此地址也属于BIOS代码，同样属于顶部的640KB字节。只是为了强调其入口地址才单独贴出来。此处16字节的内容是跳转指令jmp f000：e05b</td></tr><tr><td>F0000</td><td>FFFEF</td><td>64KB-16B</td><td>系统BIOS范围是F0000～FFFFF共640KB，为说明入口地址，将最上面的16字节从此处去掉了，所以此处终止地址是0XFFFEF</td></tr><tr><td>C8000</td><td>EFFFF</td><td>160KB</td><td>映射硬件适配器的ROM或内存映射式I/O</td></tr><tr><td>C0000</td><td>C7FFF</td><td>32KB</td><td>显示适配器BIOS</td></tr><tr><td>B8000</td><td>BFFFF</td><td>32KB</td><td>用于文本模式显示适配器</td></tr><tr><td>B0000</td><td>B7FFF</td><td>32KB</td><td>用于黑白显示适配器</td></tr><tr><td>A0000</td><td>AFFFF</td><td>64KB</td><td>用于彩色显示适配器</td></tr><tr><td>9FC00</td><td>9FFFF</td><td>1KB</td><td>EBDA（Extended BIOS Data Area）扩展BIOS数据区</td></tr><tr><td>7E00</td><td>9FBFF</td><td>622080B约608KB</td><td>可用区域</td></tr><tr><td>7C00</td><td>7DFF</td><td>512B</td><td>MBR被BIOS加载到此处，共512字节</td></tr><tr><td>500</td><td>7BFF</td><td>30464B约30KB</td><td>可用区域</td></tr><tr><td>400</td><td>4FF</td><td>256B</td><td>BIOS Data Area（BIOS数据区）</td></tr><tr><td>000</td><td>3FF</td><td>1KB</td><td>Interrupt Vector Table（中断向量表）</td></tr></tbody></table><p>其中0~0x9FFFF对应到DRAM。</p><p>BIOS中也有只读存储器ROM，保存BIOS的程序，F0000~FFFFF这64KB空间对应的是BIOS ROM。</p><h2 id="0xF000-0xFFF0地址有什么特别意义"><a href="#0xF000-0xFFF0地址有什么特别意义" class="headerlink" title="0xF000:0xFFF0地址有什么特别意义"></a>0xF000:0xFFF0地址有什么特别意义</h2><p>前文提到，CPU在加电后，会强制初始化cs:ip寄存器为0xF000:0xFFF0，按分段寻址的公式计算：0xF000*16+0xFFF0=0xFFFF0。</p><p>这个地址对应的是什么数据呢？我们看下上面的实模式1MB内存布局的表格，可以看到F0000~FFFFF是BIOS程序的地址，而0xFFFF0则是指向最后16字节的地址。</p><p>也就是说，CPU启动后，会强制初始化cs:ip寄存器为0xF000:0xFFF0，是为了取到这个地址的执行去执行，而这个地址是BIOS程序的一个部分，也就是说，CPU启动后，就开始执行BIOS的自带的程序。</p><p>所以可以推论，CPU启动后，就开始执行BIOS程序，这是电脑设计者的目的，同时他们规定了1MB的最后16字节为BIOS程序的入口，基于这种规定，CPU才会做出强制初始化cs:ip寄存器为0xF000:0xFFF0的行为。</p><p>那这个0xFFFF0地址对应的指令具体是啥呢？</p><p><a href="http://imushan.com/2018/07/11/os/Bochs%E5%AD%A6%E4%B9%A0-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E7%AF%87/" target="_blank" rel="noopener">Bochs学习-安装配置篇</a>有提到bochs启动后会自动暂停，那个时候就是CPU一条指令还未执行的时候，我们来看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  /Users/mazhibin/project/system/bochs-conf-file &gt; bochs -q</span><br><span class="line">========================================================================</span><br><span class="line">                        Bochs x86 Emulator 2.6</span><br><span class="line">            Built from SVN snapshot on September 2nd, 2012</span><br><span class="line">                  Compiled on May  5 2018 at 23:07:30</span><br><span class="line">========================================================================</span><br><span class="line">00000000000i[     ] reading configuration from bochsrc.txt</span><br><span class="line">00000000000i[     ] installing sdl module as the Bochs GUI</span><br><span class="line">00000000000i[     ] using log file bochsout.txt</span><br><span class="line">Next at t=0</span><br><span class="line">(0) [0x00000000fffffff0] f000:fff0 (unk. ctxt): jmp far f000:e05b         ; ea5be000f0</span><br><span class="line">&lt;bochs:1&gt;</span><br></pre></td></tr></table></figure><p>可以看到，bochs显示了CPU接下来要执行的指令，也就是cs:ip寄存器指向的内存区域中存放的指令，地址是f000:fff0，这也印证了CPU在启动时，cs:ip的值会被设置为0xF000:0xFFF0。指令内容是<code>jmp far f000:e05b</code>，一个跳转指令，跳到了BIOS程序的入口，接下来BIOS程序开始检测内存，显卡的外设信息，初始化硬件，并在0x000~0x3FF内存区域中建立中断向量表。</p><p>BIOS程序执行完后，就会开始从可能的启动设备中启动操作系统，这个后面来继续学习。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>x86CPU启动后进入实模式</li><li>实模式下使用20位的地址线，可以寻址1MB内存</li><li>实模式下使用分段的方式访问1MB的空间，方法是两个寄存器，一个保存段基址，一个保存段内偏移，然后通过公式：段基址*16+段内偏移，得到20位的地址</li><li>CPU通电后，cs:ip寄存器会被强制更新为0xF000:0xFFF0，这个地址指向BOIS程序的入口</li><li>所以CPU通电后，就会开始执行BOIS的程序，检测并初始化硬件，最后BIOS程序尝试从可能的启动设备中启动操作系统。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《操作系统真象还原》</li><li><a href="https://www.cnblogs.com/licb/p/8086segment.html" target="_blank" rel="noopener">8086处理器为什么要采用分段机制 - lichongbin - 博客园</a></li><li><a href="https://www.cnblogs.com/blacksword/archive/2012/12/27/2836216.html" target="_blank" rel="noopener">8086/8088 存储器分段概念 - 黑剑 - 博客园</a></li><li><a href="https://www.cnblogs.com/chengxuyuancc/archive/2013/05/12/3073738.html" target="_blank" rel="noopener">实模式、保护模式和虚拟模式 - 在于思考 - 博客园</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前每次开机，先是看到一个黑屏幕上显示一些字符，然后会进入windows经典的启动界面。对于要编写操作系统来说，这种表面的认识是不够的，得需要知道一下通电后，执行的入口是哪里，启动的流程是如何跑起来的。&lt;/p&gt;
    
    </summary>
    
      <category term="自己动手写操作系统" scheme="http://mushanshitiancai.github.io/categories/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="os" scheme="http://mushanshitiancai.github.io/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>Bochs学习-安装配置篇</title>
    <link href="http://mushanshitiancai.github.io/2018/07/11/os/Bochs%E5%AD%A6%E4%B9%A0-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E7%AF%87/"/>
    <id>http://mushanshitiancai.github.io/2018/07/11/os/Bochs学习-安装配置篇/</id>
    <published>2018-07-11T12:33:37.000Z</published>
    <updated>2018-07-22T13:14:01.133Z</updated>
    
    <content type="html"><![CDATA[<p>最近想学习如何从零编写一个操作系统，现在关于这个的资料蛮多的，《操作系统真象还原》，就是一本神级别的书，看得我醍醐灌顶。其他的书籍还有《Orange’S:一个操作系统的实现》，《30天自制操作系统》。</p><p>自己动手写操作系统，虚拟机是必不可少的，虽然我们的目标是写出一个物理机可以安装可以运行的操作系统，但是用物理机会非常的麻烦也花钱。虚拟机中，vmware和virtualbox比较出名，但是却不适合我们的场景，因为这两个虚拟机更注重效率，所以会使用硬件级的虚拟化，所以在硬件调试上，功能有限，而bochs这个开源虚拟机，是用软件虚拟了所有的硬件，所以调试可以做到非常细的粒度，比如每次cpu执行命令，我们都可以暂停，看寄存器状态，看内存状态，这对于操作系统开发调试的帮助太大太大了。所以我们使用bochs这个虚拟机来。</p><!-- mor --><h2 id="Mac安装bochs"><a href="#Mac安装bochs" class="headerlink" title="Mac安装bochs"></a>Mac安装bochs</h2><p>我的macOS的版本是10.13.2，使用brew大法安装bochs竟然报错了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install bochs（bochs2.6.9安装失败）</span><br><span class="line">cdrom_osx.cc:194:18: error: assigning to &apos;char *&apos; from incompatible type &apos;const char *&apos;</span><br></pre></td></tr></table></figure><p>可能是因为系统版本较新，Xcode的某些升级导致编译源码不通过。</p><p>查阅了许多资料后，得到的正确安装步骤如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 安装SDL</span><br><span class="line">brew install sdl</span><br><span class="line"></span><br><span class="line"># 先从官网下载bochs-2.6.tar.gz，地址https://sourceforge.net/projects/bochs/files/bochs/</span><br><span class="line">$ tar -xvf bochs-2.6.tar.gz</span><br><span class="line">$ wget https://raw.githubusercontent.com/Homebrew/formula-patches/e9b520dd4c/bochs/xcode9.patch</span><br><span class="line">$ cd bochs-2.6</span><br><span class="line">$ patch -p1 &lt; ../xcode9.patch</span><br><span class="line"></span><br><span class="line">修改config.cc的3621行</span><br><span class="line">if (SIM-&gt;get_param_string(&quot;model&quot;, base)-&gt;getptr()&gt;0) &#123;</span><br><span class="line">为</span><br><span class="line">if (SIM-&gt;get_param_string(&quot;model&quot;, base)-&gt;getptr()&gt;(char *)0) &#123;</span><br><span class="line"></span><br><span class="line">$ ./configure --enable-ne2000 \</span><br><span class="line">            --enable-all-optimizations \</span><br><span class="line">            --enable-cpu-level=6 \</span><br><span class="line">            --enable-x86-64 \</span><br><span class="line">            --enable-vmx=2 \</span><br><span class="line">            --enable-pci \</span><br><span class="line">            --enable-usb \</span><br><span class="line">            --enable-usb-ohci \</span><br><span class="line">            --enable-e1000 \</span><br><span class="line">            --enable-debugger \</span><br><span class="line">            --enable-disasm \</span><br><span class="line">            --disable-debugger-gui \</span><br><span class="line">            --with-sdl \</span><br><span class="line">            --prefix=$HOME/software/bochs</span><br><span class="line">$ make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p><code>--prefix=$HOME/software/bochs</code>这一句可以指定安装bochs到哪个目录下。</p><p>命令行中运行<code>bochs</code>，可以看到bochs的提示界面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">========================================================================</span><br><span class="line">                        Bochs x86 Emulator 2.6</span><br><span class="line">            Built from SVN snapshot on September 2nd, 2012</span><br><span class="line">                  Compiled on May  5 2018 at 23:07:30</span><br><span class="line">========================================================================</span><br><span class="line">------------------------------</span><br><span class="line">Bochs Configuration: Main Menu</span><br><span class="line">------------------------------</span><br><span class="line"></span><br><span class="line">This is the Bochs Configuration Interface, where you can describe the</span><br><span class="line">machine that you want to simulate.  Bochs has already searched for a</span><br><span class="line">configuration file (typically called bochsrc.txt) and loaded it if it</span><br><span class="line">could be found.  When you are satisfied with the configuration, go</span><br><span class="line">ahead and start the simulation.</span><br><span class="line"></span><br><span class="line">You can also start bochs with the -q option to skip these menus.</span><br><span class="line"></span><br><span class="line">1. Restore factory default configuration</span><br><span class="line">2. Read options from...</span><br><span class="line">3. Edit options</span><br><span class="line">4. Save options to...</span><br><span class="line">5. Restore the Bochs state from...</span><br><span class="line">6. Begin simulation</span><br><span class="line">7. Quit now</span><br><span class="line"></span><br><span class="line">Please choose one: [2]</span><br></pre></td></tr></table></figure><p>说明信息中说，这个界面是用于指定启动什么虚拟机的。默认情况下bochs会搜索名为<code>boshcsrc.txt</code>的配置文件，并从配置文件中得到虚拟机信息，进而启动虚拟机。配置文件也可以叫别的名称，只要在这个界面指定配置文件名即可。</p><p>所以，在真正启动虚拟机之前，我们需要写一份配置文件。</p><h2 id="bochs配置文件"><a href="#bochs配置文件" class="headerlink" title="bochs配置文件"></a>bochs配置文件</h2><p>bochs的安装目录下的<code>bochs/share/doc/bochs/bochsrc-sample.txt</code>是配置文件的模板。这个文件非常详细，包含了所有的配置项与详细说明。我们需要的配置项有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line">#=======================================================================</span><br><span class="line"># MEGS</span><br><span class="line"># Set the number of Megabytes of physical memory you want to emulate. </span><br><span class="line"># The default is 32MB, most OS&apos;s won&apos;t need more than that.</span><br><span class="line"># The maximum amount of memory supported is 2048Mb.</span><br><span class="line"># The &apos;MEGS&apos; option is deprecated. Use &apos;MEMORY&apos; option instead.</span><br><span class="line">#=======================================================================</span><br><span class="line">#megs: 256</span><br><span class="line">#megs: 128</span><br><span class="line">#megs: 64</span><br><span class="line">#megs: 32</span><br><span class="line">#megs: 16</span><br><span class="line">#megs: 8</span><br><span class="line"></span><br><span class="line">#=======================================================================</span><br><span class="line"># ROMIMAGE:</span><br><span class="line"># The ROM BIOS controls what the PC does when it first powers on.</span><br><span class="line"># Normally, you can use a precompiled BIOS in the source or binary</span><br><span class="line"># distribution called BIOS-bochs-latest. The ROM BIOS is usually loaded</span><br><span class="line"># starting at address 0xf0000, and it is exactly 64k long. Another option</span><br><span class="line"># is 128k BIOS which is loaded at address 0xe0000.</span><br><span class="line"># You can also use the environment variable $BXSHARE to specify the</span><br><span class="line"># location of the BIOS.</span><br><span class="line"># The usage of external large BIOS images (up to 512k) at memory top is</span><br><span class="line"># now supported, but we still recommend to use the BIOS distributed with</span><br><span class="line"># Bochs. The start address optional, since it can be calculated from image size.</span><br><span class="line">#=======================================================================</span><br><span class="line">romimage: file=$BXSHARE/BIOS-bochs-latest </span><br><span class="line">#romimage: file=bios/seabios-1.6.3.bin</span><br><span class="line">#romimage: file=mybios.bin, address=0xfff80000 # 512k at memory top</span><br><span class="line"></span><br><span class="line">#=======================================================================</span><br><span class="line"># VGAROMIMAGE</span><br><span class="line"># You now need to load a VGA ROM BIOS into C0000.</span><br><span class="line">#=======================================================================</span><br><span class="line">#vgaromimage: file=bios/VGABIOS-elpin-2.40</span><br><span class="line">vgaromimage: file=$BXSHARE/VGABIOS-lgpl-latest</span><br><span class="line">#vgaromimage: file=bios/VGABIOS-lgpl-latest-cirrus</span><br><span class="line"></span><br><span class="line">#=======================================================================</span><br><span class="line"># FLOPPYA:</span><br><span class="line"># Point this to pathname of floppy image file or device</span><br><span class="line"># This should be of a bootable floppy(image/device) if you&apos;re</span><br><span class="line"># booting from &apos;a&apos; (or &apos;floppy&apos;).</span><br><span class="line">#</span><br><span class="line"># You can set the initial status of the media to &apos;ejected&apos; or &apos;inserted&apos;.</span><br><span class="line">#   floppya: 2_88=path, status=ejected    (2.88M 3.5&quot;  media)</span><br><span class="line">#   floppya: 1_44=path, status=inserted   (1.44M 3.5&quot;  media)</span><br><span class="line">#   floppya: 1_2=path, status=ejected     (1.2M  5.25&quot; media)</span><br><span class="line">#   floppya: 720k=path, status=inserted   (720K  3.5&quot;  media)</span><br><span class="line">#   floppya: 360k=path, status=inserted   (360K  5.25&quot; media)</span><br><span class="line">#   floppya: 320k=path, status=inserted   (320K  5.25&quot; media)</span><br><span class="line">#   floppya: 180k=path, status=inserted   (180K  5.25&quot; media)</span><br><span class="line">#   floppya: 160k=path, status=inserted   (160K  5.25&quot; media)</span><br><span class="line">#   floppya: image=path, status=inserted  (guess media type from image size)</span><br><span class="line">#   floppya: 1_44=vvfat:path, status=inserted  (use directory as VFAT media)</span><br><span class="line">#   floppya: type=1_44                    (1.44M 3.5&quot; floppy drive, no media)</span><br><span class="line">#</span><br><span class="line"># The path should be the name of a disk image file.  On Unix, you can use a raw</span><br><span class="line"># device name such as /dev/fd0 on Linux.  On win32 platforms, use drive letters</span><br><span class="line"># such as a: or b: as the path.  The parameter &apos;image&apos; works with image files</span><br><span class="line"># only. In that case the size must match one of the supported types.</span><br><span class="line"># The parameter &apos;type&apos; can be used to enable the floppy drive without media</span><br><span class="line"># and status specified. Usually the drive type is set up based on the media type.</span><br><span class="line"># The optional parameter &apos;write_protected&apos; can be used to control the media</span><br><span class="line"># write protect switch. By default it is turned off.</span><br><span class="line">#=======================================================================</span><br><span class="line">floppya: 1_44=/dev/fd0, status=inserted</span><br><span class="line">#floppya: image=../1.44, status=inserted</span><br><span class="line">#floppya: 1_44=/dev/fd0H1440, status=inserted</span><br><span class="line">#floppya: 1_2=../1_2, status=inserted</span><br><span class="line">#floppya: 1_44=a:, status=inserted</span><br><span class="line">#floppya: 1_44=a.img, status=inserted, write_protected=1</span><br><span class="line">#floppya: 1_44=/dev/rfd0a, status=inserted</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#=======================================================================</span><br><span class="line"># BOOT:</span><br><span class="line"># This defines the boot sequence. Now you can specify up to 3 boot drives,</span><br><span class="line"># which can be &apos;floppy&apos;, &apos;disk&apos;, &apos;cdrom&apos; or &apos;network&apos; (boot ROM).</span><br><span class="line"># Legacy &apos;a&apos; and &apos;c&apos; are also supported.</span><br><span class="line"># Examples:</span><br><span class="line">#   boot: floppy</span><br><span class="line">#   boot: cdrom, disk</span><br><span class="line">#   boot: network, disk</span><br><span class="line">#   boot: cdrom, floppy, disk</span><br><span class="line">#=======================================================================</span><br><span class="line">#boot: floppy</span><br><span class="line">boot: disk</span><br><span class="line"></span><br><span class="line">#=======================================================================</span><br><span class="line"># LOG:</span><br><span class="line"># Give the path of the log file you&apos;d like Bochs debug and misc. verbiage</span><br><span class="line"># to be written to. If you don&apos;t use this option or set the filename to</span><br><span class="line"># &apos;-&apos; the output is written to the console. If you really don&apos;t want it,</span><br><span class="line"># make it &quot;/dev/null&quot; (Unix) or &quot;nul&quot; (win32). :^(</span><br><span class="line">#</span><br><span class="line"># Examples:</span><br><span class="line">#   log: ./bochs.out</span><br><span class="line">#   log: /dev/tty</span><br><span class="line">#=======================================================================</span><br><span class="line">#log: /dev/null</span><br><span class="line">log: bochsout.txt</span><br><span class="line"></span><br><span class="line">#=======================================================================</span><br><span class="line"># MOUSE:</span><br><span class="line"># This defines parameters for the emulated mouse type, the initial status</span><br><span class="line"># of the mouse capture and the runtime method to toggle it.</span><br><span class="line">#</span><br><span class="line">#  TYPE:</span><br><span class="line">#  With the mouse type option you can select the type of mouse to emulate.</span><br><span class="line">#  The default value is &apos;ps2&apos;. The other choices are &apos;imps2&apos; (wheel mouse</span><br><span class="line">#  on PS/2), &apos;serial&apos;, &apos;serial_wheel&apos; and &apos;serial_msys&apos; (one com port requires</span><br><span class="line">#  setting &apos;mode=mouse&apos;). To connect a mouse to an USB port, see the &apos;usb_uhci&apos;,</span><br><span class="line">#  &apos;usb_ohci&apos; or &apos;usb_xhci&apos; options (requires PCI and USB support).</span><br><span class="line">#</span><br><span class="line">#  ENABLED:</span><br><span class="line">#  The Bochs gui creates mouse &quot;events&quot; unless the &apos;enabled&apos; option is</span><br><span class="line">#  set to 0. The hardware emulation itself is not disabled by this.</span><br><span class="line">#  Unless you have a particular reason for enabling the mouse by default,</span><br><span class="line">#  it is recommended that you leave it off. You can also toggle the mouse</span><br><span class="line">#  usage at runtime (RFB, SDL, Win32, wxWidgets and X11 - see below).</span><br><span class="line">#</span><br><span class="line">#  TOGGLE:</span><br><span class="line">#  The default method to toggle the mouse capture at runtime is to press the</span><br><span class="line">#  CTRL key and the middle mouse button (&apos;ctrl+mbutton&apos;). This option allows</span><br><span class="line">#  to change the method to &apos;ctrl+f10&apos; (like DOSBox), &apos;ctrl+alt&apos; (like QEMU)</span><br><span class="line">#  or &apos;f12&apos; (replaces win32 &apos;legacyF12&apos; option).</span><br><span class="line">#</span><br><span class="line"># Examples:</span><br><span class="line">#   mouse: enabled=1</span><br><span class="line">#   mouse: type=imps2, enabled=1</span><br><span class="line">#   mouse: type=serial, enabled=1</span><br><span class="line">#   mouse: enabled=0, toggle=ctrl+f10</span><br><span class="line">#=======================================================================</span><br><span class="line">mouse: enabled=0</span><br><span class="line"></span><br><span class="line">#=======================================================================</span><br><span class="line"># KEYBOARD:</span><br><span class="line"># This defines parameters related to the emulated keyboard</span><br><span class="line">#</span><br><span class="line">#   TYPE:</span><br><span class="line">#     Type of keyboard return by a &quot;identify keyboard&quot; command to the</span><br><span class="line">#     keyboard controller. It must be one of &quot;xt&quot;, &quot;at&quot; or &quot;mf&quot;.</span><br><span class="line">#     Defaults to &quot;mf&quot;. It should be ok for almost everybody. A known</span><br><span class="line">#     exception is french macs, that do have a &quot;at&quot;-like keyboard.</span><br><span class="line">#</span><br><span class="line">#   SERIAL_DELAY:</span><br><span class="line">#     Approximate time in microseconds that it takes one character to</span><br><span class="line">#     be transferred from the keyboard to controller over the serial path.</span><br><span class="line">#</span><br><span class="line">#   PASTE_DELAY:</span><br><span class="line">#     Approximate time in microseconds between attempts to paste</span><br><span class="line">#     characters to the keyboard controller. This leaves time for the</span><br><span class="line">#     guest os to deal with the flow of characters.  The ideal setting</span><br><span class="line">#     depends on how your operating system processes characters.  The</span><br><span class="line">#     default of 100000 usec (.1 seconds) was chosen because it works </span><br><span class="line">#     consistently in Windows.</span><br><span class="line">#     If your OS is losing characters during a paste, increase the paste</span><br><span class="line">#     delay until it stops losing characters.</span><br><span class="line">#</span><br><span class="line">#   KEYMAP:</span><br><span class="line">#     This enables a remap of a physical localized keyboard to a</span><br><span class="line">#     virtualized us keyboard, as the PC architecture expects.</span><br><span class="line">#</span><br><span class="line"># Examples:</span><br><span class="line">#   keyboard: type=mf, serial_delay=200, paste_delay=100000</span><br><span class="line">#   keyboard: keymap=gui/keymaps/x11-pc-de.map</span><br><span class="line">#=======================================================================</span><br><span class="line">#keyboard: type=mf, serial_delay=250</span><br><span class="line"></span><br><span class="line">#=======================================================================</span><br><span class="line"># ATA0, ATA1, ATA2, ATA3</span><br><span class="line"># ATA controller for hard disks and cdroms</span><br><span class="line">#</span><br><span class="line"># ata[0-3]: enabled=[0|1], ioaddr1=addr, ioaddr2=addr, irq=number</span><br><span class="line"># </span><br><span class="line"># These options enables up to 4 ata channels. For each channel</span><br><span class="line"># the two base io addresses and the irq must be specified.</span><br><span class="line"># </span><br><span class="line"># ata0 and ata1 are enabled by default with the values shown below</span><br><span class="line">#</span><br><span class="line"># Examples:</span><br><span class="line">#   ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14</span><br><span class="line">#   ata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15</span><br><span class="line">#   ata2: enabled=1, ioaddr1=0x1e8, ioaddr2=0x3e0, irq=11</span><br><span class="line">#   ata3: enabled=1, ioaddr1=0x168, ioaddr2=0x360, irq=9</span><br><span class="line">#=======================================================================</span><br><span class="line">ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14</span><br><span class="line">ata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15</span><br><span class="line">ata2: enabled=0, ioaddr1=0x1e8, ioaddr2=0x3e0, irq=11</span><br><span class="line">ata3: enabled=0, ioaddr1=0x168, ioaddr2=0x360, irq=9</span><br><span class="line"></span><br><span class="line">#=======================================================================</span><br><span class="line"># GDBSTUB:</span><br><span class="line"># Enable GDB stub. See user documentation for details.</span><br><span class="line"># Default value is enabled=0.</span><br><span class="line">#=======================================================================</span><br><span class="line">#gdbstub: enabled=0, port=1234, text_base=0, data_base=0, bss_base=0</span><br></pre></td></tr></table></figure><p>上面是从<code>bochsrc-sample.txt</code>中摘取的我们需要的配置与说明，大家看了说明就对配置项有了解了。</p><p>最终的配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 设置虚拟机内存为32MB</span><br><span class="line">megs: 32</span><br><span class="line"></span><br><span class="line"># 设置BIOS镜像</span><br><span class="line">romimage: file=$BXSHARE/BIOS-bochs-latest </span><br><span class="line"></span><br><span class="line"># 设置VGA BIOS镜像</span><br><span class="line">vgaromimage: file=$BXSHARE/VGABIOS-lgpl-latest</span><br><span class="line"></span><br><span class="line"># 设置从硬盘启动</span><br><span class="line">boot: disk</span><br><span class="line"></span><br><span class="line"># 设置日志文件</span><br><span class="line">log: bochsout.txt</span><br><span class="line"></span><br><span class="line"># 关闭鼠标</span><br><span class="line">mouse: enabled=0</span><br><span class="line"></span><br><span class="line"># 打开键盘</span><br><span class="line">keyboard: type=mf, serial_delay=250</span><br><span class="line"></span><br><span class="line"># 设置硬盘</span><br><span class="line">ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14</span><br><span class="line"></span><br><span class="line"># 添加gdb远程调试支持</span><br><span class="line">gdbstub: enabled=1, port=1234, text_base=0, data_base=0, bss_base=0</span><br></pre></td></tr></table></figure><p>保存配置文件为bochsrc.txt，然后在该目录下运行bochs命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">➜  /Users/mazhibin/project/system/bochs-conf-file &gt; bochs</span><br><span class="line">========================================================================</span><br><span class="line">                        Bochs x86 Emulator 2.6</span><br><span class="line">            Built from SVN snapshot on September 2nd, 2012</span><br><span class="line">                  Compiled on May  5 2018 at 23:07:30</span><br><span class="line">========================================================================</span><br><span class="line">00000000000i[     ] reading configuration from bochsrc.txt</span><br><span class="line">------------------------------</span><br><span class="line">Bochs Configuration: Main Menu</span><br><span class="line">------------------------------</span><br><span class="line"></span><br><span class="line">This is the Bochs Configuration Interface, where you can describe the</span><br><span class="line">machine that you want to simulate.  Bochs has already searched for a</span><br><span class="line">configuration file (typically called bochsrc.txt) and loaded it if it</span><br><span class="line">could be found.  When you are satisfied with the configuration, go</span><br><span class="line">ahead and start the simulation.</span><br><span class="line"></span><br><span class="line">You can also start bochs with the -q option to skip these menus.</span><br><span class="line"></span><br><span class="line">1. Restore factory default configuration</span><br><span class="line">2. Read options from...</span><br><span class="line">3. Edit options</span><br><span class="line">4. Save options to...</span><br><span class="line">5. Restore the Bochs state from...</span><br><span class="line">6. Begin simulation</span><br><span class="line">7. Quit now</span><br><span class="line"></span><br><span class="line">Please choose one: [6] 6       ←这里按回车，表示读取bochsrc.txt的配置，启动模拟器</span><br><span class="line">00000000000i[     ] installing sdl module as the Bochs GUI</span><br><span class="line">00000000000i[     ] using log file bochsout.txt</span><br><span class="line">Next at t=0</span><br><span class="line">(0) [0x00000000fffffff0] f000:fff0 (unk. ctxt): jmp far f000:e05b         ; ea5be000f0</span><br><span class="line">&lt;bochs:1&gt; c       ←这里按c表示继续</span><br><span class="line">========================================================================</span><br><span class="line">Bochs is exiting with the following message:</span><br><span class="line">[BIOS ] No bootable device.</span><br><span class="line">========================================================================</span><br><span class="line">(0).[13925235] [0x00000000000f054a] f000:054a (unk. ctxt): out dx, al                ; ee</span><br></pre></td></tr></table></figure><p>bochs默认会在启动后暂停，我们按<code>c</code>，使bochs继续启动。最后bochs提示错误信息<code>[BIOS ] No bootable device.</code>并退出了虚拟机。</p><p><img src="/img/os/bochs-fail-1.png" alt=""></p><p>这和我们物理机一样，在没有安装硬盘的情况下，启动后就会提示没有可以用于启动的设备。所以我们需要弄一个硬盘出来。</p><h2 id="模拟硬盘"><a href="#模拟硬盘" class="headerlink" title="模拟硬盘"></a>模拟硬盘</h2><p>bochs作为一个模拟器，也提供了创建虚拟硬盘的工具bximage。这个工具提供了交互的方式来创建虚拟硬盘，我们来看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">➜  /Users/mazhibin/project/system/bochs-conf-file &gt; bximage</span><br><span class="line">========================================================================</span><br><span class="line">                                bximage</span><br><span class="line">                  Disk Image Creation Tool for Bochs</span><br><span class="line">          $Id: bximage.c 11315 2012-08-05 18:13:38Z vruppert $</span><br><span class="line">========================================================================</span><br><span class="line"></span><br><span class="line">Do you want to create a floppy disk image or a hard disk image?</span><br><span class="line">Please type hd or fd. [hd]  ← 按回车，表示新建硬盘</span><br><span class="line"></span><br><span class="line">What kind of image should I create?</span><br><span class="line">Please type flat, sparse or growing. [flat] ← 按回车，表示新建flat形式的硬盘</span><br><span class="line"></span><br><span class="line">Enter the hard disk size in megabytes, between 1 and 8257535</span><br><span class="line">[10] ← 按回车，表示新建10MB的硬盘</span><br><span class="line"></span><br><span class="line">I will create a &apos;flat&apos; hard disk image with</span><br><span class="line">  cyl=20</span><br><span class="line">  heads=16</span><br><span class="line">  sectors per track=63</span><br><span class="line">  total sectors=20160</span><br><span class="line">  total size=9.84 megabytes</span><br><span class="line"></span><br><span class="line">What should I name the image?</span><br><span class="line">[c.img] hd10m.img</span><br><span class="line"></span><br><span class="line">Writing: [] Done.</span><br><span class="line"></span><br><span class="line">I wrote 10321920 bytes to hd10m.img.</span><br><span class="line"></span><br><span class="line">The following line should appear in your bochsrc:</span><br><span class="line">  ata0-master: type=disk, path=&quot;hd10m.img&quot;, mode=flat, cylinders=20, heads=16, spt=63</span><br></pre></td></tr></table></figure><p>最后bximage命令提示我们，需要在bochs的配置文件中添加一行配置<code>ata0-master: type=disk, path=&quot;hd10m.img&quot;, mode=flat, cylinders=20, heads=16, spt=63</code>。我们这这行添加到bochsrc.txt后再次启动bochs：</p><p><img src="/img/os/bochs-fail-2.png" alt=""></p><p>最终的提示依然是<code>No bootable device</code>，但是仔细观察会发现，之前在没有配置硬盘是，详细的错误信息是<code>Boot failed: could not read the boot disk</code>，而再插入了空硬盘后，详细的错误信息是<code>Boot failed: not a bootable disk</code>。前者是说没有找到可以用于启动的硬盘，后者是说这个硬盘无法用来启动。</p><p>接下来就是如何在磁盘中写入启动信息，也就是主引导记录MBR了。后续的文章会继续学习。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://bochs.sourceforge.net/" target="_blank" rel="noopener">bochs: The Open Source IA-32 Emulation Project (Home Page)</a></li></ul><p>Mac编译安装bochs的参考资料：</p><ul><li><a href="https://blog.csdn.net/yzr1183739890/article/details/54864841" target="_blank" rel="noopener">mac 安装 bochs - CSDN博客</a></li><li><a href="https://blog.nswebfrog.com/2017/02/03/config-bochs/" target="_blank" rel="noopener">macOS 编译安装 bochs 虚拟机 | nswebfrog</a></li><li><a href="https://sourceforge.net/projects/bochs/?source=typ_redirect" target="_blank" rel="noopener">Bochs x86 PC emulator download | SourceForge.net</a></li><li><a href="https://sourceforge.net/p/bochs/patches/537/" target="_blank" rel="noopener">Bochs x86 PC emulator / Patches / #537 Compilation failure in cdrom_osx.cc</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近想学习如何从零编写一个操作系统，现在关于这个的资料蛮多的，《操作系统真象还原》，就是一本神级别的书，看得我醍醐灌顶。其他的书籍还有《Orange’S:一个操作系统的实现》，《30天自制操作系统》。&lt;/p&gt;
&lt;p&gt;自己动手写操作系统，虚拟机是必不可少的，虽然我们的目标是写
      
    
    </summary>
    
      <category term="自己动手写操作系统" scheme="http://mushanshitiancai.github.io/categories/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="os" scheme="http://mushanshitiancai.github.io/tags/os/"/>
    
      <category term="bochs" scheme="http://mushanshitiancai.github.io/tags/bochs/"/>
    
  </entry>
  
  <entry>
    <title>Java如何保证文件落盘？</title>
    <link href="http://mushanshitiancai.github.io/2018/06/18/java/language/Java%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%96%87%E4%BB%B6%E8%90%BD%E7%9B%98%EF%BC%9F/"/>
    <id>http://mushanshitiancai.github.io/2018/06/18/java/language/Java如何保证文件落盘？/</id>
    <published>2018-06-18T13:20:49.000Z</published>
    <updated>2018-07-11T12:32:38.351Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的文章<a href="http://imushan.com/2018/06/17/linux/Linux-UNIX%E7%BC%96%E7%A8%8B%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%96%87%E4%BB%B6%E8%90%BD%E7%9B%98/" target="_blank" rel="noopener">Linux/UNIX编程如何保证文件落盘</a>中，我们聊了从应用到操作系统，我们要如何保证文件落盘，来确保掉电等故障不会导致数据丢失。JDK也封装了对应的功能，并且为我们做好了跨平台的保证。</p><a id="more"></a><p>JDK中有三种方式可以强制文件数据落盘：</p><ol><li>调用<code>FileDescriptor#sync</code>函数</li><li>调用<code>FileChannel#force</code>函数</li><li>使用<code>RandomAccessFile</code>以<code>rws</code>或者<code>rwd</code>模式打开文件</li></ol><h2 id="FileDescriptor-sync"><a href="#FileDescriptor-sync" class="headerlink" title="FileDescriptor#sync"></a><code>FileDescriptor#sync</code></h2><p><code>FileDescriptor</code>类提供了<code>sync</code>方法，可以用于保证数据保存到持久化存储设备后返回：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"/Users/mazhibin/b.txt"</span>);</span><br><span class="line">outputStream.getFD().sync();</span><br></pre></td></tr></table></figure><p>可以看一下JDK是如何实现<code>FileDescriptor#sync</code>的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span> <span class="keyword">throws</span> SyncFailedException</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk/src/solaris/native/java/io/FileDescriptor_md.c</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_java_io_FileDescriptor_sync(JNIEnv *env, jobject <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取文件描述符</span></span><br><span class="line">    FD fd = THIS_FD(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 调用IO_Sync来执行数据同步</span></span><br><span class="line">    <span class="keyword">if</span> (IO_Sync(fd) == <span class="number">-1</span>) &#123;</span><br><span class="line">        JNU_ThrowByName(env, <span class="string">"java/io/SyncFailedException"</span>, <span class="string">"sync failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>IO_Sync</code>在UNIX系统上的定义就是<code>fsync</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk/src/solaris/native/java/io/io_util_md.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IO_Sync fsync</span></span><br></pre></td></tr></table></figure><h2 id="FileChannel-force"><a href="#FileChannel-force" class="headerlink" title="FileChannel#force"></a><code>FileChannel#force</code></h2><p>之前的文章提到了，操作系统提供了<code>fsync</code>/<code>fdatasync</code>两个用户同步数据到持久化设备的系统调用，后者尽可能的会不同步文件元数据，来减少一次磁盘IO，提高性能。但是Java IO的<code>FileDescriptor#sync</code>只是对fsync的封装，JDK中没有对于<code>fdatasync</code>的封装，这是一个特性缺失。</p><p>Java NIO对这一点也做了增强，<code>FileChannel</code>类的<code>force</code>方法，支持传入一个布尔参数<code>metaData</code>，表示是否需要确保文件元数据落盘，如果为<code>true</code>，则调用<code>fsync</code>。如果为<code>false</code>，则调用<code>fdatasync</code>。</p><p>使用范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"/Users/mazhibin/b.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制文件数据与元数据落盘</span></span><br><span class="line">outputStream.getChannel().force(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制文件数据落盘，不关心元数据是否落盘</span></span><br><span class="line">outputStream.getChannel().force(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>我们来看看其实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileChannelImpl</span> <span class="keyword">extends</span> <span class="title">FileChannel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FileDispatcher nd;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FileDescriptor fd;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NativeThreadSet threads = <span class="keyword">new</span> NativeThreadSet(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> open;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureOpen</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.isOpen()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 布尔参数metaData用于指定是否需要文件元数据也确保落盘</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">force</span><span class="params">(<span class="keyword">boolean</span> metaData)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 确保文件是已经打开的</span></span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="keyword">int</span> rv = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ti = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            begin();</span><br><span class="line">            ti = threads.add();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 再次确保文件是已经打开的</span></span><br><span class="line">            <span class="keyword">if</span> (!isOpen())</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 调用FileDispatcher#force</span></span><br><span class="line">                rv = nd.force(fd, metaData);</span><br><span class="line">            &#125; <span class="keyword">while</span> ((rv == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threads.remove(ti);</span><br><span class="line">            end(rv &gt; -<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">assert</span> IOStatus.check(rv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现中有许多线程同步相关的代码，不属于我们要关注的部分，就不分析了。<code>FileChannel#force</code>调用<code>FileDispatcher#force</code>。</p><p><code>FileDispatcher</code>是NIO内部实现用的一个类，封装了一些文件操作方法，其中包含了刷新文件的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDispatcher</span> <span class="keyword">extends</span> <span class="title">NativeDispatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">force</span><span class="params">(FileDescriptor fd, <span class="keyword">boolean</span> metaData)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FileDispatcher#force</code>的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileDispatcherImpl</span> <span class="keyword">extends</span> <span class="title">FileDispatcher</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">force</span><span class="params">(FileDescriptor fd, <span class="keyword">boolean</span> metaData)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> force0(fd, metaData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">force0</span><span class="params">(FileDescriptor fd, <span class="keyword">boolean</span> metaData)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FileDispatcher#force</code>的本地方法实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">Java_sun_nio_ch_FileDispatcherImpl_force0(JNIEnv *env, jobject <span class="keyword">this</span>,</span><br><span class="line">                                          jobject fdo, jboolean md)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取文件描述符</span></span><br><span class="line">    jint fd = fdval(env, fdo);</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (md == JNI_FALSE) &#123;</span><br><span class="line">        <span class="comment">// 如果调用者认为不需要同步文件元数据，调用fdatasync</span></span><br><span class="line">        result = fdatasync(fd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">#ifdef _AIX</span><br><span class="line">        <span class="comment">/* On AIX, calling fsync on a file descriptor that is opened only for</span></span><br><span class="line"><span class="comment">         * reading results in an error ("EBADF: The FileDescriptor parameter is</span></span><br><span class="line"><span class="comment">         * not a valid file descriptor open for writing.").</span></span><br><span class="line"><span class="comment">         * However, at this point it is not possibly anymore to read the</span></span><br><span class="line"><span class="comment">         * 'writable' attribute of the corresponding file channel so we have to</span></span><br><span class="line"><span class="comment">         * use 'fcntl'.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> getfl = fcntl(fd, F_GETFL);</span><br><span class="line">        <span class="keyword">if</span> (getfl &gt;= <span class="number">0</span> &amp;&amp; (getfl &amp; O_ACCMODE) == O_RDONLY) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">// 如果调用者认为需要同步文件元数据，调用fsync</span></span><br><span class="line">        result = fsync(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handle(env, result, <span class="string">"Force failed"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，其实就是简单的通过<code>metaData</code>参数来区分调用<code>fsync</code>和<code>fdatasync</code>。</p><h2 id="RandomAccessFile结合rws-rwd模式"><a href="#RandomAccessFile结合rws-rwd模式" class="headerlink" title="RandomAccessFile结合rws/rwd模式"></a>RandomAccessFile结合rws/rwd模式</h2><p><code>RandomAccessFile</code>打开文件支持4中模式：</p><ul><li>“r”    以只读方式打开。调用结果对象的任何 write 方法都将导致抛出 IOException。</li><li>“rw”    打开以便读取和写入。如果该文件尚不存在，则尝试创建该文件。</li><li>“rws”    打开以便读取和写入，对于 “rw”，还要求对文件的内容或元数据的每个更新都同步写入到底层存储设备。</li><li>“rwd” 打开以便读取和写入，对于 “rw”，还要求对文件内容的每个更新都同步写入到底层存储设备。</li></ul><p>其中<code>rws</code>模式会在<code>open</code>文件时传入<code>O_SYNC</code>标志位。<code>rwd</code>模式会在<code>open</code>文件时传入<code>O_DSYNC</code>标志位。</p><p>具体的源码分析参考：<a href="http://imushan.com/2018/06/04/java/language/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-RandomAccessFile/" target="_blank" rel="noopener">JDK源码阅读-RandomAccessFile</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://yongkunphd.blogspot.com/2013/12/how-fsync-works-in-java.html" target="_blank" rel="noopener">PhD’s Research</a></li><li><a href="https://stackoverflow.com/questions/730521/really-force-file-sync-flush-in-java" target="_blank" rel="noopener">storage - Really force file sync/flush in Java - Stack Overflow</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前的文章&lt;a href=&quot;http://imushan.com/2018/06/17/linux/Linux-UNIX%E7%BC%96%E7%A8%8B%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%96%87%E4%BB%B6%E8%90%BD%E7%9B%98/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux/UNIX编程如何保证文件落盘&lt;/a&gt;中，我们聊了从应用到操作系统，我们要如何保证文件落盘，来确保掉电等故障不会导致数据丢失。JDK也封装了对应的功能，并且为我们做好了跨平台的保证。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://mushanshitiancai.github.io/categories/Java/"/>
    
    
      <category term="java" scheme="http://mushanshitiancai.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Linux/UNIX编程如何保证文件落盘</title>
    <link href="http://mushanshitiancai.github.io/2018/06/17/linux/Linux-UNIX%E7%BC%96%E7%A8%8B%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%96%87%E4%BB%B6%E8%90%BD%E7%9B%98/"/>
    <id>http://mushanshitiancai.github.io/2018/06/17/linux/Linux-UNIX编程如何保证文件落盘/</id>
    <published>2018-06-17T15:12:09.000Z</published>
    <updated>2018-06-18T13:07:02.003Z</updated>
    
    <content type="html"><![CDATA[<p>我们编写程序write数据到文件中时，其实数据不会立马写入磁盘，而是会经过层层缓存。每层缓存都有自己的刷新时机，每层缓存都刷新后才会写入磁盘。这些缓存的存在是为了加速读写操作，因为如果每次读写都对应真实磁盘操作，那么读写的效率会大大降低。带来的坏处是如果期间发生掉电或者别的故障，还未写入磁盘的数据就丢失了。对于数据安全敏感的应用，比如数据库，比如交易程序，这是无法忍受的。所以操作系统提供了保证文件落盘的机制。我们来看下这些机制的原理和使用。</p><a id="more"></a><h2 id="I-O缓冲区机制"><a href="#I-O缓冲区机制" class="headerlink" title="I/O缓冲区机制"></a>I/O缓冲区机制</h2><p><img src="/img/linux/os-buffers.png" alt=""></p><p>图片来自：<a href="https://lwn.net/Articles/457667/" target="_blank" rel="noopener">https://lwn.net/Articles/457667/</a></p><p>上图说明了操作系统到磁盘的数据流，以及经过的缓冲区。首先数据会先存在于应用的内存空间，如果调用库函数写入，库函数可能还会把数据缓存在库函数所维护的缓冲区空间中，比如C标准库stdio提供的方法就会进行缓存，目的是为了减少系统调用的次数。这两个缓存都是在用户空间中的。库函数缓存刷新时，会调用write系统调用写入内核空间，内核同样维护了一个页缓存（page cache），操作系统会在合适的时间把脏页的数据写入磁盘。即使是写入磁盘了，磁盘也可能维护了一个缓存，在这个时候掉电依然会丢失数据的，只有写入了磁盘的持久存储物理介质上，数据才是真正的落盘了，是安全的。我们接下来就是要研究如何做到这一步。</p><h2 id="用户空间缓冲区"><a href="#用户空间缓冲区" class="headerlink" title="用户空间缓冲区"></a>用户空间缓冲区</h2><p>用户空间的缓存分为应用程序本身维护的缓冲区与库维护的缓冲区。</p><p>应用本身维护的缓冲区需要开发者自己刷新，调用库函数写入到库函数的缓冲区中。如果应用程序不依赖任何库函数，而是直接使用系统调用，那么则是把数据写入系统的缓冲区去。</p><p>库函数一般都会维护缓冲区，目的是简化应用程序的编写，应用程序就不需要编写维护缓冲区的代码，同时性能也得到了提高，因为缓冲区大大减少了系统调用的次数，而系统调用是非常耗时的，系统调用涉及到用户态到内核态的切换，这个切换需要很多的步骤与校验，较为耗时。</p><p>比如C标准库stdio就维护着一个缓冲区，对应这个缓冲区，C标准库提供了<code>fflush</code>方法强制把缓冲区数据写入操作系统。</p><p>Java的<code>OutputStream</code>接口提供了一个<code>flush</code>方法，具体的作用要看实现类的具体实现。<code>BufferedOutputStream#flush</code>就会把自己维护的缓冲区数据写入下一层的<code>OutputStream</code>。如果是<code>new BufferedOutputStream(new FileOutputStream(&quot;/&quot;))</code>这样的模式，则调用<code>BufferedOutputStream#flush</code>会将数据写入操作系统。</p><h2 id="内核缓冲区"><a href="#内核缓冲区" class="headerlink" title="内核缓冲区"></a>内核缓冲区</h2><p>应用程序直接或者通过库函数间接的使用系统调用<code>write</code>将数据写入操作系统缓冲区。</p><p>UNIX系统在内核中设有高速缓存或页面高速缓存。目的是为了减少磁盘读写次数。</p><p>用户写入系统的数据先写入系统缓冲区，系统缓冲区写满后，将其排入<code>输出队列</code>，然后得到队首时，才进行实际的IO操作。这种输出方式被称为<code>延迟写</code>。</p><p>UNIX系统提供了三个系统调用来执行刷新内核缓冲区：<code>sync</code>，<code>fsync</code>，<code>fdatasync</code>。</p><h3 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></table></figure><p><code>sync</code>函数只是将<strong>所有</strong>修改过的块缓冲区排入<code>输出队列</code>就返回，并不等待实际的写磁盘操作返回。</p><p>操作系统的<code>update</code>系统守护进程会周期地调用<code>sync</code>函数，来保证系统中的数据能定期落盘。</p><p>根据<a href="http://man7.org/linux/man-pages/man2/sync.2.html" target="_blank" rel="noopener">sync(2) - Linux manual page</a>的描述，Linux对<code>sync</code>的实现与POSIX规范不太一样，POSIX规范中，<code>sync</code>可能在文件真正落盘前就返回，而Linux的实现则是文件真正落盘后才会返回。所以Linux中，<code>sync</code>与<code>fsync</code>的效果是一样的！但是1.3.20之前的Linux存在BUG，导致sync并不会在真正落盘后返回。</p><h3 id="fsync"><a href="#fsync" class="headerlink" title="fsync"></a>fsync</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> filedes)</span></span></span><br></pre></td></tr></table></figure><p><code>fsync</code>对指定的文件起作用，它传输内核缓冲区中这个文件的数据到存储设备中，并阻塞直到存储设备响应说数据已经保存好了。</p><p><code>fsync</code>对文件数据与文件元数据都有效。文件的元数据可以理解为文件的属性数据，比如文件的更新时间，访问时间，长度等。</p><h3 id="fdatasync"><a href="#fdatasync" class="headerlink" title="fdatasync"></a>fdatasync</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fdatasync</span><span class="params">(<span class="keyword">int</span> filedes)</span></span></span><br></pre></td></tr></table></figure><p><code>fdatasync</code>和<code>fsync</code>类似，两者的区别是，<code>fdatasync</code>不一定需要刷新文件的元数据部分到存储设备。</p><p>是否需要刷新文件的元数据，是要看元数据的变化部分是否对之后的读取有影响，比如文件元数据的访问时间<code>st_atime</code>和修改时间<code>st_mtime</code>变化了，<code>fdatasync</code>不会去刷新元数据数据到存储设备，因为即使这个数据丢失了不一致了，也不影响故障恢复后的文件读取。但是如果文件的长度<code>st_size</code>变化了，那么就需要刷新元数据数据到存储设备。</p><p>所以如果你每次都更新文件长度，那么调用<code>fsync</code>和<code>fdatasync</code>的效果是一样的。</p><p>但是如果更新能做到不修改文件长度，那么<code>fdatasync</code>能比<code>fsync</code>少了一次磁盘写入，这个是非常大的速度提升。</p><h3 id="O-SYNC和O-DSYNC"><a href="#O-SYNC和O-DSYNC" class="headerlink" title="O_SYNC和O_DSYNC"></a><code>O_SYNC</code>和<code>O_DSYNC</code></h3><p>除了上面三个系统调用，<code>open</code>系统调用在打开文件时，可以设置和同步相关的标志位：<code>O_SYNC</code>和<code>O_DSYNC</code>。</p><p>设置<code>O_SYNC</code>的效果相当于是每次<code>write</code>后自动调用<code>fsync</code>。</p><p>设置<code>O_DSYNC</code>的效果相当于是每次<code>write</code>后自动调用<code>fdatasync</code>。</p><h3 id="关于新建文件"><a href="#关于新建文件" class="headerlink" title="关于新建文件"></a>关于新建文件</h3><p>在一个文件上调用<code>fsync</code>/<code>fdatasync</code>只能保证文件本身的数据落盘，但是对于文件系统来说，目录中也保存着文件信息，<code>fsync</code>/<code>fdatasync</code>的调用并不会保证这部分的数据落盘。如果此时发生掉电，这个文件就无法被找到了。</p><p>所以对于新建文件来说，还需要在父目录上调用<code>fsync</code>。</p><h3 id="关于覆盖现有文件"><a href="#关于覆盖现有文件" class="headerlink" title="关于覆盖现有文件"></a>关于覆盖现有文件</h3><p>覆盖现有文件时，如果发生掉电，新的数据是不会写入成功，但是可能会污染现有的数据，导致现有数据丢失。</p><p>所以最佳实践是新建一个临时文件，写入成功后，再替换原有文件。具体步骤：</p><ol><li>新建一个临时文件</li><li>向临时文件写入数据</li><li>对临时文件调用<code>fsync</code>，保证数据落盘。期间发生掉电对现有文件无影响。</li><li>重命名临时文件为目标文件名</li><li>对父目录调用<code>fsync</code></li></ol><h2 id="存储设备缓冲区"><a href="#存储设备缓冲区" class="headerlink" title="存储设备缓冲区"></a>存储设备缓冲区</h2><p>存储设备为了提高性能，也会加入缓存。高级的存储设备能提供非易失性的缓存，比如有掉电保护的缓存。但是无法对所有设备做出这种保证，所以如果数据只是写入了存储设备的缓存的话，遇到掉电等故障，依然会导致数据丢失。</p><p>对于保证数据能保存到存储设备的持久化存储介质上，而不管设备本身是否有易失性缓存，操作系统提供了<code>write barriers</code>这个机制。</p><p>开启了<code>write barriers</code>的文件系统，能保证调用<code>fsync</code>/<code>fdatasync</code>数据持久化保存，无论是否发生了掉电等其他故障，但是会导致性能下降。</p><p>许多文件系统提供了配置<code>write barriers</code>的功能。比如<code>ext3</code>, <code>ext4</code>, <code>xfs</code> 和 <code>btrfs</code>。<code>mount</code>参数<code>-o barrier</code>表示开启写屏障，调用<code>fsync</code>/<code>fdatasync</code>能保证刷新存储设备的缓存到持久化介质上。<code>-o nobarrier</code>则表示关闭写屏障，调用<code>fsync</code>/<code>fdatasync</code>无法保证数据落盘。</p><p>Linux默认开启写屏障，所以默认情况下，我们调用<code>fsync</code>/<code>fdatasync</code>，就可以认为是文件真正的可靠落盘了。</p><p>对于这个层面的数据安全保证来说，应用程序是不需要去考虑的，因为如果这台机器的硬盘被挂载为没有开启写屏障，那么可以认为这个管理员知道这个风险，他选择了更高的性能，而不是更高的安全性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>文件数据从应用程序写入磁盘，需要经过多个缓冲区：应用本身的缓冲区，库的缓冲区，操作系统缓冲区，磁盘缓冲区</li><li>如果文件数据只是写入缓冲区，而还未写入硬盘的持久化存储设备上，那么断电等故障会导致数据丢失</li><li>库层面刷新缓冲区：C标准库的<code>fflush</code>，JDK的<code>OutputStream#flush</code></li><li>操作系统层面刷新缓冲区：<ul><li><code>fsync</code>可以刷新文件数据+元数据缓冲区</li><li><code>fdatasync</code>可以刷新文件数据，在不影响读取的情况下，可以不刷新文件元数据，性能更好一些</li><li><code>open</code>系统调用的<code>O_SYNC</code>标志位可以在每次<code>write</code>后自动调用<code>fsync</code></li><li><code>open</code>系统调用的<code>O_DSYNC</code>标志位可以在每次<code>write</code>后自动调用<code>fdatasync</code></li></ul></li><li>存储设备层面刷新缓冲区：文件系统支持开启/关闭写屏障<code>write barriers</code>，如果开启写屏障，则<code>fsync</code>/<code>fdatasync</code>可以保证文件写入磁盘的持久化设备中，如果关闭写屏障，则<code>fsync</code>/<code>fdatasync</code>只能保证文件写入磁盘，此时文件可能存在于磁盘的缓存中</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《UNIX环境高级编程》</li><li><a href="https://lwn.net/Articles/457667/" target="_blank" rel="noopener">Ensuring data reaches disk</a></li><li><a href="https://blog.csdn.net/cywosp/article/details/8767327" target="_blank" rel="noopener">linux 同步IO: sync、fsync与fdatasync - CSDN博客</a></li><li><a href="http://man7.org/linux/man-pages/man2/sync.2.html" target="_blank" rel="noopener">sync(2) - Linux manual page</a></li><li><a href="http://man7.org/linux/man-pages/man2/fdatasync.2.html" target="_blank" rel="noopener">fsync(2) - Linux manual page</a></li><li><a href="https://blog.csdn.net/zbszhangbosen/article/details/7956558" target="_blank" rel="noopener">sync/fsync/fdatasync的简单比较 - CSDN博客</a></li><li><a href="http://blog.httrack.com/blog/2013/11/15/everything-you-always-wanted-to-know-about-fsync/" target="_blank" rel="noopener">Everything You Always Wanted To Know About fsync() - xavier roche’s homework</a></li><li><a href="http://blog.163.com/digoal@126/blog/static/163877040201132692318242/" target="_blank" rel="noopener">Linux OS: Write Barriers - 德哥@Digoal的日志 - 网易博客</a></li><li><a href="https://www.2cto.com/kf/201604/497356.html" target="_blank" rel="noopener">Linux Barrier I/O 实现分析与barrier内存屏蔽分析总结 - 综合编程类其他综合 - 红黑联盟</a></li><li><a href="https://docs-old.fedoraproject.org/en-US/Fedora/14/html/Storage_Administration_Guide/writebarr.html" target="_blank" rel="noopener">Chapter 16. Write Barriers</a></li><li><a href="https://lwn.net/Articles/283161/" target="_blank" rel="noopener">Barriers and journaling filesystems [LWN.net]</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们编写程序write数据到文件中时，其实数据不会立马写入磁盘，而是会经过层层缓存。每层缓存都有自己的刷新时机，每层缓存都刷新后才会写入磁盘。这些缓存的存在是为了加速读写操作，因为如果每次读写都对应真实磁盘操作，那么读写的效率会大大降低。带来的坏处是如果期间发生掉电或者别的故障，还未写入磁盘的数据就丢失了。对于数据安全敏感的应用，比如数据库，比如交易程序，这是无法忍受的。所以操作系统提供了保证文件落盘的机制。我们来看下这些机制的原理和使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://mushanshitiancai.github.io/categories/Linux/"/>
    
    
      <category term="linux" scheme="http://mushanshitiancai.github.io/tags/linux/"/>
    
      <category term="os" scheme="http://mushanshitiancai.github.io/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB遍历方式对比</title>
    <link href="http://mushanshitiancai.github.io/2018/06/07/db/MongoDB%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94/"/>
    <id>http://mushanshitiancai.github.io/2018/06/07/db/MongoDB遍历方式对比/</id>
    <published>2018-06-07T06:58:53.000Z</published>
    <updated>2018-07-11T12:32:38.349Z</updated>
    
    <content type="html"><![CDATA[<p>在处理数据时，需要遍历MongoDB全表数据。</p><a id="more"></a><p>以前的写法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> limit = <span class="number">1000</span>;</span><br><span class="line">List&lt;DBObject&gt; ret = mongoTemplate.find(<span class="keyword">new</span> Query().limit(limit).with(<span class="keyword">new</span> Sort(Sort.Direction.ASC,<span class="string">"_id"</span>)), DBObject.class, <span class="string">"demo"</span>);</span><br><span class="line"><span class="keyword">while</span> (ret.size() == limit) &#123;</span><br><span class="line">    <span class="comment">// do</span></span><br><span class="line">    count += ret.size();</span><br><span class="line">    ret = mongoTemplate.find(<span class="keyword">new</span> Query(Criteria.where(<span class="string">"_id"</span>).gt(ret.get(ret.size() - <span class="number">1</span>).get(<span class="string">"_id"</span>))).limit(limit).with(<span class="keyword">new</span> Sort(Sort.Direction.ASC, <span class="string">"_id"</span>)), DBObject.class, <span class="string">"demo"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// do</span></span><br><span class="line">count += ret.size();</span><br></pre></td></tr></table></figure><p>通过多次批量查询的方式遍历全表。</p><p>后面发现可以调用更底层的find获取Cursor来遍历结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DBCollection demo = mongoTemplate.getCollection(<span class="string">"demo"</span>);</span><br><span class="line">DBCursor cursor = demo.find((DBObject) JSON.parse(<span class="string">"&#123;&#125;"</span>));</span><br><span class="line"><span class="keyword">while</span> (cursor.hasNext()) &#123;</span><br><span class="line">    DBObject next = cursor.next();</span><br><span class="line">    <span class="comment">// do</span></span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写法更加简单了，那两种方式的性能如何呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------</span><br><span class="line">ms     %     Task name</span><br><span class="line">-----------------------------------------</span><br><span class="line">10658  008%  cursor mode</span><br><span class="line">115964  092%  batch mode</span><br></pre></td></tr></table></figure><p>用cursor比多次批量查询快了10倍！为什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.data.mongodb.core.MongoTemplate#find</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">find</span><span class="params">(<span class="keyword">final</span> Query query, Class&lt;T&gt; entityClass, String collectionName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (query == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> findAll(entityClass, collectionName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> doFind(collectionName, query.getQueryObject(), query.getFieldsObject(), entityClass,</span><br><span class="line">            <span class="keyword">new</span> QueryCursorPreparer(query, entityClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的执行函数为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">executeFindMultiInternal</span><span class="params">(CollectionCallback&lt;DBCursor&gt; collectionCallback, CursorPreparer preparer,</span></span></span><br><span class="line"><span class="function"><span class="params">        DbObjectCallback&lt;T&gt; objectCallback, String collectionName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        DBCursor cursor = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cursor = collectionCallback.doInCollection(getAndPrepareCollection(getDb(), collectionName));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (preparer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                cursor = preparer.prepare(cursor);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (cursor.hasNext()) &#123;</span><br><span class="line">                DBObject object = cursor.next();</span><br><span class="line">                result.add(objectCallback.doWith(object));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cursor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                cursor.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> potentiallyConvertRuntimeException(e, exceptionTranslator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MongoTemplate#find</code>的内部实现也是使用<code>DBCursor</code>实现的。在内部遍历获取结果，放入ArrayList后返回。意味着用这个方法，会比直接使用<code>DBCursor</code>多了一次拷贝，而且因为ArrayList本身的增长还涉及到多次大的拷贝。</p><p>目前关于这两种方法的性能差异的推测为：</p><ol><li><code>DBCollection#find</code>的逻辑简单，直接查询，获取<code>DBCursor</code>返回</li><li><code>MongoTemplate#find</code>有很多逻辑，查询得到<code>DBCursor</code>后，内部遍历，将结果放入ArrayList返回。这个遍历返回的过程也花了一定的时间（包含ArrayList扩容的时间）</li><li><code>DBCollection#find</code>只需要进行一次查询，剩下的过程都是迭代这个查询得到的Cursor，而<code>MongoTemplate#find</code>需要进行很多次查询，目前推测查询比迭代光标耗时很多。</li></ol><p>目前实验来看<code>MongoTemplate#find</code>便于平时业务逻辑使用，因为直接返回的可用的List，而且是Bean转换好的。</p><p><code>DBCollection#find</code>则有更高的性能。</p><h2 id="DBCursor-next对应一个网络请求吗"><a href="#DBCursor-next对应一个网络请求吗" class="headerlink" title="DBCursor#next对应一个网络请求吗"></a><code>DBCursor#next</code>对应一个网络请求吗</h2><p><code>DBCursor</code>使用next获取下一条数据，那每次调用next都是网络请求MongoDB获取数据吗？那岂不是很慢？</p><p><code>DBCursor#next</code>最终调用<code>MongoBatchCursorAdapter#next</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasNext()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (curBatch == <span class="keyword">null</span>) &#123;</span><br><span class="line">        curBatch = batchCursor.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> getNextInBatch();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">getNextInBatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T nextInBatch = curBatch.get(curPos);</span><br><span class="line">    <span class="keyword">if</span> (curPos &lt; curBatch.size() - <span class="number">1</span>) &#123;</span><br><span class="line">        curPos++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        curBatch = <span class="keyword">null</span>;</span><br><span class="line">        curPos = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nextInBatch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MongoBatchCursorAdapter#next</code>调用<code>QueryBatchCursor#next</code>得到结果List，在从中取出一个返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Iterator has been closed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!hasNext()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;T&gt; retVal = nextBatch;</span><br><span class="line">    nextBatch = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>QueryBatchCursor#next</code>中没有获取逻辑，而是直接返回<code>nextBatch</code>，这个<code>nextBatch</code>是在<code>hasNext</code>时就获取的了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cursor has been closed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextBatch != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (limitReached()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (serverCursor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        getMore(); <span class="comment">// 获取数据</span></span><br><span class="line">        <span class="keyword">if</span> (nextBatch != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论是在调用<code>com.mongodb.DBCursor#hasNext</code>时，MongoDB Driver就已经获取了一批数据（断点看是100条），然后调用<code>com.mongodb.DBCursor#next</code>返回这些结果，如果这一批使用完毕，则会再去获取一批。</p><p>也就是说Cursor已经帮我们做了按批次获取的优化了，我们也就不需要自己来做这个麻烦事了。</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>PS. 还做了多线程全表扫描的对比：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiTheradIterTest</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line"></span><br><span class="line">    DBCollection demo = mongoTemplate.getCollection(<span class="string">"demo"</span>);</span><br><span class="line">    System.out.println(demo.count());</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    stopWatch.start(<span class="string">"multi thread cursor mode"</span>);</span><br><span class="line">    String minId = <span class="string">"000000000000000000"</span>;</span><br><span class="line">    String maxId = <span class="string">"ffffffffffffffffff"</span>;</span><br><span class="line">    List&lt;Future&lt;Integer&gt;&gt; futureList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">        String startId = <span class="string">"5b175"</span> + Integer.toHexString(i) + minId;</span><br><span class="line">        String endId = <span class="string">"5b175"</span> + Integer.toHexString(i) + maxId;</span><br><span class="line"></span><br><span class="line">        Future&lt;Integer&gt; future = executorService.submit(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                DBCursor cursor = demo.find((DBObject) JSON.parse(</span><br><span class="line">                        <span class="string">"&#123; \"$and\" : [ &#123; \"_id\" : &#123; \"$gte\" : &#123; \"$oid\" : \""</span></span><br><span class="line">                                + startId +</span><br><span class="line">                                <span class="string">"\"&#125;&#125;&#125; , &#123; \"_id\" : &#123; \"$lte\" : &#123; \"$oid\" : \""</span></span><br><span class="line">                                + endId +</span><br><span class="line">                                <span class="string">"\"&#125;&#125;&#125;]&#125;"</span>));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (cursor.hasNext())&#123;</span><br><span class="line">                    DBObject next = cursor.next();</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        futureList.add(future);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Future&lt;Integer&gt; future : futureList) &#123;</span><br><span class="line">        Integer aCount = future.get();</span><br><span class="line">        count += aCount;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"multi thread cursor mode="</span> + count);</span><br><span class="line">    stopWatch.stop();</span><br><span class="line"></span><br><span class="line">    stopWatch.start(<span class="string">"multi thread batch mode"</span>);</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> limit = <span class="number">1000</span>;</span><br><span class="line">    futureList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">        String startId = <span class="string">"5b175"</span> + Integer.toHexString(i) + minId;</span><br><span class="line">        String endId = <span class="string">"5b175"</span> + Integer.toHexString(i) + maxId;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Future&lt;Integer&gt; future = executorService.submit(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//                    System.out.println(startId + "-" + endId);</span></span><br><span class="line">                Criteria criteria = <span class="keyword">new</span> Criteria();</span><br><span class="line">                criteria.andOperator(Criteria.where(<span class="string">"_id"</span>).gte(<span class="keyword">new</span> ObjectId(startId)), Criteria.where(<span class="string">"_id"</span>).lte(<span class="keyword">new</span> ObjectId(endId)));</span><br><span class="line">                Query query = <span class="keyword">new</span> Query(criteria).limit(limit).with(<span class="keyword">new</span> Sort(Sort.Direction.ASC, <span class="string">"_id"</span>));</span><br><span class="line">                List&lt;DBObject&gt; ret = mongoTemplate.find(query, DBObject.class, <span class="string">"demo"</span>);</span><br><span class="line"><span class="comment">//                    System.out.println(query + "  " + ret.size() + "  " + Thread.currentThread().getName());</span></span><br><span class="line">                <span class="comment">// do</span></span><br><span class="line">                count += ret.size();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ret.isEmpty() || ret.get(ret.size() - <span class="number">1</span>).get(<span class="string">"_id"</span>).toString().equals(endId)) &#123;</span><br><span class="line">                    System.out.println();</span><br><span class="line">                    <span class="keyword">return</span> count;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    criteria = <span class="keyword">new</span> Criteria();</span><br><span class="line">                    criteria.andOperator(Criteria.where(<span class="string">"_id"</span>).gt(ret.get(ret.size() - <span class="number">1</span>).get(<span class="string">"_id"</span>)), Criteria.where(<span class="string">"_id"</span>).lte(<span class="keyword">new</span> ObjectId(endId)));</span><br><span class="line">                    Query query1 = <span class="keyword">new</span> Query(criteria).limit(limit).with(<span class="keyword">new</span> Sort(Sort.Direction.ASC, <span class="string">"_id"</span>));</span><br><span class="line">                    ret = mongoTemplate.find(query1, DBObject.class, <span class="string">"demo"</span>);</span><br><span class="line">                    <span class="comment">// do</span></span><br><span class="line">                    count += ret.size();</span><br><span class="line"><span class="comment">//                        System.out.println(query1 + "  " + ret.size() + "  " + Thread.currentThread().getName());</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (ret.isEmpty() || ret.get(ret.size() - <span class="number">1</span>).get(<span class="string">"_id"</span>).toString().equals(endId)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> count;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        futureList.add(future);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Future&lt;Integer&gt; future : futureList) &#123;</span><br><span class="line">        Integer aCount = future.get();</span><br><span class="line">        count += aCount;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"multi batch cursor mode="</span> + count);</span><br><span class="line">    stopWatch.stop();</span><br><span class="line"></span><br><span class="line">    System.out.println(stopWatch.prettyPrint());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------</span><br><span class="line">ms     %     Task name</span><br><span class="line">-----------------------------------------</span><br><span class="line">09287  005%  multi thread cursor mode</span><br><span class="line">192853  095%  multi thread batch mode</span><br></pre></td></tr></table></figure><p>遇到了几个问题：</p><ol><li>多线程的代码会更加复杂，但依然是<code>DBCollection#find</code>的方式代码简单一些</li><li>多线程需要考虑如何平分查询区间到每个执行线程，这边我是通过分割ObjectId区间来做，但是遇到一个问题，ObjectId是以时间戳开头的，所以我短时间造的数据前面几位是一样的，所以并没能很好的保证每个区间的任务强度一致，也就弱化了多线程的效果</li><li>不同的id格式，代码还需要做调整才能适应，更增加了实现复杂度</li><li>以上的实验结果来看多线程效果不是很明显（可能是因为代码还不够完善）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在处理数据时，需要遍历MongoDB全表数据。&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://mushanshitiancai.github.io/categories/MongoDB/"/>
    
    
      <category term="db" scheme="http://mushanshitiancai.github.io/tags/db/"/>
    
      <category term="mongodb" scheme="http://mushanshitiancai.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码阅读-RandomAccessFile</title>
    <link href="http://mushanshitiancai.github.io/2018/06/04/java/language/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-RandomAccessFile/"/>
    <id>http://mushanshitiancai.github.io/2018/06/04/java/language/JDK源码阅读-RandomAccessFile/</id>
    <published>2018-06-04T13:27:48.000Z</published>
    <updated>2018-06-04T14:48:10.907Z</updated>
    
    <content type="html"><![CDATA[<p><code>FileInputStream</code>只能用于读取文件，<code>FileOutputStream</code>只能用于写入文件，而对于同时读取文件，并且需要随意移动文件当前偏移量的话，就需要使用<code>RandomAccessFile</code>这个类了。<code>RandomAccessFile</code>是对操作系统提供的文件读写能力最完整的封装。</p><a id="more"></a><h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><p>RAF打开文件时，除了指定文件对象，还需要指定一个模式，取值有：</p><ul><li>“r”    以只读方式打开。调用结果对象的任何 write 方法都将导致抛出 IOException。</li><li>“rw”    打开以便读取和写入。如果该文件尚不存在，则尝试创建该文件。</li><li>“rws”    打开以便读取和写入，对于 “rw”，还要求对文件的内容或元数据的每个更新都同步写入到底层存储设备。</li><li>“rwd” 打开以便读取和写入，对于 “rw”，还要求对文件内容的每个更新都同步写入到底层存储设备。</li></ul><p>“rws”和”rwd”的效率比”rw”低非常非常多，因为每次读写都需要刷到磁盘才会返回，这两个中”rwd”比”rws”效率高一些，因为”rwd”只刷新文件内容，”rws”刷新文件内容与元数据，文件的元数据就是文件更新时间等信息。</p><p>这些特性是操作系统提供的特性，通过这次阅读源码，我们来看看是如何使用这些特性来实现上面的这些模式的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4个标志位，用于组合表示4种模式</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> O_RDONLY = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> O_RDWR =   <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> O_SYNC =   <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> O_DSYNC =  <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RandomAccessFile</span><span class="params">(File file, String mode)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> FileNotFoundException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    String name = (file != <span class="keyword">null</span> ? file.getPath() : <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">int</span> imode = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 只读模式</span></span><br><span class="line">    <span class="keyword">if</span> (mode.equals(<span class="string">"r"</span>))</span><br><span class="line">        imode = O_RDONLY;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mode.startsWith(<span class="string">"rw"</span>)) &#123;</span><br><span class="line">        <span class="comment">// 读写模式</span></span><br><span class="line">        imode = O_RDWR;</span><br><span class="line">        rw = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读写模式下，可以结合O_SYNC和O_DSYNC标志</span></span><br><span class="line">        <span class="keyword">if</span> (mode.length() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mode.equals(<span class="string">"rws"</span>))</span><br><span class="line">                imode |= O_SYNC;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mode.equals(<span class="string">"rwd"</span>))</span><br><span class="line">                imode |= O_DSYNC;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                imode = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (imode &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal mode \""</span> + mode</span><br><span class="line">                                            + <span class="string">"\" must be one of "</span></span><br><span class="line">                                            + <span class="string">"\"r\", \"rw\", \"rws\","</span></span><br><span class="line">                                            + <span class="string">" or \"rwd\""</span>);</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        security.checkRead(name);</span><br><span class="line">        <span class="keyword">if</span> (rw) &#123;</span><br><span class="line">            security.checkWrite(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (file.isInvalid()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"Invalid file path"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新建文件描述符</span></span><br><span class="line">    fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">    fd.attach(<span class="keyword">this</span>);</span><br><span class="line">    path = name;</span><br><span class="line">    open(name, imode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(String name, <span class="keyword">int</span> mode)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    open0(name, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">open0</span><span class="params">(String name, <span class="keyword">int</span> mode)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> FileNotFoundException</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk/src/share/native/java/io/RandomAccessFile.c</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_java_io_RandomAccessFile_open0(JNIEnv *env,</span><br><span class="line">                                    jobject <span class="keyword">this</span>, jstring path, jint mode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> flags = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// JAVA中的标志位与操作系统标志位转换</span></span><br><span class="line">    <span class="keyword">if</span> (mode &amp; java_io_RandomAccessFile_O_RDONLY)</span><br><span class="line">        flags = O_RDONLY;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mode &amp; java_io_RandomAccessFile_O_RDWR) &#123;</span><br><span class="line">        flags = O_RDWR | O_CREAT;</span><br><span class="line">        <span class="keyword">if</span> (mode &amp; java_io_RandomAccessFile_O_SYNC)</span><br><span class="line">            flags |= O_SYNC;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mode &amp; java_io_RandomAccessFile_O_DSYNC)</span><br><span class="line">            flags |= O_DSYNC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用fileOpen打开函数</span></span><br><span class="line">    fileOpen(env, <span class="keyword">this</span>, path, raf_fd, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fileOpen</code>之后的流程与<code>FileInputStream</code>的一致，可以参考<a href="http://imushan.com/2018/06/03/java/language/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-FileInputStream/" target="_blank" rel="noopener">JDK源码阅读-FileInputStream</a></p><p>可以看出，相比于<code>FileInputStream</code>固定使用<code>O_RDONLY</code>，<code>FileOutputStream</code>固定使用<code>O_WRONLY | O_CREAT</code>，<code>RandomAccessFile</code>提供了在Java中指定打开模式的能力。</p><h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> read0();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readBytes(b, <span class="number">0</span>, b.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readBytes(b, off, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三个读取函数的实现与<code>FileInputStream</code>一致，可以参考<a href="http://imushan.com/2018/06/03/java/language/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-FileInputStream/" target="_blank" rel="noopener">JDK源码阅读-FileInputStream</a></p><p><code>RandomAccessFile</code>还提供了一个遍历方法，用于读取指定长度的数据，如果还没读取到指定长度就到文件尾，抛出<code>EOFException</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">readFully</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    readFully(b, <span class="number">0</span>, b.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">readFully</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="keyword">this</span>.read(b, off + n, len - n);</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</span><br><span class="line">        n += count;</span><br><span class="line">    &#125; <span class="keyword">while</span> (n &lt; len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件偏移量相关操作"><a href="#文件偏移量相关操作" class="headerlink" title="文件偏移量相关操作"></a>文件偏移量相关操作</h2><h3 id="获取当前文件偏移量"><a href="#获取当前文件偏移量" class="headerlink" title="获取当前文件偏移量"></a>获取当前文件偏移量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">getFilePointer</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk/src/share/native/java/io/RandomAccessFile.c</span></span><br><span class="line">JNIEXPORT jlong JNICALL</span><br><span class="line">Java_java_io_RandomAccessFile_getFilePointer(JNIEnv *env, jobject <span class="keyword">this</span>) &#123;</span><br><span class="line">    FD fd;</span><br><span class="line">    jlong ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取记录在FileDescriptor中的文件描述符</span></span><br><span class="line">    fd = GET_FD(<span class="keyword">this</span>, raf_fd);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        JNU_ThrowIOException(env, <span class="string">"Stream Closed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过seek当前偏移量0个字节的方式获取当前文件偏移量</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = IO_Lseek(fd, <span class="number">0L</span>, SEEK_CUR)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        JNU_ThrowIOExceptionWithLastError(env, <span class="string">"Seek failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设置当前文件偏移量"><a href="#设置当前文件偏移量" class="headerlink" title="设置当前文件偏移量"></a>设置当前文件偏移量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">long</span> pos)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Negative seek offset"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        seek0(pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">seek0</span><span class="params">(<span class="keyword">long</span> pos)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk/src/share/native/java/io/RandomAccessFile.c</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_java_io_RandomAccessFile_seek0(JNIEnv *env,</span><br><span class="line">                    jobject <span class="keyword">this</span>, jlong pos) &#123;</span><br><span class="line"></span><br><span class="line">    FD fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取记录在FileDescriptor中的文件描述符</span></span><br><span class="line">    fd = GET_FD(<span class="keyword">this</span>, raf_fd);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        JNU_ThrowIOException(env, <span class="string">"Stream Closed"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pos &lt; jlong_zero) &#123;</span><br><span class="line">        JNU_ThrowIOException(env, <span class="string">"Negative seek offset"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IO_Lseek(fd, pos, SEEK_SET) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置文件偏移量为pos指定的位置，SEEK_SET表示表示移动到的位置距离文件开始处pos长度</span></span><br><span class="line">        JNU_ThrowIOExceptionWithLastError(env, <span class="string">"Seek failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RandomAccessFile</code>还提供了相对当前位置移动文件偏移量的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk/src/share/native/java/io/RandomAccessFile.c</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">skipBytes</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> pos;</span><br><span class="line">    <span class="keyword">long</span> len;</span><br><span class="line">    <span class="keyword">long</span> newpos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前文件当前偏移量</span></span><br><span class="line">    pos = getFilePointer();</span><br><span class="line">    <span class="comment">// 获取文件长度</span></span><br><span class="line">    len = length();</span><br><span class="line">    newpos = pos + n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果文件偏移量大于文件尾，则设置为文件尾（Java自己做的限制）</span></span><br><span class="line">    <span class="keyword">if</span> (newpos &gt; len) &#123;</span><br><span class="line">        newpos = len;</span><br><span class="line">    &#125;</span><br><span class="line">    seek(newpos);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* return the actual number of bytes skipped */</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) (newpos - pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这个方法不是原子的，所以多线程操作的时候要注意。</span><br><span class="line"></span><br><span class="line">### 获取文件长度</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk/src/share/native/java/io/RandomAccessFile.c</span></span><br><span class="line">JNIEXPORT jlong JNICALL</span><br><span class="line">Java_java_io_RandomAccessFile_length(JNIEnv *env, jobject <span class="keyword">this</span>) &#123;</span><br><span class="line">    FD fd;</span><br><span class="line">    jlong cur = jlong_zero;</span><br><span class="line">    jlong end = jlong_zero;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取记录在FileDescriptor中的文件描述符</span></span><br><span class="line">    fd = GET_FD(<span class="keyword">this</span>, raf_fd);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        JNU_ThrowIOException(env, <span class="string">"Stream Closed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((cur = IO_Lseek(fd, <span class="number">0L</span>, SEEK_CUR)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        JNU_ThrowIOExceptionWithLastError(env, <span class="string">"Seek failed"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((end = IO_Lseek(fd, <span class="number">0L</span>, SEEK_END)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        JNU_ThrowIOExceptionWithLastError(env, <span class="string">"Seek failed"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IO_Lseek(fd, cur, SEEK_SET) == <span class="number">-1</span>) &#123;</span><br><span class="line">        JNU_ThrowIOExceptionWithLastError(env, <span class="string">"Seek failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取文件长度的流程：</p><ol><li>获取当前文件偏移量，记录下来</li><li>设置当前文件偏移量到文件未，得到文件的长度</li><li>设置当前文件偏移量到之前记录的位置</li><li>返回文件长度</li></ol><p>这么来看，UNIX系统上精确获取文件长度的做法就只这个流程了。</p><h3 id="设置文件长度"><a href="#设置文件长度" class="headerlink" title="设置文件长度"></a>设置文件长度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">setLength</span><span class="params">(<span class="keyword">long</span> newLength)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk/src/share/native/java/io/RandomAccessFile.c</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_java_io_RandomAccessFile_setLength(JNIEnv *env, jobject <span class="keyword">this</span>,</span><br><span class="line">                                        jlong newLength)</span><br><span class="line">&#123;</span><br><span class="line">    FD fd;</span><br><span class="line">    jlong cur;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取记录在FileDescriptor中的文件描述符</span></span><br><span class="line">    fd = GET_FD(<span class="keyword">this</span>, raf_fd);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        JNU_ThrowIOException(env, <span class="string">"Stream Closed"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前文件偏移量</span></span><br><span class="line">    <span class="keyword">if</span> ((cur = IO_Lseek(fd, <span class="number">0L</span>, SEEK_CUR)) == <span class="number">-1</span>) <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用ftruncate来设置文件长度</span></span><br><span class="line">    <span class="keyword">if</span> (IO_SetLength(fd, newLength) == <span class="number">-1</span>) <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置文件长度后，恢复文件偏移量</span></span><br><span class="line">    <span class="comment">// 如果是缩小了文件，并且文件偏移量大于现在的文件长度，设置文件偏移量为文件尾</span></span><br><span class="line">    <span class="keyword">if</span> (cur &gt; newLength) &#123;</span><br><span class="line">        <span class="keyword">if</span> (IO_Lseek(fd, <span class="number">0L</span>, SEEK_END) == <span class="number">-1</span>) <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (IO_Lseek(fd, cur, SEEK_SET) == <span class="number">-1</span>) <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"> fail:</span><br><span class="line">    JNU_ThrowIOExceptionWithLastError(env, <span class="string">"setLength failed"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jdk/src/solaris/native/java/io/io_util_md.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IO_SetLength handleSetLength</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// jdk/src/solaris/native/java/io/io_util_md.c</span></span><br><span class="line">jint</span><br><span class="line">handleSetLength(FD fd, jlong length)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    RESTARTABLE(ftruncate64(fd, length), result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    write0(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    writeBytes(b, <span class="number">0</span>, b.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    writeBytes(b, off, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三个write方法实现与FileOutputStream相同，可以参考<a href="http://imushan.com/2018/06/04/java/language/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-FileOutputStream/" target="_blank" rel="noopener">JDK源码阅读-FileOutputStream</a></p><h2 id="读取Java数据类型方法"><a href="#读取Java数据类型方法" class="headerlink" title="读取Java数据类型方法"></a>读取Java数据类型方法</h2><p><code>RandomAccessFile</code>还提供了读取Java数据类型的方法，这些方法与<code>DataInputStream</code>和<code>DataOutputStream</code>中提供的一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">readBoolean</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">byte</span> <span class="title">readByte</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readUnsignedByte</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="title">readShort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readUnsignedShort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">readChar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readInt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">readLong</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">readFloat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">readDouble</span><span class="params">()</span></span></span><br><span class="line"><span class="function">String <span class="title">readLine</span><span class="params">()</span></span></span><br><span class="line"><span class="function">String <span class="title">readUTF</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeBoolean</span><span class="params">(<span class="keyword">boolean</span> v)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeByte</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeShort</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeChar</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeInt</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeLong</span><span class="params">(<span class="keyword">long</span> v)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeFloat</span><span class="params">(<span class="keyword">float</span> v)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeDouble</span><span class="params">(<span class="keyword">double</span> v)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeBytes</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeChars</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeUTF</span><span class="params">(String str)</span></span></span><br></pre></td></tr></table></figure><p>这些方法都是调用<code>RandomAccessFile</code>中基础的read/write方法实现的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;FileInputStream&lt;/code&gt;只能用于读取文件，&lt;code&gt;FileOutputStream&lt;/code&gt;只能用于写入文件，而对于同时读取文件，并且需要随意移动文件当前偏移量的话，就需要使用&lt;code&gt;RandomAccessFile&lt;/code&gt;这个类了。&lt;code&gt;RandomAccessFile&lt;/code&gt;是对操作系统提供的文件读写能力最完整的封装。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://mushanshitiancai.github.io/categories/Java/"/>
    
      <category term="JDK源码阅读" scheme="http://mushanshitiancai.github.io/categories/Java/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="java" scheme="http://mushanshitiancai.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码阅读-FileOutputStream</title>
    <link href="http://mushanshitiancai.github.io/2018/06/04/java/language/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-FileOutputStream/"/>
    <id>http://mushanshitiancai.github.io/2018/06/04/java/language/JDK源码阅读-FileOutputStream/</id>
    <published>2018-06-04T08:11:22.000Z</published>
    <updated>2018-06-16T01:09:03.892Z</updated>
    
    <content type="html"><![CDATA[<p><code>FileOutputStream</code>用户打开文件并获取输出流。</p><a id="more"></a><h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(File file, <span class="keyword">boolean</span> append)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> FileNotFoundException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    String name = (file != <span class="keyword">null</span> ? file.getPath() : <span class="keyword">null</span>);</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        security.checkWrite(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (file.isInvalid()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"Invalid file path"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">    fd.attach(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.append = append; <span class="comment">// 记录是否是append追加模式</span></span><br><span class="line">    <span class="keyword">this</span>.path = name;</span><br><span class="line"></span><br><span class="line">    open(name, append);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(String name, <span class="keyword">boolean</span> append)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    open0(name, append);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">open0</span><span class="params">(String name, <span class="keyword">boolean</span> append)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> FileNotFoundException</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk/src/solaris/native/java/io/FileOutputStream_md.c</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_java_io_FileOutputStream_open(JNIEnv *env, jobject <span class="keyword">this</span>,</span><br><span class="line">                                   jstring path, jboolean append) &#123;</span><br><span class="line">    <span class="comment">// 使用O_WRONLY，O_CREAT模式打开文件，如果文件不存在会新建文件</span></span><br><span class="line">    <span class="comment">// 如果java中指定append参数为true，则使用O_APPEND追加模式</span></span><br><span class="line">    <span class="comment">// 如果java中指定append参数为false，则使用O_TRUNC模式，如果文件存在内容，会清空掉</span></span><br><span class="line">    fileOpen(env, <span class="keyword">this</span>, path, fos_fd,</span><br><span class="line">             O_WRONLY | O_CREAT | (append ? O_APPEND : O_TRUNC));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fileOpen</code>之后的流程与<code>FileInputStream</code>的一致，可以参考<a href="http://imushan.com/2018/06/03/java/language/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-FileInputStream/" target="_blank" rel="noopener">JDK源码阅读-FileInputStream</a></p><h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><p><code>FileOutputStream</code>提供了三个write函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    write(b, append);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    writeBytes(b, <span class="number">0</span>, b.length, append);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    writeBytes(b, off, len, append);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b, <span class="keyword">boolean</span> append)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len, <span class="keyword">boolean</span> append)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk/src/solaris/native/java/io/FileOutputStream_md.c</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_java_io_FileOutputStream_write(JNIEnv *env, jobject <span class="keyword">this</span>, jint byte, jboolean append) &#123;</span><br><span class="line">    writeSingle(env, <span class="keyword">this</span>, byte, append, fos_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_java_io_FileOutputStream_writeBytes(JNIEnv *env,</span><br><span class="line">    jobject <span class="keyword">this</span>, jbyteArray bytes, jint off, jint len, jboolean append) &#123;</span><br><span class="line">    writeBytes(env, <span class="keyword">this</span>, bytes, off, len, append, fos_fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk/src/share/native/java/io/io_util.c</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">writeSingle(JNIEnv *env, jobject <span class="keyword">this</span>, jint byte, jboolean append, jfieldID fid) &#123;</span><br><span class="line">    <span class="comment">// Discard the 24 high-order bits of byte. See OutputStream#write(int)</span></span><br><span class="line">    <span class="keyword">char</span> c = (<span class="keyword">char</span>) byte;</span><br><span class="line">    jint n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取记录在FileDescriptor中的文件描述符</span></span><br><span class="line">    FD fd = GET_FD(<span class="keyword">this</span>, fid);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        JNU_ThrowIOException(env, <span class="string">"Stream Closed"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 追加模式和普通模式使用不同的函数</span></span><br><span class="line">    <span class="keyword">if</span> (append == JNI_TRUE) &#123;</span><br><span class="line">        n = IO_Append(fd, &amp;c, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n = IO_Write(fd, &amp;c, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">-1</span>) &#123;</span><br><span class="line">        JNU_ThrowIOExceptionWithLastError(env, <span class="string">"Write error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">writeBytes(JNIEnv *env, jobject <span class="keyword">this</span>, jbyteArray bytes,</span><br><span class="line">           jint off, jint len, jboolean append, jfieldID fid)</span><br><span class="line">&#123;</span><br><span class="line">    jint n;</span><br><span class="line">    <span class="keyword">char</span> stackBuf[BUF_SIZE];</span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="literal">NULL</span>;</span><br><span class="line">    FD fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断Java传入的byte数组是否是null</span></span><br><span class="line">    <span class="keyword">if</span> (IS_NULL(bytes)) &#123;</span><br><span class="line">        JNU_ThrowNullPointerException(env, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断off和len参数是否数组越界</span></span><br><span class="line">    <span class="keyword">if</span> (outOfBounds(env, off, len, bytes)) &#123;</span><br><span class="line">        JNU_ThrowByName(env, <span class="string">"java/lang/IndexOutOfBoundsException"</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果写入长度为0，直接返回0</span></span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; BUF_SIZE) &#123;</span><br><span class="line">        <span class="comment">// 如果写入长度大于BUF_SIZE（8192），无法使用栈空间buffer</span></span><br><span class="line">        <span class="comment">// 需要调用malloc在堆空间申请buffer</span></span><br><span class="line">        buf = <span class="built_in">malloc</span>(len);</span><br><span class="line">        <span class="keyword">if</span> (buf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            JNU_ThrowOutOfMemoryError(env, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buf = stackBuf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制Java传入的byte数组数据到C空间的buffer中</span></span><br><span class="line">    (*env)-&gt;GetByteArrayRegion(env, bytes, off, len, (jbyte *)buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(*env)-&gt;ExceptionOccurred(env)) &#123;</span><br><span class="line">        off = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取记录在FileDescriptor中的文件描述符</span></span><br><span class="line">            fd = GET_FD(<span class="keyword">this</span>, fid);</span><br><span class="line">            <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                JNU_ThrowIOException(env, <span class="string">"Stream Closed"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 追加模式和普通模式使用不同的函数</span></span><br><span class="line">            <span class="keyword">if</span> (append == JNI_TRUE) &#123;</span><br><span class="line">                n = IO_Append(fd, buf+off, len);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                n = IO_Write(fd, buf+off, len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">-1</span>) &#123;</span><br><span class="line">                JNU_ThrowIOExceptionWithLastError(env, <span class="string">"Write error"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            off += n;</span><br><span class="line">            len -= n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (buf != stackBuf) &#123;</span><br><span class="line">        <span class="built_in">free</span>(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>IO_Write</code>/<code>IO_Append</code>虽然看起来是两个不同的函数，其实是两个不同的宏定义，指向同一个函数<code>handleWrite</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk/src/solaris/native/java/io/io_util_md.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IO_Write handleWrite</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IO_Append handleWrite</span></span><br></pre></td></tr></table></figure><p><code>handleWrite</code>中调用<code>write</code>系统调用写入数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk/src/solaris/native/java/io/io_util_md.c</span></span><br><span class="line"><span class="keyword">ssize_t</span></span><br><span class="line">handleWrite(FD fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, jint len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> result;</span><br><span class="line">    RESTARTABLE(write(fd, buf, len), result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FileOutputStream#write(byte[], int, int)</code>的主要流程：</p><ol><li>检查参数是否合法（byte数组不能为空，off和len没有越界）</li><li>判断读取的长度，如果等于0直接返回0，如果大于BUF_SIZE需要在堆空间申请内存，如果<code>0&lt;len&lt;=BUF_SIZE</code>则直接在使用栈空间的缓存</li><li>从Java空间的byte数组复制数据到中C空间的char数组中</li><li>调用<code>write</code>系统调用写文件内容到系统中</li></ol><p><strong>重要收获：</strong></p><ol><li>使用<code>FileOutputStream#write(byte[], int, int)</code>写入的长度，len一定不能大于8192！因为在小于8192时，会直接利用栈空间的char数组，如果大于，则需要调用malloc申请内存，并且还需要free释放内存，这是非常消耗时间的。</li><li>相比于直接使用系统调用，Java的写入会多一次拷贝！</li></ol><h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (closeLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        closed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">        channel.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd.closeAll(<span class="keyword">new</span> Closeable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            close0();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FileOutputStream</code>关闭文件的逻辑和<code>FileInputStream</code>关闭文件的逻辑是一样的，参考<a href="http://imushan.com/2018/05/29/java/language/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-FileDescriptor/" target="_blank" rel="noopener">JDK源码阅读-FileDescriptor</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>FileOutputStream</code>打开文件使用<code>open</code>系统调用</li><li><code>FileOutputStream</code>写入文件使用<code>write</code>系统调用</li><li><code>FileOutputStream</code>关闭文件使用<code>close</code>系统调用</li><li>使用<code>FileOutputStream#write(byte[], int, int)</code>写入的长度，len一定不能大于8192！因为在小于8192时，会直接利用栈空间的char数组，如果大于，则需要调用malloc申请内存，并且还需要free释放内存，这是非常消耗时间的。</li><li>相比于直接使用系统调用，Java的写入会多一次拷贝！</li><li><code>FileOutputStream#write</code>是无缓冲的，所以每次调用对对应一次系统调用，可能会有较低的性能，需要结合<code>BufferedOutputStream</code>提高性能</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;FileOutputStream&lt;/code&gt;用户打开文件并获取输出流。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://mushanshitiancai.github.io/categories/Java/"/>
    
      <category term="JDK源码阅读" scheme="http://mushanshitiancai.github.io/categories/Java/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="java" scheme="http://mushanshitiancai.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码阅读-FileInputStream</title>
    <link href="http://mushanshitiancai.github.io/2018/06/03/java/language/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-FileInputStream/"/>
    <id>http://mushanshitiancai.github.io/2018/06/03/java/language/JDK源码阅读-FileInputStream/</id>
    <published>2018-06-03T01:45:24.000Z</published>
    <updated>2018-06-16T01:08:50.905Z</updated>
    
    <content type="html"><![CDATA[<p><code>FileIntputStream</code>用于打开一个文件并获取输入流。</p><a id="more"></a><h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><p>我们来看看<code>FileIntputStream</code>打开文件时，做了什么操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    String name = (file != <span class="keyword">null</span> ? file.getPath() : <span class="keyword">null</span>);</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        security.checkRead(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (file.isInvalid()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"Invalid file path"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">    fd.attach(<span class="keyword">this</span>);</span><br><span class="line">    path = name;</span><br><span class="line">    open(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    open0(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">open0</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException</span>;</span><br></pre></td></tr></table></figure><p><code>FileIntputStream</code>的构造函数，在Java层面做的事情不多：</p><ol><li>检查是否有读取文件的权限</li><li>判断文件路径是否合法</li><li>新建<code>FileDescriptor</code>实例</li><li>调用<code>open0</code>本地方法</li></ol><p><code>FileDescriptor</code>类对应操作系统的文件描述符，具体可以参考<a href="http://imushan.com/2018/05/29/java/language/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-FileDescriptor/" target="_blank" rel="noopener">JDK源码阅读-FileDescriptor</a>这篇文章。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk/src/share/native/java/io/FileInputStream.c</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_java_io_FileInputStream_open0(JNIEnv *env, jobject <span class="keyword">this</span>, jstring path) &#123;</span><br><span class="line">    <span class="comment">// 使用O_RDONLY只读模式打开文件</span></span><br><span class="line">    fileOpen(env, <span class="keyword">this</span>, path, fis_fd, O_RDONLY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jdk/src/solaris/native/java/io/io_util_md.c</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">fileOpen(JNIEnv *env, jobject <span class="keyword">this</span>, jstring path, jfieldID fid, <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    WITH_PLATFORM_STRING(env, path, ps) &#123;</span><br><span class="line">        FD fd;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__linux__) || defined(_ALLBSD_SOURCE)</span></span><br><span class="line">        <span class="comment">// 如果是Linux或BSD，去掉path结尾的/，因为这些内核不需要</span></span><br><span class="line">        <span class="keyword">char</span> *p = (<span class="keyword">char</span> *)ps + <span class="built_in">strlen</span>(ps) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((p &gt; ps) &amp;&amp; (*p == <span class="string">'/'</span>))</span><br><span class="line">            *p-- = <span class="string">'\0'</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        fd = JVM_Open(ps, flags, <span class="number">0666</span>); <span class="comment">// 打开文件拿到文件描述符</span></span><br><span class="line">        <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            SET_FD(<span class="keyword">this</span>, fd, fid); <span class="comment">// 非负整数认为是正确的文件描述符，设置到fd字段</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            throwFileNotFoundException(env, path);  <span class="comment">// 负数认为是不正确文件描述符，抛出FileNotFoundException异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; END_PLATFORM_STRING(env, ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FileOutputStream#open</code>的JNI代码逻辑也比较简单：</p><ol><li>如果是Linux或BSD，去掉path结尾的/，因为这些内核不需要</li><li>调用<code>JVM_Open</code>函数打开文件，得到文件描述符</li><li>调用<code>SET_FD</code>设置文件描述符到<code>FileDescriptor#fd</code></li></ol><p><code>SET_FD</code>用于设置文件描述符到<code>FileDescriptor#fd</code>，具体可以参考<a href="http://imushan.com/2018/05/29/java/language/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-FileDescriptor/" target="_blank" rel="noopener">JDK源码阅读-FileDescriptor</a>这篇文章。</p><p><code>JVM_Open</code>根据其命名可以看得出来是JVM提供的函数，可以看出JDK的实现是分为多层的：Java-JNI-JDK，需要和操作系统交互的代码在JNI层面，一些每个操作系统都需要提供的真正底层的方法JVM来提供。具体的这个分层设计以后如果能有机会看JVM实现应该能有更深的理解。</p><p><code>JVM_Open</code>的实现可以在Hotspot虚拟机的代码中找到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hotspot/src/share/vm/prims/jvm.cpp</span></span><br><span class="line">JVM_LEAF(jint, JVM_Open(<span class="keyword">const</span> <span class="keyword">char</span> *fname, jint flags, jint mode))</span><br><span class="line">  JVMWrapper2(<span class="string">"JVM_Open (%s)"</span>, fname);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//%note jvm_r6</span></span><br><span class="line">  <span class="keyword">int</span> result = os::open(fname, flags, mode);  <span class="comment">// 调用os::open打开文件</span></span><br><span class="line">  <span class="keyword">if</span> (result &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(errno) &#123;</span><br><span class="line">      <span class="keyword">case</span> EEXIST:</span><br><span class="line">        <span class="keyword">return</span> JVM_EEXIST;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">JVM_END</span><br><span class="line"></span><br><span class="line"><span class="comment">// hotspot/src/os/linux/vm/os_linux.cpp</span></span><br><span class="line"><span class="keyword">int</span> os::open(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, <span class="keyword">int</span> mode) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果path长度大于MAX_PATH，抛出异常</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strlen</span>(path) &gt; MAX_PATH - <span class="number">1</span>) &#123;</span><br><span class="line">    errno = ENAMETOOLONG;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="comment">// O_DELETE是JVM自定义的一个flag，要在传递给操作系统前去掉</span></span><br><span class="line">  <span class="keyword">int</span> o_delete = (oflag &amp; O_DELETE);</span><br><span class="line">  oflag = oflag &amp; ~O_DELETE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用open64打开文件</span></span><br><span class="line">  fd = ::open64(path, oflag, mode);</span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 问打开成功也可能是目录，这里还需要判断是否打开的是普通文件</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat64</span> <span class="title">buf64</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret = ::fstat64(fd, &amp;buf64);</span><br><span class="line">    <span class="keyword">int</span> st_mode = buf64.st_mode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((st_mode &amp; S_IFMT) == S_IFDIR) &#123;</span><br><span class="line">        errno = EISDIR;</span><br><span class="line">        ::close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ::close(fd);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> FD_CLOEXEC</span></span><br><span class="line">    <span class="comment">// 设置文件描述符标志FD_CLOEXEC</span></span><br><span class="line">    <span class="comment">// 这样在fork和exec时，子进程就不会收到父进程打开的文件描述符的影响</span></span><br><span class="line">    <span class="comment">// 具体参考[FD_CLOEXEC用法及原因_转](https://www.cnblogs.com/embedded-linux/p/6753617.html)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> flags = ::fcntl(fd, F_GETFD);</span><br><span class="line">        <span class="keyword">if</span> (flags != <span class="number">-1</span>)</span><br><span class="line">            ::fcntl(fd, F_SETFD, flags | FD_CLOEXEC);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (o_delete != <span class="number">0</span>) &#123;</span><br><span class="line">    ::unlink(path);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到JVM最后使用<code>open64</code>这个方法打开文件，网上对于<code>open64</code>这个资料还是很少的，我找到的是<a href="https://www.unix.com/man-page/All/2/open64/" target="_blank" rel="noopener">man page for open64 (all section 2) - Unix &amp; Linux Commands</a>，从中可以看出，<code>open64</code>是为了在32位环境打开大文件的系统调用，但是不是标准的一部分。和<code>open</code>+<code>O_LARGEFILE</code>效果是一样的。参考：<a href="https://stackoverflow.com/questions/5245306/wrapper-for-open-and-open64-and-see-that-system-calls-by-vi-uses-open64" target="_blank" rel="noopener">c - Wrapper for open() and open64() and see that system calls by vi uses open64() - Stack Overflow</a></p><p>这样完整的打开文件流程就分析完了，去掉各种函数调用，本质上只做了两件事：</p><ol><li>调用<code>open</code>系统调用打开文件</li><li>保存得到的文件描述符到<code>FileDescriptor#fd</code>中</li></ol><h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> read0();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">read0</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readBytes(b, <span class="number">0</span>, b.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readBytes(b, off, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">readBytes</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><p>可以看出，<code>FileInputStream</code>的三个主要read方法，依赖于两个本地方法，先来看看读取一个字节的<code>read0</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk/src/share/native/java/io/FileInputStream.c</span></span><br><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">Java_java_io_FileInputStream_read0(JNIEnv *env, jobject <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> readSingle(env, <span class="keyword">this</span>, fis_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jdk/src/share/native/java/io/io_util.c</span></span><br><span class="line">jint</span><br><span class="line">readSingle(JNIEnv *env, jobject <span class="keyword">this</span>, jfieldID fid) &#123;</span><br><span class="line">    jint nread;</span><br><span class="line">    <span class="keyword">char</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取记录在FileDescriptor中的文件描述符</span></span><br><span class="line">    FD fd = GET_FD(<span class="keyword">this</span>, fid);</span><br><span class="line">    <span class="keyword">if</span> (fd == -<span class="number">1</span>) &#123;</span><br><span class="line">        JNU_ThrowIOException(env, <span class="string">"Stream Closed"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用IO_Read读取一个字节</span></span><br><span class="line">    nread = IO_Read(fd, &amp;ret, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123; <span class="comment">/* EOF */</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == -<span class="number">1</span>) &#123; <span class="comment">/* error */</span></span><br><span class="line">        JNU_ThrowIOExceptionWithLastError(env, <span class="string">"Read error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret &amp; <span class="number">0xFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jdk/src/solaris/native/java/io/io_util_md.h</span></span><br><span class="line">#define IO_Read handleRead</span><br><span class="line"></span><br><span class="line"><span class="comment">// jdk/src/solaris/native/java/io/io_util_md.c</span></span><br><span class="line">ssize_t</span><br><span class="line">handleRead(FD fd, <span class="keyword">void</span> *buf, jint len)</span><br><span class="line">&#123;</span><br><span class="line">    ssize_t result;</span><br><span class="line">    <span class="comment">// 调用read系统调用读取文件</span></span><br><span class="line">    RESTARTABLE(read(fd, buf, len), result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jdk/src/solaris/native/java/io/io_util_md.h</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Retry the operation if it is interrupted</span></span><br><span class="line"><span class="comment"> * 如果被中断，则重试的宏</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">#define RESTARTABLE(_cmd, _result) do &#123; \</span><br><span class="line">    <span class="keyword">do</span> &#123; \</span><br><span class="line">        _result = _cmd; \</span><br><span class="line">    &#125; <span class="keyword">while</span>((_result == -<span class="number">1</span>) &amp;&amp; (errno == EINTR)); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>read的过程并没有使用JVM提供的函数，而是直接使用open系统调用，为什么有这个区别，目前不太清楚。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk/src/share/native/java/io/FileInputStream.c</span></span><br><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">Java_java_io_FileInputStream_readBytes(JNIEnv *env, jobject <span class="keyword">this</span>,</span><br><span class="line">        jbyteArray bytes, jint off, jint len) &#123;</span><br><span class="line">    <span class="keyword">return</span> readBytes(env, <span class="keyword">this</span>, bytes, off, len, fis_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jdk/src/share/native/java/io/io_util.c</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * The maximum size of a stack-allocated buffer.</span></span><br><span class="line"><span class="comment"> * 栈上能分配的最大buffer大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">#define BUF_SIZE 8192</span><br><span class="line"></span><br><span class="line">jint</span><br><span class="line">readBytes(JNIEnv *env, jobject <span class="keyword">this</span>, jbyteArray bytes,</span><br><span class="line">          jint off, jint len, jfieldID fid)</span><br><span class="line">&#123;</span><br><span class="line">    jint nread;</span><br><span class="line">    <span class="keyword">char</span> stackBuf[BUF_SIZE]; <span class="comment">// BUF_SIZE=8192</span></span><br><span class="line">    <span class="keyword">char</span> *buf = NULL;</span><br><span class="line">    FD fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入的Java byte数组不能是null</span></span><br><span class="line">    <span class="keyword">if</span> (IS_NULL(bytes)) &#123;</span><br><span class="line">        JNU_ThrowNullPointerException(env, NULL);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// off，len参数是否越界判断</span></span><br><span class="line">    <span class="keyword">if</span> (outOfBounds(env, off, len, bytes)) &#123;</span><br><span class="line">        JNU_ThrowByName(env, <span class="string">"java/lang/IndexOutOfBoundsException"</span>, NULL);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果要读取的长度是0，直接返回读取长度0</span></span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; BUF_SIZE) &#123;</span><br><span class="line">        <span class="comment">// 如果要读取的长度大于BUF_SIZE，则不能在栈上分配空间了，需要在堆上分配空间</span></span><br><span class="line">        buf = malloc(len);</span><br><span class="line">        <span class="keyword">if</span> (buf == NULL) &#123;</span><br><span class="line">            <span class="comment">// malloc分配失败，抛出OOM异常</span></span><br><span class="line">            JNU_ThrowOutOfMemoryError(env, NULL);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buf = stackBuf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取记录在FileDescriptor中的文件描述符</span></span><br><span class="line">    fd = GET_FD(<span class="keyword">this</span>, fid);</span><br><span class="line">    <span class="keyword">if</span> (fd == -<span class="number">1</span>) &#123;</span><br><span class="line">        JNU_ThrowIOException(env, <span class="string">"Stream Closed"</span>);</span><br><span class="line">        nread = -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用IO_Read读取</span></span><br><span class="line">        nread = IO_Read(fd, buf, len);</span><br><span class="line">        <span class="keyword">if</span> (nread &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 读取成功后，从buf拷贝数据到Java的byte数组中</span></span><br><span class="line">            (*env)-&gt;SetByteArrayRegion(env, bytes, off, nread, (jbyte *)buf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// read系统调用返回-1是读取失败</span></span><br><span class="line">            JNU_ThrowIOExceptionWithLastError(env, <span class="string">"Read error"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">/* EOF */</span></span><br><span class="line">            <span class="comment">// 操作系统read读取返回0认为是读取结束，Java中返回-1认为是读取结束</span></span><br><span class="line">            nread = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果使用的是堆空间（len &gt; BUF_SIZE），需要手动释放</span></span><br><span class="line">    <span class="keyword">if</span> (buf != stackBuf) &#123;</span><br><span class="line">        free(buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FileInputStream#read(byte[], int, int)</code>的主要流程：</p><ol><li>检查参数是否合法（byte数组不能为空，off和len没有越界）</li><li>判断读取的长度，如果等于0直接返回0，如果大于BUF_SIZE需要在堆空间申请内存，如果<code>0&lt;len&lt;=BUF_SIZE</code>则直接在使用栈空间的缓存</li><li>调用<code>read</code>系统调用读取文件内容到内存中</li><li>从C空间的char数组复制数据到Java空间的byte数组中</li></ol><p><strong>重要收获：</strong></p><ol><li>使用<code>FileInputStream#read(byte[], int, int)</code>读取的长度，len一定不能大于8192！因为在小于8192时，会直接利用栈空间的char数组，如果大于，则需要调用malloc申请内存，并且还需要free释放内存，这是非常消耗时间的。</li><li>相比于直接使用系统调用，Java的读取会多一次拷贝！（思考：使用C标准库的fread和Java的read，复制次数是一样，还是fread会少一次？）</li></ol><h2 id="移动偏移量"><a href="#移动偏移量" class="headerlink" title="移动偏移量"></a>移动偏移量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk/src/share/native/java/io/FileInputStream.c</span></span><br><span class="line">JNIEXPORT jlong JNICALL</span><br><span class="line">Java_java_io_FileInputStream_skip(JNIEnv *env, jobject <span class="keyword">this</span>, jlong toSkip) &#123;</span><br><span class="line">    jlong cur = jlong_zero;</span><br><span class="line">    jlong end = jlong_zero;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取记录在FileDescriptor中的文件描述符</span></span><br><span class="line">    FD fd = GET_FD(<span class="keyword">this</span>, fis_fd);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        JNU_ThrowIOException (env, <span class="string">"Stream Closed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用seek系统调用移动当前偏移量</span></span><br><span class="line">    <span class="keyword">if</span> ((cur = IO_Lseek(fd, (jlong)<span class="number">0</span>, (jint)SEEK_CUR)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取当前文件偏移量</span></span><br><span class="line">        JNU_ThrowIOExceptionWithLastError(env, <span class="string">"Seek error"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((end = IO_Lseek(fd, toSkip, (jint)SEEK_CUR)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 移动偏移量</span></span><br><span class="line">        JNU_ThrowIOExceptionWithLastError(env, <span class="string">"Seek error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (end - cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jdk/src/solaris/native/java/io/io_util_md.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _ALLBSD_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> open64 open</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fstat64 fstat</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> stat64 stat</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lseek64 lseek</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ftruncate64 ftruncate</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IO_Lseek lseek</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IO_Lseek lseek64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="获取文件可读取的字节数"><a href="#获取文件可读取的字节数" class="headerlink" title="获取文件可读取的字节数"></a>获取文件可读取的字节数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">available</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk/src/share/native/java/io/FileInputStream.c</span></span><br><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">Java_java_io_FileInputStream_available(JNIEnv *env, jobject <span class="keyword">this</span>) &#123;</span><br><span class="line">    jlong ret;</span><br><span class="line">    <span class="comment">// 获取记录在FileDescriptor中的文件描述符</span></span><br><span class="line">    FD fd = GET_FD(<span class="keyword">this</span>, fis_fd);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        JNU_ThrowIOException (env, <span class="string">"Stream Closed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用IO_Available获取可读字节数</span></span><br><span class="line">    <span class="keyword">if</span> (IO_Available(fd, &amp;ret)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ret &gt; INT_MAX) &#123;</span><br><span class="line">            ret = (jlong) INT_MAX;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jlong_to_jint(ret);</span><br><span class="line">    &#125;</span><br><span class="line">    JNU_ThrowIOExceptionWithLastError(env, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jdk/src/solaris/native/java/io/io_util_md.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IO_Available handleAvailable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// jdk/src/solaris/native/java/io/io_util_md.c</span></span><br><span class="line">jint</span><br><span class="line">handleAvailable(FD fd, jlong *pbytes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> mode;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat64</span> <span class="title">buf64</span>;</span></span><br><span class="line">    jlong size = <span class="number">-1</span>, current = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取文件的长度</span></span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    RESTARTABLE(fstat64(fd, &amp;buf64), result);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">-1</span>) &#123;</span><br><span class="line">        mode = buf64.st_mode;</span><br><span class="line">        <span class="keyword">if</span> (S_ISCHR(mode) || S_ISFIFO(mode) || S_ISSOCK(mode)) &#123;</span><br><span class="line">            <span class="comment">// 字符特殊文件，管道或FIFO，套接字</span></span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">int</span> result;</span><br><span class="line">            RESTARTABLE(ioctl(fd, FIONREAD, &amp;n), result);</span><br><span class="line">            <span class="keyword">if</span> (result &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                *pbytes = n;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISREG(mode)) &#123;</span><br><span class="line">            <span class="comment">// 普通文件，从st_size字段可以直接获取文件大小</span></span><br><span class="line">            size = buf64.st_size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前文件偏移量</span></span><br><span class="line">    <span class="keyword">if</span> ((current = lseek64(fd, <span class="number">0</span>, SEEK_CUR)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果fstat获取的大小小于当前偏移量，则通过偏移量方式再次获取文件长度</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; current) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((size = lseek64(fd, <span class="number">0</span>, SEEK_END)) == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (lseek64(fd, current, SEEK_SET) == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件长度减去当前偏移量得到文件可读长度</span></span><br><span class="line">    *pbytes = size - current;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void close() throws IOException &#123;</span><br><span class="line">    // 保证只有一个线程会执行关闭逻辑</span><br><span class="line">    synchronized (closeLock) &#123;</span><br><span class="line">        if (closed) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        closed = true;</span><br><span class="line">    &#125;</span><br><span class="line">    // 关闭关联的Channel</span><br><span class="line">    if (channel != null) &#123;</span><br><span class="line">        channel.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 调用FileDescriptor的closeAll，关闭所有相关流，并调用close系统调用关闭文件描述符</span><br><span class="line">    fd.closeAll(new Closeable() &#123;</span><br><span class="line">        public void close() throws IOException &#123;</span><br><span class="line">            close0();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关闭文件的流程可以参考<a href="http://imushan.com/2018/05/29/java/language/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-FileDescriptor/" target="_blank" rel="noopener">JDK源码阅读-FileDescriptor</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>FileInputStream</code>打开文件使用<code>open</code>系统调用</li><li><code>FileInputStream</code>读取文件使用<code>read</code>系统调用</li><li><code>FileInputStream</code>关闭文件使用<code>close</code>系统调用</li><li><code>FileInputStream</code>修改文件当前偏移量使用<code>lseek</code>系统调用</li><li><code>FileInputStream</code>获取文件可读字节数使用<code>fstat</code>系统调用</li><li>使用<code>FileInputStream#read(byte[], int, int)</code>读取的长度，len一定不能大于8192！因为在小于8192时，会直接利用栈空间的char数组，如果大于，则需要调用malloc申请内存，并且还需要free释放内存，这是非常消耗时间的。</li><li>相比于直接使用系统调用，Java的读取文件会多一次拷贝！因为使用read读取文件内容到C空间的数组后，需要拷贝数据到JVM的堆空间的数组中</li><li><code>FileInputStream#read</code>是无缓冲的，所以每次调用对对应一次系统调用，可能会有较低的性能，需要结合<code>BufferedInputStream</code>提高性能</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://imushan.com/2018/05/29/java/language/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-FileDescriptor/" target="_blank" rel="noopener">JDK源码阅读-FileDescriptor</a></li><li><a href="https://www.cnblogs.com/embedded-linux/p/6753617.html" target="_blank" rel="noopener">FD<em>CLOEXEC用法及原因</em>转</a></li><li><a href="https://www.unix.com/man-page/All/2/open64/" target="_blank" rel="noopener">man page for open64 (all section 2) - Unix &amp; Linux Commands</a></li><li><a href="https://stackoverflow.com/questions/5245306/wrapper-for-open-and-open64-and-see-that-system-calls-by-vi-uses-open64" target="_blank" rel="noopener">c - Wrapper for open() and open64() and see that system calls by vi uses open64() - Stack Overflow</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;FileIntputStream&lt;/code&gt;用于打开一个文件并获取输入流。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://mushanshitiancai.github.io/categories/Java/"/>
    
      <category term="JDK源码阅读" scheme="http://mushanshitiancai.github.io/categories/Java/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="java" scheme="http://mushanshitiancai.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码阅读-FileDescriptor</title>
    <link href="http://mushanshitiancai.github.io/2018/05/29/java/language/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-FileDescriptor/"/>
    <id>http://mushanshitiancai.github.io/2018/05/29/java/language/JDK源码阅读-FileDescriptor/</id>
    <published>2018-05-29T14:20:49.000Z</published>
    <updated>2018-06-18T10:25:54.791Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统使用文件描述符来指代一个打开的文件，对文件的读写操作，都需要文件描述符作为参数。Java虽然在设计上使用了抽象程度更高的流来作为文件操作的模型，但是底层依然要使用文件描述符与操作系统交互，而Java世界里文件描述符的对应类就是FileDescriptor。</p><a id="more"></a><p>Java文件操作的三个类：<code>FileIntputStream</code>，<code>FileOutputStream</code>，<code>RandomAccessFile</code>，打开这些类的源码可以看到都有一个FileDescriptor成员变量。</p><p>注：本文使用的JDK版本为8。</p><h2 id="FileDescriptor与文件描述符"><a href="#FileDescriptor与文件描述符" class="headerlink" title="FileDescriptor与文件描述符"></a>FileDescriptor与文件描述符</h2><p>操作系统中的文件描述符本质上是一个非负整数，其中0,1,2固定为标准输入，标准输出，标准错误输出，程序接下来打开的文件使用当前进程中最小的可用的文件描述符号码，比如3。</p><p>文件描述符本身就是一个整数，所以FileDescriptor的核心职责就是保存这个数字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDescriptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是文件描述符是无法在Java代码里设置的，因为FileDescriptor只有私有和无参的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileDescriptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fd = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">FileDescriptor</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.fd = fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那Java是在何时会设置FileDescriptor的fd字段呢？这要结合<code>FileIntputStream</code>，<code>FileOutputStream</code>，<code>RandomAccessFile</code>的代码来看了。</p><p>我们以<code>FileInputStream</code>为例，首先，<code>FileInputStream</code>有一个<code>FileDescriptor</code>成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FileDescriptor fd;</span><br></pre></td></tr></table></figure><p>在<code>FileInputStream</code>实例化时，会新建<code>FileDescriptor</code>实例，并使用<code>fd.attach(this)</code>关联<code>FileInputStream</code>实例与<code>FileDescriptor</code>实例，这是为了日后关闭文件描述符做准备。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    String name = (file != <span class="keyword">null</span> ? file.getPath() : <span class="keyword">null</span>);</span><br><span class="line">    fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">    fd.attach(<span class="keyword">this</span>);</span><br><span class="line">    path = name;</span><br><span class="line">    open(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    open0(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">open0</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException</span>;</span><br></pre></td></tr></table></figure><p>但是上面的代码也没有对<code>FileDescriptor#fd</code>进行赋值，实际上Java层面无法对他赋值，真正的逻辑是在<code>FileInputStream#open0</code>这个native方法中，这就要下载JDK的源码来看了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /jdk/src/share/native/java/io/FileInputStream.c</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_java_io_FileInputStream_open(JNIEnv *env, jobject <span class="keyword">this</span>, jstring path) &#123;</span><br><span class="line">    fileOpen(env, <span class="keyword">this</span>, path, fis_fd, O_RDONLY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /jdk/src/solaris/native/java/io/io_util_md.c</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">fileOpen(JNIEnv *env, jobject <span class="keyword">this</span>, jstring path, jfieldID fid, <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    WITH_PLATFORM_STRING(env, path, ps) &#123;</span><br><span class="line">        FD fd;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__linux__) || defined(_ALLBSD_SOURCE)</span></span><br><span class="line">        <span class="comment">/* Remove trailing slashes, since the kernel won't */</span></span><br><span class="line">        <span class="keyword">char</span> *p = (<span class="keyword">char</span> *)ps + <span class="built_in">strlen</span>(ps) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((p &gt; ps) &amp;&amp; (*p == <span class="string">'/'</span>))</span><br><span class="line">            *p-- = <span class="string">'\0'</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        fd = JVM_Open(ps, flags, <span class="number">0666</span>); <span class="comment">// 打开文件拿到文件描述符</span></span><br><span class="line">        <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            SET_FD(<span class="keyword">this</span>, fd, fid); <span class="comment">// 非负整数认为是正确的文件描述符，设置到fd字段</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            throwFileNotFoundException(env, path);  <span class="comment">// 负数认为是不正确文件描述符，抛出FileNotFoundException异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; END_PLATFORM_STRING(env, ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到JDK的JNI代码中，使用<code>JVM_Open</code>打开文件，得到文件描述符，而<code>JVM_Open</code>已经不是JDK的方法了，而是JVM提供的方法，所以我们需要在hotspot中寻找其实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /hotspot/src/share/vm/prims/jvm.cpp</span></span><br><span class="line">JVM_LEAF(jint, JVM_Open(<span class="keyword">const</span> <span class="keyword">char</span> *fname, jint flags, jint mode))</span><br><span class="line">  JVMWrapper2(<span class="string">"JVM_Open (%s)"</span>, fname);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//%note jvm_r6</span></span><br><span class="line">  <span class="keyword">int</span> result = os::open(fname, flags, mode);  <span class="comment">// 调用os::open打开文件</span></span><br><span class="line">  <span class="keyword">if</span> (result &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(errno) &#123;</span><br><span class="line">      <span class="keyword">case</span> EEXIST:</span><br><span class="line">        <span class="keyword">return</span> JVM_EEXIST;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">JVM_END</span><br><span class="line"></span><br><span class="line"><span class="comment">// /hotspot/src/os/linux/vm/os_linux.cpp</span></span><br><span class="line"><span class="keyword">int</span> os::open(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, <span class="keyword">int</span> mode) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strlen</span>(path) &gt; MAX_PATH - <span class="number">1</span>) &#123;</span><br><span class="line">    errno = ENAMETOOLONG;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">int</span> o_delete = (oflag &amp; O_DELETE);</span><br><span class="line">  oflag = oflag &amp; ~O_DELETE;</span><br><span class="line"></span><br><span class="line">  fd = ::open64(path, oflag, mode);  <span class="comment">// 调用open64打开文件</span></span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 问打开成功也可能是目录，这里还需要判断是否打开的是普通文件</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat64</span> <span class="title">buf64</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret = ::fstat64(fd, &amp;buf64);</span><br><span class="line">    <span class="keyword">int</span> st_mode = buf64.st_mode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((st_mode &amp; S_IFMT) == S_IFDIR) &#123;</span><br><span class="line">        errno = EISDIR;</span><br><span class="line">        ::close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ::close(fd);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> FD_CLOEXEC</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> flags = ::fcntl(fd, F_GETFD);</span><br><span class="line">        <span class="keyword">if</span> (flags != <span class="number">-1</span>)</span><br><span class="line">            ::fcntl(fd, F_SETFD, flags | FD_CLOEXEC);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (o_delete != <span class="number">0</span>) &#123;</span><br><span class="line">    ::unlink(path);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到JVM最后使用<code>open64</code>这个方法打开文件，网上对于<code>open64</code>这个资料还是很少的，我找到的是<a href="https://www.unix.com/man-page/All/2/open64/" target="_blank" rel="noopener">man page for open64 (all section 2) - Unix &amp; Linux Commands</a>，从中可以看出，<code>open64</code>是为了在32位环境打开大文件的系统调用，但是不是标准的一部分。（这一部分不是很确定，因为没有明确的资料）</p><p>这里的open不是我们以前学C语言时打开文件用的fopen函数，fopen是C标准库里的函数，而open不是，open是POSIX规范中的函数，是不带缓冲的I/O，不带缓冲的I/O相关的函数还有read，write，lseek，close，不带缓冲指的是这些函数都调用内核中的一个系统调用，而C标准库为了减少系统调用，使用了缓存来减少read，write的内存调用。（参考《UNIX环境高级编程》）</p><p>通过上面的代码跟踪，我们知道了<code>FileInputStream#open</code>是使用open系统调用来打开文件，得到文件句柄，现在我们的问题要回到这个文件句柄是如何最终设置到<code>FileDescriptor#fd</code>，我们来看<code>/jdk/src/solaris/native/java/io/io_util_md.c:fileOpen</code>的关键代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fd = handleOpen(ps, flags, <span class="number">0666</span>);</span><br><span class="line"><span class="keyword">if</span> (fd != <span class="number">-1</span>) &#123;</span><br><span class="line">    SET_FD(<span class="keyword">this</span>, fd, fid);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    throwFileNotFoundException(env, path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果文件描述符fd正确，通过<code>SET_FD</code>这个红设置到<code>fid</code>对应的成员变量上：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_FD(this, fd, fid) \</span></span><br><span class="line">    <span class="keyword">if</span> ((*env)-&gt;GetObjectField(env, (<span class="keyword">this</span>), (fid)) != <span class="literal">NULL</span>) \</span><br><span class="line">        (*env)-&gt;SetIntField(env, (*env)-&gt;GetObjectField(env, (<span class="keyword">this</span>), (fid)),IO_fd_fdID, (fd))</span><br></pre></td></tr></table></figure><p><code>SET_FD</code>宏比较简单，获取<code>FileInputStream</code>上的<code>fid</code>这个字段ID对应的字段，然后设置这个字段的<code>IO_fd_fdID</code>对应的字段（<code>FileDescriptor#fd</code>）为文件描述符。</p><p>那这个<code>fid</code>和<code>IO_fd_fdID</code>是哪里来的呢？在<code>/jdk/src/share/native/java/io/FileInputStream.c</code>的开头，可以看到这样的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk/src/share/native/java/io/FileInputStream.c</span></span><br><span class="line">jfieldID fis_fd; <span class="comment">/* id for jobject 'fd' in java.io.FileInputStream */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment"> * static methods to store field ID's in initializers</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_java_io_FileInputStream_initIDs(JNIEnv *env, jclass fdClass) &#123;</span><br><span class="line">    fis_fd = (*env)-&gt;GetFieldID(env, fdClass, <span class="string">"fd"</span>, <span class="string">"Ljava/io/FileDescriptor;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Java_java_io_FileInputStream_initIDs</code>对应<code>FileInputStream</code>中static块调用的<code>initIDs</code>函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/* File Descriptor - handle to the open file */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FileDescriptor fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        initIDs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">initIDs</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有<code>jdk/src/solaris/native/java/io/FileDescriptor_md.c</code>开头：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk/src/solaris/native/java/io/FileDescriptor_md.c</span></span><br><span class="line"><span class="comment">/* field id for jint 'fd' in java.io.FileDescriptor */</span></span><br><span class="line">jfieldID IO_fd_fdID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment"> * static methods to store field ID's in initializers</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_java_io_FileDescriptor_initIDs(JNIEnv *env, jclass fdClass) &#123;</span><br><span class="line">    IO_fd_fdID = (*env)-&gt;GetFieldID(env, fdClass, <span class="string">"fd"</span>, <span class="string">"I"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Java_java_io_FileDescriptor_initIDs</code>对应<code>FileDescriptor</code>中static块调用的<code>initIDs</code>函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDescriptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        initIDs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This routine initializes JNI field offsets for the class */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">initIDs</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码可以看出这样的一个流程：</p><ol><li>JVM加载FileDescriptor类，执行static块中的代码</li><li>执行static块中的代码时，执行initIDs本地方法</li><li>initIDs本地方法只做了一件事情，就是获取fd字段ID，并保存在IO_fd_fdID变量中</li><li>JVM加载FileInputStream类，执行static块中的代码</li><li>执行static块中的代码时，执行initIDs本地方法</li><li>initIDs本地方法只做了一件事情，就是获取fd字段ID，并保存在fis_fd变量中</li><li>后续逻辑直接使用IO_fd_fdID和fis_fd</li></ol><p>为什么会有这样一个奇怪的初始化过程呢，为什么要专门弄一个initIDs方法来提前保存字段ID呢？这是因为特定类的字段ID在一次Java程序的声明周期中是不会变化的，而获取字段ID本身是一个比较耗时的过程，因为如果字段是从父类继承而来，JVM需要遍历继承树来找到这个字段，所以JNI代码的最佳实践就是对使用到的字段ID做缓存。（参考<a href="http://www.ibm.com/developerworks/cn/java/j-jni/index.html" target="_blank" rel="noopener">使用 Java Native Interface 的最佳实践</a>）</p><h2 id="标准输入，标准输出，标准错误输出"><a href="#标准输入，标准输出，标准错误输出" class="headerlink" title="标准输入，标准输出，标准错误输出"></a>标准输入，标准输出，标准错误输出</h2><p>标准输入，标准输出，标准错误输出是所有操作系统都支持的，对于一个进程来说，文件描述符0,1,2固定是标准输入，标准输出，标准错误输出。</p><p>Java对标准输入，标准输出，标准错误输出的支持也是通过FileDescriptor实现的，<code>FileDescriptor</code>中定义了in，out，err这三个静态变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> FileDescriptor in = <span class="keyword">new</span> FileDescriptor(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> FileDescriptor out = <span class="keyword">new</span> FileDescriptor(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> FileDescriptor err = <span class="keyword">new</span> FileDescriptor(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>我们常用的<code>System.out</code>等，就是基于这三个封装的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">System</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> InputStream in = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> PrintStream out = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> PrintStream err = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Initialize the system class.  Called after thread initialization.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initializeSystemClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FileInputStream fdIn = <span class="keyword">new</span> FileInputStream(FileDescriptor.in);</span><br><span class="line">        FileOutputStream fdOut = <span class="keyword">new</span> FileOutputStream(FileDescriptor.out);</span><br><span class="line">        FileOutputStream fdErr = <span class="keyword">new</span> FileOutputStream(FileDescriptor.err);</span><br><span class="line">        setIn0(<span class="keyword">new</span> BufferedInputStream(fdIn));</span><br><span class="line">        setOut0(newPrintStream(fdOut, props.getProperty(<span class="string">"sun.stdout.encoding"</span>)));</span><br><span class="line">        setErr0(newPrintStream(fdErr, props.getProperty(<span class="string">"sun.stderr.encoding"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">setIn0</span><span class="params">(InputStream in)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">setOut0</span><span class="params">(PrintStream out)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">setErr0</span><span class="params">(PrintStream err)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>System作为一个特殊的类，类构造时无法实例化<code>in/out/err</code>，构造发生在<code>initializeSystemClass</code>被调用时，但是<code>in/out/err</code>是被声明为final的，如果声明时和类构造时没有赋值，是会报错的，所以System在实现时，先设置为null，然后通过native方法来在运行时修改（学到了不少奇技淫巧。。），通过<code>setIn0/setOut0/setErr0</code>的注释也可以说明这一点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The following three functions implement setter methods for</span></span><br><span class="line"><span class="comment"> * java.lang.System.&#123;in, out, err&#125;. They are natively implemented</span></span><br><span class="line"><span class="comment"> * because they violate the semantics of the language (i.e. set final</span></span><br><span class="line"><span class="comment"> * variable).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_java_lang_System_setIn0(JNIEnv *env, jclass cla, jobject stream)</span><br><span class="line">&#123;</span><br><span class="line">    jfieldID fid =</span><br><span class="line">        (*env)-&gt;GetStaticFieldID(env,cla,<span class="string">"in"</span>,<span class="string">"Ljava/io/InputStream;"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fid == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    (*env)-&gt;SetStaticObjectField(env,cla,fid,stream);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_java_lang_System_setOut0(JNIEnv *env, jclass cla, jobject stream)</span><br><span class="line">&#123;</span><br><span class="line">    jfieldID fid =</span><br><span class="line">        (*env)-&gt;GetStaticFieldID(env,cla,<span class="string">"out"</span>,<span class="string">"Ljava/io/PrintStream;"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fid == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    (*env)-&gt;SetStaticObjectField(env,cla,fid,stream);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_java_lang_System_setErr0(JNIEnv *env, jclass cla, jobject stream)</span><br><span class="line">&#123;</span><br><span class="line">    jfieldID fid =</span><br><span class="line">        (*env)-&gt;GetStaticFieldID(env,cla,<span class="string">"err"</span>,<span class="string">"Ljava/io/PrintStream;"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fid == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    (*env)-&gt;SetStaticObjectField(env,cla,fid,stream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FileDescriptor关闭逻辑"><a href="#FileDescriptor关闭逻辑" class="headerlink" title="FileDescriptor关闭逻辑"></a>FileDescriptor关闭逻辑</h2><p><code>FileDescriptor</code>的代码不多，除了上面提到的<code>fd</code>成员变量，<code>initIDs</code>初始化构造方法，<code>in/out/err</code>三个标准描述符，只剩下<code>attach</code>和<code>closeAll</code>这两个方法，这两个方法和文件描述符的关闭有关。</p><p>上文提到过，<code>FileInputStream</code>在实例化时，会新建<code>FileDescriptor</code>并调用<code>FileDescriptor#attach</code>方法绑定文件流与文件描述符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    String name = (file != <span class="keyword">null</span> ? file.getPath() : <span class="keyword">null</span>);</span><br><span class="line">    fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">    fd.attach(<span class="keyword">this</span>);</span><br><span class="line">    path = name;</span><br><span class="line">    open(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FileDescriptor#attach</code>实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Closeable c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// first caller gets to do this</span></span><br><span class="line">        parent = c;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (otherParents == <span class="keyword">null</span>) &#123;</span><br><span class="line">        otherParents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        otherParents.add(parent);</span><br><span class="line">        otherParents.add(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        otherParents.add(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>FileDescriptor</code>只和一个<code>FileInputStream/FileOutputStream/RandomAccessFile</code>有关联，则只是简单的保存到<code>parent</code>成员中，如果有多个<code>FileInputStream/FileOutputStream/RandomAccessFile</code>有关联，则所有关联的<code>Closeable</code>都保存到<code>otherParents</code>这个<code>ArrayList</code>中。</p><p>这里其实有个细节，就是<code>parent</code>变量其实只在这个函数有用到，所以上面的逻辑完全可以写成无论<code>FileDescriptor</code>和几个<code>Closeable</code>对象有关联，都直接保存到<code>otherParents</code>这个<code>ArrayList</code>即可，但是极大的概率，一个<code>FileDescriptor</code>只会和一个<code>FileInputStream/FileOutputStream/RandomAccessFile</code>有关联，只有用户调用<code>FileInputStream(FileDescriptor fdObj)</code>这样样的构造函数才会出现多个<code>Closeable</code>对象对应一个<code>FileDescriptor</code>的情况，这里其实是做了优化，在大概率的情况下不新建<code>ArrayList</code>，减少一个对象的创建开销。</p><p>接着看看<code>FileInputStream</code>如何进行关闭操作，如何关闭关联的<code>FileDescriptor</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (closeLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        closed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">        channel.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd.closeAll(<span class="keyword">new</span> Closeable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            close0();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">close0</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><p>首先通过锁保证关闭流程不会被并发调用，设置成员<code>closed</code>为<code>true</code>，接着关闭关联的Channel，这个以后分析NIO的时候再来说。接着就是关闭<code>FileDescriptor</code>了。</p><p><code>FileDescriptor</code>没有提供<code>close</code>方法，而是提供了一个<code>closeAll</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">closeAll</span><span class="params">(Closeable releaser)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!closed) &#123;</span><br><span class="line">        closed = <span class="keyword">true</span>;</span><br><span class="line">        IOException ioe = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> (Closeable c = releaser) &#123;</span><br><span class="line">            <span class="keyword">if</span> (otherParents != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Closeable referent : otherParents) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        referent.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span>(IOException x) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (ioe == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            ioe = x;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            ioe.addSuppressed(x);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException ex) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * If releaser close() throws IOException</span></span><br><span class="line"><span class="comment">             * add other exceptions as suppressed.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (ioe != <span class="keyword">null</span>)</span><br><span class="line">                ex.addSuppressed(ioe);</span><br><span class="line">            ioe = ex;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ioe != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> ioe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FileDescriptor</code>的关闭流程有点绕，效果是会把关联的<code>Closeable</code>对象（其实只可能是<code>FileInputStream/FileOutputStream/RandomAccessFile</code>，而这三个类的<code>close</code>方法实现是一模一样的）通通都关闭掉（效果是这些对象的<code>closed</code>设置为true，关联的Channel关闭，这样这个对象就无法使用了），最后这些关联的对象中，只会有一个对象的<code>close0</code>本地方法被调用，这个方法中调用系统调用<code>close</code>来真正关闭文件描述符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /jdk/src/solaris/native/java/io/FileInputStream_md.c</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_java_io_FileInputStream_close0(JNIEnv *env, jobject <span class="keyword">this</span>) &#123;</span><br><span class="line">    fileClose(env, <span class="keyword">this</span>, fis_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /jdk/src/solaris/native/java/io/io_util_md.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fileClose</span><span class="params">(JNIEnv *env, jobject <span class="keyword">this</span>, jfieldID fid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FD fd = GET_FD(<span class="keyword">this</span>, fid);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the fd to -1 before closing it so that the timing window</span></span><br><span class="line"><span class="comment">     * of other threads using the wrong fd (closed but recycled fd,</span></span><br><span class="line"><span class="comment">     * that gets re-opened with some other filename) is reduced.</span></span><br><span class="line"><span class="comment">     * Practically the chance of its occurance is low, however, we are</span></span><br><span class="line"><span class="comment">     * taking extra precaution over here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SET_FD(<span class="keyword">this</span>, <span class="number">-1</span>, fid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试关闭0，1，2文件描述符，需要特殊的操作。首先这三个是不能关闭的，</span></span><br><span class="line">    <span class="comment">// 如果关闭的，后续打开的文件就会占用这三个描述符，</span></span><br><span class="line">    <span class="comment">// 所以合理的做法是把要关闭的描述符指向/dev/null，实现关闭的效果</span></span><br><span class="line">    <span class="comment">// 不过Java代码中，正常是没办法关闭0，1，2文件描述符的</span></span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= STDIN_FILENO &amp;&amp; fd &lt;= STDERR_FILENO) &#123;</span><br><span class="line">        <span class="keyword">int</span> devnull = open(<span class="string">"/dev/null"</span>, O_WRONLY);</span><br><span class="line">        <span class="keyword">if</span> (devnull &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            SET_FD(<span class="keyword">this</span>, fd, fid); <span class="comment">// restore fd</span></span><br><span class="line">            JNU_ThrowIOExceptionWithLastError(env, <span class="string">"open /dev/null failed"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dup2(devnull, fd);</span><br><span class="line">            close(devnull);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (close(fd) == <span class="number">-1</span>) &#123; <span class="comment">// 关闭非0，1，2的文件描述符只是调用close系统调用</span></span><br><span class="line">        JNU_ThrowIOExceptionWithLastError(env, <span class="string">"close failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在回头来讨论一个问题，就是为什么关闭一个<code>FileInputStream/FileOutputStream/RandomAccessFile</code>，就要把他关联的文件描述符所关联的所有<code>FileInputStream/FileOutputStream/RandomAccessFile</code>对象都关闭呢？</p><p>这个可以看看<code>FileInputStream#close</code>的JavaDoc：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Closes this file input stream and releases any system resources</span><br><span class="line">associated with the stream.</span><br><span class="line"></span><br><span class="line">If this stream has an associated channel then the channel is closed</span><br><span class="line">as well.</span><br></pre></td></tr></table></figure><p>也就是说<code>FileInputStream#close</code>是会吧输入/出流对应的系统资源关闭的，也就是输入/出流对应的文件描述符会被关闭，而如果这个文件描述符还关联这其他输入/出流，如果文件描述符都被关闭了，这些流自然也就不能用了，所以closeAll里把这些关联的流通通都关闭掉，使其不再可用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>FileDescriptor</code>的作用是保存操作系统中的文件描述符</li><li><code>FileDescriptor</code>实例会被<code>FileInputStream/FileOutputStream/RandomAccessFile</code>持有，这三个类在打开文件时，在JNI代码中使用<code>open</code>系统调用打开文件，得到文件描述符在JNI代码中设置到<code>FileDescriptor</code>的<code>fd</code>成员变量上</li><li>关闭<code>FileInputStream/FileOutputStream/RandomAccessFile</code>时，会关闭底层对应的文件描述符，如果此文件描述符被多个<code>FileInputStream/FileOutputStream/RandomAccessFile</code>对象持有，则这些对象都会被关闭。关闭是文件底层是通过调用<code>close</code>系统调用实现的。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《UNIX环境高级编程》</li><li><a href="https://blog.csdn.net/cywosp/article/details/38965239" target="_blank" rel="noopener">每天进步一点点——Linux中的文件描述符与打开文件之间的关系 - CSDN博客</a></li><li><a href="https://blog.csdn.net/qq_29350001/article/details/65437279" target="_blank" rel="noopener">UNIX再学习 – 文件描述符 - CSDN博客</a></li><li><a href="https://www.cnblogs.com/bakari/p/5520860.html" target="_blank" rel="noopener">Linux探秘之用户态与内核态 - aCloudDeveloper - 博客园</a></li><li><a href="https://www.cnblogs.com/sfireworks/p/4428972.html" target="_blank" rel="noopener">关于内核态和用户态切换开销的测试 - fireworks - 博客园</a></li><li><a href="https://www.zhihu.com/question/32043825" target="_blank" rel="noopener">系统调用真正的效率瓶颈在哪里？ - 知乎</a></li><li><a href="http://www.ibm.com/developerworks/cn/java/j-jni/index.html" target="_blank" rel="noopener">使用 Java Native Interface 的最佳实践</a></li><li><a href="https://stackoverflow.com/questions/34980241/why-closing-an-input-stream-closes-the-associated-file-descriptor-as-well-even" target="_blank" rel="noopener">java - Why closing an Input Stream closes the associated File Descriptor as well, even the File Descriptor is shared among multiple streams ? - Stack Overflow</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;操作系统使用文件描述符来指代一个打开的文件，对文件的读写操作，都需要文件描述符作为参数。Java虽然在设计上使用了抽象程度更高的流来作为文件操作的模型，但是底层依然要使用文件描述符与操作系统交互，而Java世界里文件描述符的对应类就是FileDescriptor。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://mushanshitiancai.github.io/categories/Java/"/>
    
      <category term="JDK源码阅读" scheme="http://mushanshitiancai.github.io/categories/Java/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="java" scheme="http://mushanshitiancai.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JVM堆内存使用率持续上升的一种排查思路</title>
    <link href="http://mushanshitiancai.github.io/2018/05/28/java/debug/JVM%E5%A0%86%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E7%8E%87%E6%8C%81%E7%BB%AD%E4%B8%8A%E5%8D%87%E7%9A%84%E4%B8%80%E7%A7%8D%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF/"/>
    <id>http://mushanshitiancai.github.io/2018/05/28/java/debug/JVM堆内存使用率持续上升的一种排查思路/</id>
    <published>2018-05-28T11:43:09.000Z</published>
    <updated>2018-05-29T15:13:43.019Z</updated>
    
    <content type="html"><![CDATA[<p>最近新版本发布后，在运行一段时间后程序突然无响应了，观察监控，发现JVM堆内存占用在某个时间点突然飙升，最终导致应用无响应：</p><p><img src="/img/jvm_memory_up.png" alt=""></p><p>重启Tomcat后，应用恢复正常，并且后续时间没有发生内存上涨问题。</p><p>分析这个JVM内存曲线，他是直线上升的，以前遇到过类似的场景，会导致这种直线（匀速）上升的，一般是一个死循环导致的，如果是普通请求资源泄露的话，上升曲线不会这么平稳，会和请求量有一定的关系。</p><p>死循环导致这个线程的资源无法释放，随着循环次数的增多，累积的对象越来越多，最终导致堆内存耗尽。</p><p>那要如何定位到具体的死循环位置呢？这个是个难题。之前遇到类似的问题是通过dump生产环境的JVM内存来分析，耗时耗力。结合之前的经验，这次我直接去nginx日志搜索响应码为504的请求，果不其然，在内存飙升时间点附近，有一个被响应504的请求。</p><p>504是什么响应码呢？这个响应码比较少遇到，指的是网关超时 (Gateway timeout)。当一个请求到Tomcat后，Tomcat如果陷入死循环，那么这个请求自然无法得到响应，nginx等待响应超时，响应给用户504。</p><p>504响应时间点和内存飙升时间点对的上，那么大概率就是这个接口导致的，详细分析这个接口的代码，发现了在特殊参数的情况下，会进入死循环，修改后问题解决。</p><p>总结：</p><ol><li>观察JVM内存曲线，是否是匀速上升</li><li>搜索Nginx响应码为504的日志，查看日志时间是否和内存上升时间点匹配</li><li>分析Nginx响应码为504的请求，确认是否存在死循环逻辑</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近新版本发布后，在运行一段时间后程序突然无响应了，观察监控，发现JVM堆内存占用在某个时间点突然飙升，最终导致应用无响应：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/jvm_memory_up.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;重启Tomcat后，应用恢复正常，并
      
    
    </summary>
    
      <category term="Java" scheme="http://mushanshitiancai.github.io/categories/Java/"/>
    
    
      <category term="java" scheme="http://mushanshitiancai.github.io/tags/java/"/>
    
      <category term="jvm" scheme="http://mushanshitiancai.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>AWS S3 Range下载响应测试</title>
    <link href="http://mushanshitiancai.github.io/2018/05/09/network/AWS-S3-Range%E4%B8%8B%E8%BD%BD%E5%93%8D%E5%BA%94%E6%B5%8B%E8%AF%95/"/>
    <id>http://mushanshitiancai.github.io/2018/05/09/network/AWS-S3-Range下载响应测试/</id>
    <published>2018-05-09T01:44:02.000Z</published>
    <updated>2018-05-21T13:57:43.974Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP范围请求（Range Requests）是用于获取对象指定范围内容的请求规范，常用语HTTP断点续传和多线程下载。</p><p>Range头部的格式可能的格式较多，这里通过调用AWS S3服务来看一下，一个规范的文件下载服务是如何响应范围请求的。</p><p>HTTP范围请求的资料可以参考：</p><ul><li><a href="https://blog.csdn.net/u012062760/article/details/77096479" target="_blank" rel="noopener">RFC7233 HTTP范围请求(Range Requests)</a></li><li><a href="https://tools.ietf.org/html/rfc7233" target="_blank" rel="noopener">RFC 7233 - Hypertext Transfer Protocol (HTTP/1.1): Range Requests</a></li></ul><a id="more"></a><p>请求范例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">请求：</span><br><span class="line">#GET http://s3-ap-southeast-1.amazonaws.com/cs-aws-prod/1e9471c2-a37a-46ef-8ff2-24668784a6b4</span><br><span class="line">HTTP Request (com.jcabi.http.request.BaseRequest):</span><br><span class="line">Authorization: AWS AKIAIMS5FEA5TVKVCJSQ:YOEn+UYjvog0N95eyoutbDuqypQ=</span><br><span class="line">Date: Wed, 09 May 2018 01:42:31 GMT</span><br><span class="line">Range: bytes=1-10</span><br><span class="line"></span><br><span class="line">[request body length = 0]</span><br><span class="line"></span><br><span class="line">响应：</span><br><span class="line">206 Partial Content [http://s3-ap-southeast-1.amazonaws.com/cs-aws-prod/1e9471c2-a37a-46ef-8ff2-24668784a6b4]</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">ETag: &quot;3535ffff5715f4e218758b22dce07bfb&quot;</span><br><span class="line">X-Amz-Request-Id: BCEDD052EF0DDF74</span><br><span class="line">Content-Length: 10</span><br><span class="line">X-Amz-Id-2: ru/QjNwx4QfHz2Jn+pO8kdrj4mDO7YM4NiTigA1EOJcR4lIaV8XpjJw79tbVyPKKpCgum9htdYM=</span><br><span class="line">Content-Range: bytes 1-10/53</span><br><span class="line">Date: Wed, 09 May 2018 01:42:34 GMT</span><br><span class="line">Last-Modified: Wed, 09 May 2018 01:42:30 GMT</span><br><span class="line">Server: AmazonS3</span><br><span class="line">Content-Type: binary/octet-stream</span><br><span class="line"></span><br><span class="line">[body length = 10]</span><br></pre></td></tr></table></figure><p>测试结果：</p><table><thead><tr><th>Range头部</th><th>格式合法</th><th>响应码</th><th>响应体</th><th>Content-Range</th></tr></thead><tbody><tr><td>Range:</td><td>不合法</td><td>200</td><td>返回全部内容</td><td>无</td></tr><tr><td>Range: a</td><td>不合法</td><td>200</td><td>返回全部内容</td><td>无</td></tr><tr><td>Range: 0</td><td>不合法</td><td>200</td><td>返回全部内容</td><td>无</td></tr><tr><td>Range: bytes</td><td>不合法</td><td>200</td><td>返回全部内容</td><td>无</td></tr><tr><td>Range: bytes a</td><td>不合法</td><td>200</td><td>返回全部内容</td><td>无</td></tr><tr><td>Range: bytes 1</td><td>不合法</td><td>200</td><td>返回全部内容</td><td>无</td></tr><tr><td>Range: bytes=1</td><td>不合法</td><td>200</td><td>返回全部内容</td><td>无</td></tr><tr><td>Range: bytes=-</td><td>不合法</td><td>200</td><td>返回全部内容</td><td>无</td></tr><tr><td>Range: bytes=1-10-</td><td>不合法</td><td>200</td><td>返回全部内容</td><td>无</td></tr><tr><td>Range: bytes=1-10a</td><td>不合法</td><td>200</td><td>返回全部内容</td><td>无</td></tr><tr><td>Range: bytes=1–</td><td>不合法</td><td>200</td><td>返回全部内容</td><td>无</td></tr><tr><td>Range: bytes=1–1</td><td>不合法</td><td>200</td><td>返回全部内容</td><td>无</td></tr><tr><td>Range: bytes=10-1</td><td><strong>不合法</strong></td><td>200</td><td>返回全部内容</td><td>无</td></tr><tr><td>Range: bytes=0-</td><td>合法</td><td><strong>206</strong></td><td>返回全部内容</td><td>bytes 0-${len-1}/${len}</td></tr><tr><td>Range: bytes=1-</td><td>合法</td><td><strong>206</strong></td><td>返回第一个字节到最后一个字节</td><td>bytes 1-${len-1}/${len}</td></tr><tr><td>Range: bytes={len}-</td><td>合法</td><td><strong>416</strong></td><td>InvalidRange错误信息</td><td>无</td></tr><tr><td>Range: bytes=-10</td><td>合法</td><td><strong>206</strong></td><td>返回最后10个字节</td><td>bytes ${len-10}-${len-1}/${len}</td></tr><tr><td>Range: bytes=-{len}</td><td>合法</td><td><strong>206</strong></td><td>返回全部内容</td><td>bytes 0-${len-1}/${len}</td></tr><tr><td>Range: bytes=-{len+1}</td><td>合法</td><td><strong>206</strong></td><td>返回全部内容</td><td>bytes 0-${len-1}/${len}</td></tr><tr><td>Range: bytes=1-10</td><td>合法</td><td><strong>206</strong></td><td>返回第一个字节到第10个字节</td><td>bytes 1-10/${len}</td></tr><tr><td>Range: bytes=0-{len+1}</td><td>合法</td><td><strong>206</strong></td><td>返回全部内容</td><td>bytes 0-${len-1}/${len}</td></tr><tr><td>Range: bytes={len-1}-{len}</td><td>合法</td><td><strong>206</strong></td><td>返回最后一个字节</td><td>bytes ${len - 1}-${len - 1}/${len}</td></tr><tr><td>Range: bytes={len}-{len+1}</td><td>合法</td><td><strong>416</strong></td><td>InvalidRange错误信息</td><td>无</td></tr><tr><td>Range: bytes=1-2,3-4</td><td>合法</td><td><strong>200</strong></td><td>返回全部内容(说明S3不支持多段范围请求)</td><td>无</td></tr></tbody></table><p>总结：</p><ol><li>不合法的Range头部都被忽略（而不是抛出异常）</li><li>合法的Range请求，都响应206（即使返回的内容是文件完整的内容）</li><li>如果Range的起点位置大于文件最后一个字节，则响应416</li><li>如果Range的终点位置大于文件最后一个字节，不会抛出异常，而是范围到最后一个字节为止</li><li>在响应416的情况下，S3不会响应头部Content-Range: bytes */47022（RFC中是建议（SHOULD而不是MUST，参考<a href="https://tools.ietf.org/html/rfc7233#section-4.4" target="_blank" rel="noopener">资料</a>）响应这个头部，以便于客户端知道文件的大小调整请求）</li><li>AWS S3不支持多段范围请求</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP范围请求（Range Requests）是用于获取对象指定范围内容的请求规范，常用语HTTP断点续传和多线程下载。&lt;/p&gt;
&lt;p&gt;Range头部的格式可能的格式较多，这里通过调用AWS S3服务来看一下，一个规范的文件下载服务是如何响应范围请求的。&lt;/p&gt;
&lt;p&gt;HTTP范围请求的资料可以参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/u012062760/article/details/77096479&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RFC7233 HTTP范围请求(Range Requests)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RFC 7233 - Hypertext Transfer Protocol (HTTP/1.1): Range Requests&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="http" scheme="http://mushanshitiancai.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB笔记-查询计划</title>
    <link href="http://mushanshitiancai.github.io/2018/04/15/db/MongoDB%E7%AC%94%E8%AE%B0-%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92/"/>
    <id>http://mushanshitiancai.github.io/2018/04/15/db/MongoDB笔记-查询计划/</id>
    <published>2018-04-15T09:16:38.000Z</published>
    <updated>2018-04-15T10:16:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB在进行查询时，会分析查询语句，得出可能的查询计划。</p><a id="more"></a><p>这里的查询计划就是各种可能的具体查询方法，比如对于{name:1,age:1}的查询，可能是用{name:1}这个索引进行查询，或者是用{age:1}这个索引进行查询，这些查询步骤就被称为查询计划。</p><p>如果一个索引能够精确匹配这个查询，那么查询优化器就会直接使用这个查询计划，并且不做缓存。</p><p>比如对于{name:1,age:1}的查询，有一个{name:1,age:1}的索引，那么查询优化器就直接使用这个索引，不会有别的逻辑。</p><p>如果一个查询有多个查询计划，则查询优化器会并发执行这些查询计划，从中选择最高效的查询，缓存该查询计划。之后与此查询一样格式的查询（Query Shape一样），都会尝试使用这个查询计划。</p><p>这里说一下Query Shape：查询语句中query，sort，projection的格式定义。比如{age:1}和{age:2}的Query Shape是一样的。这样我们就可以对Query Shape进行处理，从而覆盖到很多查询语句。</p><p>更详细的查询步骤为：</p><ol><li>判断Plan Cache中是否有对应Query Shape的查询计划缓存</li><li>如果没有缓存，则分析查询语句与全部的索引，得出所有可能的查询计划，然后并发执行查询计划，得到最优的查询计划。缓存最优查询计划到Plan Cache中，然后执行该查询计划得到结果。</li><li>如果有缓存，则触发replanning机制，就是判断这个缓存的查询计划性能是否可以，如果可以的话执行这个查询计划得到结果。如果这个查询计划被认为性能不佳，则会从Plan Cache中清除掉，然后走没有命中查询计划缓存的步骤。</li></ol><p>这个步骤的流程图如下：</p><p><img src="https://docs.mongodb.com/manual/_images/query-planner-diagram.bakedsvg.svg" alt=""></p><h2 id="旧版本"><a href="#旧版本" class="headerlink" title="旧版本"></a>旧版本</h2><p>MongoDB2.x对于查询计划的选择与缓存的机制与3.x有很大的区别。如果你手上使用的是旧版本的MongoDB还是需要了解一下的。</p><ol><li>根据查询模式（Query pattern）判断是否存在CachedPlan，如果存在直接选择</li><li>如果没有缓存记录，查询优化器创建新查询计划并标记类型，如果类型为Optimal Plan则直接执行该Plan；如果不存在Optimal Plan，MongoDB会并发尝试可能的Helpful Plan以及不使用索引的基础查询。查询优化器会对比选择表现最好的查询计划继续执行，并将查询模式与最终查询计划的映射写入CachedPlan。</li></ol><p>与3.x的区别在于，对于查询计划，区分为<code>Optimal Plan</code>和<code>Helpful Plan</code>。如果是<code>Optimal Plan</code>会直接执行而不进行性能比较。如果有多个<code>Optimal Plan</code>会执行第一个。而3.x一视同仁，都会进行性能比较。</p><p>缓存的查询计划在以下条件下会清空并重新评估： </p><ul><li>集合收到1000次写操作 </li><li>执行reindex </li><li>添加或删除索引 </li><li>mongod进程重启 </li><li>查询时指定explain()</li></ul><p>这里与3.x的区别是如果没有1000次更新或者其他会导致查询计划缓存更新的操作的话，之后的查询都会使用这个查询计划，一旦这个查询计划其实是慢查询的话，就会导致数据库出现大量慢查询。而3.x即使命中了缓存，也依然会进行性能评估，如果评估不通过，这个缓存会被清理。</p><p>参考：<a href="https://blog.csdn.net/wentyoon/article/details/78853962" target="_blank" rel="noopener">MongoDB索引-查询优化器</a></p><h2 id="清空Plan-Cache"><a href="#清空Plan-Cache" class="headerlink" title="清空Plan Cache"></a>清空Plan Cache</h2><p>新建索引，或者drop集合都会清空Plan Cache。</p><p>重启MongoDB也会清空Plan Cache。</p><p>MongoDB2.6提供了操作Plan Cache的方法。</p><p>使用<code>PlanCache.clear()</code>可以清空Plan Cache。</p><p>使用<code>PlanCache.clearPlansByQuery()</code>可以清除某个Query Shape的Plan Cache。</p><h2 id="PlanCache对象"><a href="#PlanCache对象" class="headerlink" title="PlanCache对象"></a>PlanCache对象</h2><p>MongoDB2.6提供了操作Plan Cache的方法。</p><p><code>db.collection.getPlanCache()</code>：获取集合的Plan Cache对象，可以进行进一步操作。<br><code>PlanCache.clear()</code>：清空Plan Cache。<br><code>PlanCache.clearPlansByQuery()</code>：清除某个Query Shape的Plan Cache。<br><code>PlanCache.getPlansByQuery()</code>：获取某个Query Shape的执行计划缓存。<br><code>PlanCache.listQueryShapes()</code>：获取缓存的Query Shape。</p><h2 id="IndexFilter"><a href="#IndexFilter" class="headerlink" title="IndexFilter"></a>IndexFilter</h2><p>IndexFilter用于指定查询优化器对于特定Query Shape如何使用索引。IndexFilter只提供了索引供查询优化器分析，查询优化器最终还是根据分析与执行结果来决定用哪个执行计划。</p><p>如果对应的Query Shape有指定IndexFilter，则查询的hint会被无视。</p><p>IndexFilter可以通过命令移除，也将在实例重启后清空。</p><p><a href="http://www.mongoing.com/eshu_explain2" target="_blank" rel="noopener">MongoDB干货系列2-MongoDB执行计划分析详解（2）</a></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>新建user集合，并插入数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.user.createIndex(&#123;<span class="attr">name</span>:<span class="number">1</span>&#125;)</span><br><span class="line">db.user.createIndex(&#123;<span class="attr">age</span>:<span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line">db.user.insert(&#123; </span><br><span class="line">    <span class="string">"name"</span> : <span class="string">"mushan"</span>, </span><br><span class="line">    <span class="string">"age"</span> : <span class="number">18</span>, </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>执行<code>db.user.find({name:1,age:1}).explain()</code>，看一下查询优化器都分析出了哪些查询计划：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    <span class="attr">"queryPlanner"</span> : &#123;</span><br><span class="line">        <span class="attr">"winningPlan"</span> : &#123;</span><br><span class="line">            <span class="attr">"stage"</span> : <span class="string">"FETCH"</span>, </span><br><span class="line">            <span class="attr">"filter"</span> : &#123;</span><br><span class="line">                <span class="attr">"age"</span> : &#123;</span><br><span class="line">                    <span class="attr">"$eq"</span> : <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, </span><br><span class="line">            <span class="attr">"inputStage"</span> : &#123;</span><br><span class="line">                <span class="attr">"stage"</span> : <span class="string">"IXSCAN"</span>, </span><br><span class="line">                <span class="attr">"indexName"</span> : <span class="string">"name_1"</span>, </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, </span><br><span class="line">        <span class="attr">"rejectedPlans"</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"stage"</span> : <span class="string">"FETCH"</span>, </span><br><span class="line">                <span class="attr">"filter"</span> : &#123;</span><br><span class="line">                    <span class="attr">"name"</span> : &#123;</span><br><span class="line">                        <span class="attr">"$eq"</span> : <span class="number">1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, </span><br><span class="line">                <span class="attr">"inputStage"</span> : &#123;</span><br><span class="line">                    <span class="attr">"stage"</span> : <span class="string">"IXSCAN"</span>, </span><br><span class="line">                    <span class="attr">"indexName"</span> : <span class="string">"age_1"</span>, </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"stage"</span> : <span class="string">"FETCH"</span>, </span><br><span class="line">                <span class="attr">"inputStage"</span> : &#123;</span><br><span class="line">                    <span class="attr">"stage"</span> : <span class="string">"AND_SORTED"</span>, </span><br><span class="line">                    <span class="attr">"inputStages"</span> : [</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="attr">"stage"</span> : <span class="string">"IXSCAN"</span>, </span><br><span class="line">                            <span class="attr">"indexName"</span> : <span class="string">"name_1"</span>, </span><br><span class="line">                        &#125;, </span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="attr">"stage"</span> : <span class="string">"IXSCAN"</span>, </span><br><span class="line">                            <span class="attr">"indexName"</span> : <span class="string">"age_1"</span>, </span><br><span class="line">                        &#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，一共有三个查询计划：</p><ol><li>使用<code>name_1</code>索引</li><li>使用<code>age_1</code>索引</li><li>使用<code>age_1</code>和<code>name_1</code>索引结合<code>AND_SORTED</code></li></ol><p>对于MongoDB来说，他也没办法知道到底哪种方式是最快的，所以他就同时执行这三个查询计划，最终胜利的是使用<code>name_1</code>的查询计划。（这个例子中，使用<code>name_1</code>索引和使用<code>age_1</code>索引速度应该是一样的，这种情况下MongoDB就随便选一个了（具体的规则要看代码了））</p><p>按照上面的说明，对于这种有多个查询计划的语句，查询优化器会缓存最优查询计划，所以这里应该是缓存了使用<code>name_1</code>的查询计划，我们来查询看看。</p><p>执行<code>db.user.getPlanCache().listQueryShapes()</code>会发现为空，这是因为<code>explain()</code>不会去缓存查询计划。所以我们需要执行一下真实的查询：<code>db.user.find({name:1,age:1})</code>，然后执行<code>db.user.getPlanCache().listQueryShapes()</code>，得到结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"query"</span> : &#123;</span><br><span class="line">            <span class="attr">"name"</span> : <span class="number">1</span>, </span><br><span class="line">            <span class="attr">"age"</span> : <span class="number">1</span></span><br><span class="line">        &#125;, </span><br><span class="line">        <span class="attr">"sort"</span> : &#123;</span><br><span class="line"></span><br><span class="line">        &#125;, </span><br><span class="line">        <span class="attr">"projection"</span> : &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>可以看到这个查询作已经被作为一个Query Shape缓存下来了。</p><p>然后我们执行<code>db.user.getPlanCache().getPlansByQuery({name:2,age:10})</code>来看看Plan Cache是如何这个查询的查询计划的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"details"</span> : &#123;</span><br><span class="line">            <span class="attr">"solution"</span> : <span class="string">"(index-tagged expression tree: tree=Node\n---Leaf \n---Leaf &#123; name: 1.0 &#125;, pos: 0\n)"</span></span><br><span class="line">        &#125;, </span><br><span class="line">        <span class="attr">"reason"</span> : &#123;</span><br><span class="line">            <span class="attr">"score"</span> : <span class="number">1.0003000000000002</span>, </span><br><span class="line">            <span class="attr">"stats"</span> : &#123;</span><br><span class="line">                <span class="attr">"stage"</span> : <span class="string">"FETCH"</span>, </span><br><span class="line">                <span class="attr">"filter"</span> : &#123;</span><br><span class="line">                    <span class="attr">"age"</span> : &#123;</span><br><span class="line">                        <span class="attr">"$eq"</span> : <span class="number">1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, </span><br><span class="line">                <span class="attr">"inputStage"</span> : &#123;</span><br><span class="line">                    <span class="attr">"stage"</span> : <span class="string">"IXSCAN"</span>, </span><br><span class="line">                    <span class="attr">"indexName"</span> : <span class="string">"name_1"</span>, </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"details"</span> : &#123;</span><br><span class="line">            <span class="attr">"solution"</span> : <span class="string">"(index-tagged expression tree: tree=Node\n---Leaf &#123; age: 1.0 &#125;, pos: 0\n---Leaf \n)"</span></span><br><span class="line">        &#125;, </span><br><span class="line">        <span class="attr">"reason"</span> : &#123;</span><br><span class="line">            <span class="attr">"score"</span> : <span class="number">1.0003000000000002</span>, </span><br><span class="line">            <span class="attr">"stats"</span> : &#123;</span><br><span class="line">                <span class="attr">"stage"</span> : <span class="string">"FETCH"</span>, </span><br><span class="line">                <span class="attr">"filter"</span> : &#123;</span><br><span class="line">                    <span class="attr">"name"</span> : &#123;</span><br><span class="line">                        <span class="attr">"$eq"</span> : <span class="number">1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, </span><br><span class="line">                <span class="attr">"inputStage"</span> : &#123;</span><br><span class="line">                    <span class="attr">"stage"</span> : <span class="string">"IXSCAN"</span>, </span><br><span class="line">                    <span class="attr">"indexName"</span> : <span class="string">"age_1"</span>, </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"details"</span> : &#123;</span><br><span class="line">            <span class="attr">"solution"</span> : <span class="string">"(index-tagged expression tree: tree=Node\n---Leaf &#123; age: 1.0 &#125;, pos: 0\n---Leaf &#123; name: 1.0 &#125;, pos: 0\n)"</span></span><br><span class="line">        &#125;, </span><br><span class="line">        <span class="attr">"reason"</span> : &#123;</span><br><span class="line">            <span class="attr">"score"</span> : <span class="number">1.0002</span>, </span><br><span class="line">            <span class="attr">"stats"</span> : &#123;</span><br><span class="line">                <span class="attr">"stage"</span> : <span class="string">"FETCH"</span>, </span><br><span class="line">                <span class="attr">"inputStage"</span> : &#123;</span><br><span class="line">                    <span class="attr">"stage"</span> : <span class="string">"AND_SORTED"</span>, </span><br><span class="line">                    <span class="attr">"inputStages"</span> : [</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="attr">"stage"</span> : <span class="string">"IXSCAN"</span>, </span><br><span class="line">                            <span class="attr">"indexName"</span> : <span class="string">"name_1"</span>, </span><br><span class="line">                        &#125;, </span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="attr">"stage"</span> : <span class="string">"IXSCAN"</span>, </span><br><span class="line">                            <span class="attr">"indexName"</span> : <span class="string">"age_1"</span>, </span><br><span class="line">                        &#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>上面对输出进行了一些简化，可以看到，缓存中保存了全部的查询计划，但是根据得分进行了排序。从这里我们也可以看出使用<code>age_1</code>索引的查询计划于使用<code>name_1</code>索引的查询计划得分是一样的。</p><p>MongoDB查询优化器根据这个缓存结果，按照上文说的流程来进行replanning机制。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://docs.mongodb.com/manual/core/query-plans/" target="_blank" rel="noopener">Query Plans — MongoDB Manual 3.6</a></li><li><a href="http://www.mongoing.com/eshu_explain1" target="_blank" rel="noopener">MongoDB干货系列2-MongoDB执行计划分析详解（1） | MongoDB中文社区</a></li><li><a href="http://www.mongoing.com/eshu_explain2" target="_blank" rel="noopener">MongoDB干货系列2-MongoDB执行计划分析详解（2） | MongoDB中文社区</a></li><li><a href="https://blog.csdn.net/wentyoon/article/details/78853962" target="_blank" rel="noopener">MongoDB索引-查询优化器 - CSDN博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MongoDB在进行查询时，会分析查询语句，得出可能的查询计划。&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://mushanshitiancai.github.io/categories/MongoDB/"/>
    
    
      <category term="db" scheme="http://mushanshitiancai.github.io/tags/db/"/>
    
      <category term="mongodb" scheme="http://mushanshitiancai.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>URI,URL与URN的区别</title>
    <link href="http://mushanshitiancai.github.io/2018/03/23/network/URI-URL%E4%B8%8EURN%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://mushanshitiancai.github.io/2018/03/23/network/URI-URL与URN的区别/</id>
    <published>2018-03-23T09:27:46.000Z</published>
    <updated>2018-04-15T09:15:58.959Z</updated>
    
    <content type="html"><![CDATA[<p>URI：统一资源标识符 Uniform Resource Identifier<br>URL：统一资源定位符 Uniform Resource Locator<br>URN：统一资源名称 Uniform Resource Name</p><p>URI通过标识符的方式确定一个资源。<br>URL通过定位的方式确定一个资源。<br>URN通过名称的方式确定一个资源。<br>URL和URN是URL的子集。URI可以是URL，URN或者两者都是。</p><p>比如对应人这个资源，用URL的方式表示的话可能是：人类住址协议://地球/中国/福建省/福州市/xxx/马志彬.人。<br>而用URN的表示方式则可用身份证号来唯一确定。<br>而这两种方式都是URI。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/URI_Euler_Diagram_no_lone_URIs.svg/320px-URI_Euler_Diagram_no_lone_URIs.svg.png" alt=""></p><p>URI的格式为<code>URI协议名:内容</code>。<br>通用的URI格式为：<code>scheme:[//[user[:password]@]host[:port]][/path][?query][#fragment]</code><br>URN使用<code>urn</code>作为协议名。 </p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E6%A0%87%E5%BF%97%E7%AC%A6" target="_blank" rel="noopener">统一资源标志符 - 维基百科，自由的百科全书</a></li><li><a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6" target="_blank" rel="noopener">统一资源定位符 - 维基百科，自由的百科全书</a></li><li><a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%90%8D%E7%A7%B0" target="_blank" rel="noopener">统一资源名称 - 维基百科，自由的百科全书</a></li><li><a href="http://www.ibm.com/developerworks/cn/xml/x-urlni.html" target="_blank" rel="noopener">分清 URI、URL 和 URN</a></li><li><a href="https://www.zhihu.com/question/21950864" target="_blank" rel="noopener">HTTP 协议中 URI 和 URL 有什么区别？</a></li><li><a href="https://stackoverflow.com/questions/176264/what-is-the-difference-between-a-uri-a-url-and-a-urn" target="_blank" rel="noopener">http - What is the difference between a URI, a URL and a URN? - Stack Overflow</a></li><li><a href="https://www.w3.org/TR/uri-clarification/" target="_blank" rel="noopener">URIs, URLs, and URNs: Clarifications and Recommendations 1.0</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;URI：统一资源标识符 Uniform Resource Identifier&lt;br&gt;URL：统一资源定位符 Uniform Resource Locator&lt;br&gt;URN：统一资源名称 Uniform Resource Name&lt;/p&gt;
&lt;p&gt;URI通过标识符的方式确定一
      
    
    </summary>
    
    
      <category term="http" scheme="http://mushanshitiancai.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>IndexedDB笔记-基本使用</title>
    <link href="http://mushanshitiancai.github.io/2018/02/27/js/javascript/IndexedDB%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://mushanshitiancai.github.io/2018/02/27/js/javascript/IndexedDB笔记-基本使用/</id>
    <published>2018-02-27T13:42:52.000Z</published>
    <updated>2018-03-03T15:05:31.165Z</updated>
    
    <content type="html"><![CDATA[<p>Web Application，网页应用是大势所趋，网页如果要提供本地应用级别的体验，存储是不可缺少的功能。从最早的Cookie，到LocalStorage，到IndexedDB，前端存储方案从简单的键值对到现在的数据库，功能不断强大。</p><p>IndexedDB是一种可以让你在用户的浏览器内持久化存储数据的方法。IndexedDB为生成Web Application提供了丰富的查询能力，使我们的应用在在线和离线时都可以正常工作。IndexedDB是一个功能完备的NoSQL数据库。</p><a id="more"></a><p>提示：IndexedDB提供的API是底层API，加上IndexedDB异步的设计，在使用上可能会比较麻烦，可以使用第三方对于IndexedDB API的封装库来简化代码，减少痛苦，比如<a href="https://localforage.github.io/localForage/" target="_blank" rel="noopener">localForage</a>，<a href="http://www.dexie.org/" target="_blank" rel="noopener">dexie.js</a>，<a href="https://github.com/erikolson186/zangodb" target="_blank" rel="noopener">ZangoDB</a>，<a href="http://jsstore.net/" target="_blank" rel="noopener">JsStore</a>等。</p><h2 id="打开数据库（database）"><a href="#打开数据库（database）" class="headerlink" title="打开数据库（database）"></a>打开数据库（database）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> request = indexedDB.open(<span class="string">"TestDB"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">request.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 打开数据库失败</span></span><br><span class="line">&#125;</span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 打开数据库成功，成功后request.result会被设置为db对象</span></span><br><span class="line">    <span class="keyword">let</span> db = request.result；</span><br><span class="line">&#125;</span><br><span class="line">request.onupgradeneeded = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 在数据库版本升级时触发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从打开数据库和后端的编程体验就不一样了。首先IndexDB的所有操作都是异步的，打开数据库也不例外。</p><p><code>open</code>函数打开一个数据库连接，第一个参数指定数据库名称，第二个是一个可选参数，指定数据库的版本，如果不指定，则看数据库是否已经存在，如果已经存在，则打开数据库并且不更新版本，如果数据库不存在，则创建该数据库并且版本为1。</p><p><code>open</code>函数会立刻返回一个<code>IDBOpenDBRequest</code>对象，但是这会儿数据库还没打开好。如果数据库打开成功，则触发<code>success</code>事件，并设置Request对象的<code>result</code>字段为<code>IDBDatabase</code>实例。然后我们就可以用db实例来进行数据库操作了。</p><h3 id="数据库版本"><a href="#数据库版本" class="headerlink" title="数据库版本"></a>数据库版本</h3><p>数据库的版本也是令人疑惑的一个地方，之前接触的后端数据库都没有版本的概念。一般我们在使用SQL数据库的时候，在应用开始使用数据库前，我们要执行建库建表语句，然后应用才能正常的使用数据库。而在开发的过程中，如果需要升级数据表的结构，我们需要通知DBA在夜深人静的时候执行更新数据表结构的语句。</p><p>对于后端开发，我们可以专门的有人有时间去维护数据库结构，而对于浏览器端则不一样了，你的代码在客户端建立了一个数据表，之后需要更新结构，是不会有专人去更新的，还是得你的JS代码来更新。那如何知这个用户的浏览器中的数据表需要更新了呢？一种方法就是程序根据当前需要来检测浏览器中的表结构，索引是否符合当前需求，但是随着程序的不断维护，这个检测代码会越发的复杂，所以IndexedDB设计上就考虑了这个场景，为数据库的结构定义版本，如果需要修改数据表结构，就增加版本。IndexedDB检测当前版本和客户端的版本是否一致，如果客户端的版本低于当前需要的版本，则触发<code>upgradeneeded</code>事件，让用户有机会去执行升级数据表结构的代码。</p><p>所以<code>onupgradeneeded</code>回调函数会在<code>open</code>一个大于浏览器中现存版本的数据库时触发，也只有在这个函数中可以更新对象存储空间和索引。</p><h2 id="Object-Store"><a href="#Object-Store" class="headerlink" title="Object Store"></a>Object Store</h2><p>SQL数据库使用表来存储记录，IndexedDB中没有表，而是使用object store（对象存储空间）来存储记录。每条记录需要和一个键相关联。</p><p>可以指定记录中的一个字段作为键值（key path），或者可以使用自动生成的递增数字作为键值（key generate）。</p><table><thead><tr><th>Key Path</th><th>Key Generator</th><th>说明</th></tr></thead><tbody><tr><td>No</td><td>No</td><td>这个存储对象空间可以放任何类型的值（原始类型，对象），但是需要指定一个单独的Key与值进行关联</td></tr><tr><td>Yes</td><td>No</td><td>这个存储对象空间只能存放对象，这个对象必须有一个和KeyPath同名的属性</td></tr><tr><td>No</td><td>Yes</td><td>这个存储对象空间可以放任何类型的值（原始类型，对象），与值关联的Key会自动生成，如果你要指定，也是可以的</td></tr><tr><td>Yes</td><td>Yes</td><td>这个存储对象空间只能存放对象，这个对象必须有一个和KeyPath同名的属性，这个属性值会自动生成，但是如果属性值存在，则会使用属性值</td></tr></tbody></table><p>看着这两个的定义还是有点复杂的。我们可以联系SQL数据库来思考。SQL的表结构包含多个字段，必须有一个主键。主键可以设置为自增或者是自定义。IndexedDB只不过是存储结构有一些不同，它更加灵活，它也需要一个主键，只是这个可以是数据上的，也可以是数据外的。KeyPath为No，也就是不在数据中保存主键，所以存储对象空间可以存放任何类型，而KeyPath为Yes，则需要在数据中保存主键，所以数据也就只能是对象了。Key Generator则是指定主键是否是自增的，如果是Yes，则主键自增，但是也可以自己指定，如果为No，则主键必须用户自己指定。</p><p><code>key path</code>和<code>key generate</code>配置的是对象存储空间的主键和是否自增。IndexedDB还支持索引和唯一索引，前提是对象存储空间存储的是对象。</p><p>新建对象存储空间方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objectStore = IDBDatabase.createObjectStore(name, options);</span><br></pre></td></tr></table></figure><p><code>name</code>参数指定对象存储空间名称，<code>options</code>参数是可选的，可选的属性有：</p><ul><li><code>keyPath</code>： 指定主键，可以是一个数组。如果没有指定，则会使用独立的键值（out-of-line keys）作为主键</li><li><code>autoIncrement</code>：对应上面说的Key Generator配置，默认false</li></ul><p>新建索引方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myIDBIndex = objectStore.createIndex(indexName, keyPath, objectParameters);</span><br></pre></td></tr></table></figure><p><code>indexName</code>指定索引名称。<code>keyPath</code>指定索引的键，可以是一个数组。<code>objectParameters</code>参数是可选的，可选的属性有：</p><ul><li><code>unique</code>：指定索引为唯一索引</li><li><code>multiEntry</code>：</li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>IndexedDB所有操作都需要在事务上进行，而且事务都是显式的。我们通过数据库对象得到事务，然后在事务上提交操作。</p><p>IndexedDB事务有三种模式<code>readonly</code>，<code>readwrite</code>和<code>versionchange</code>。如果事务只有读取数据库的操作，则使用<code>readonly</code>模式，如果事务需要更新数据库需要使用<code>readwrite</code>模式。<code>versionchange</code>事务用于更新数据库结构，一般情况下我们无法获取这种模式的事务，但是在指定更高version来打开数据库时，数据库会开启此事务，并触发<code>onupgradeneeded()</code>回调，这就是为啥只能在<code>onupgradeneeded()</code>中更新数据库结构的原因。</p><p>开启事务：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> IDBTransaction = IDBDatabase.transaction(storeNames, mode);</span><br></pre></td></tr></table></figure><ul><li><code>storeNames</code> object store名称数组，用于指定事务操作覆盖的object store</li><li><code>mode</code> 事务模式，可选值为<code>readonly</code>，<code>readwrite</code>，默认值为<code>readonly</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该事务需要操作'my-store-name'和'my-store-name2'这两个对象存储空间</span></span><br><span class="line"><span class="keyword">var</span> transaction = db.transaction([<span class="string">'my-store-name'</span>, <span class="string">'my-store-name2'</span>]); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 该事物只操作my-store-name这个对象存储空间，可以直接用字符串</span></span><br><span class="line"><span class="keyword">var</span> transaction = db.transaction(<span class="string">'my-store-name'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该事物需要操作所有的对象存储空间</span></span><br><span class="line"><span class="keyword">var</span> transaction = db.transaction(db.objectStoreNames);</span><br></pre></td></tr></table></figure><p>个人观点是，事务在声明时就需要指定模式和之后操作涉及的对象存储空间，其实是比较麻烦的，为什么这么做，应该是为了更容易的优化性能。指定操作的模式，那对于自读模式，可以不用加锁的并发，对于读写模式，则可能需要加锁。同时指定了操作的object store，则可以确定要对那些object store（以上属于推测）。</p><p>事务能接收三中DOM事件：<code>error</code>, <code>abort</code>, <code>complete</code>。在事务中提交的操作发生的错误都会冒泡到事务（然后冒泡到db实例）。在事务发生错误时，事务会回滚，除非你在错误处理函数中调用<code>preventDefault()</code>。如果你没有处理错误或者调用了事务的<code>abort()</code>方法，则事务回滚，并触发<code>abort</code>事件。如果事务成功，触发<code>complete</code>事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> transaction = db.transaction(<span class="string">"user"</span>, <span class="string">"readwrite"</span>);</span><br><span class="line">transaction.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 事务失败时触发</span></span><br><span class="line">&#125;;</span><br><span class="line">transaction.oncomplete = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 事务成功结束时触发</span></span><br><span class="line">&#125;;</span><br><span class="line">transaction.onabort = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 事务回滚时触发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事务声明好了后，我们通过事务获取object storage，然后就可以对object storage进行操作了。获取<a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore" target="_blank" rel="noopener">IDBObjectStore</a>对象的方法如下，注意，这里只能获取在新建transaction时指定的object storage数组中的object storage：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IDBObjectStore objectStore = IDBTransaction.objectStore(name);</span><br></pre></td></tr></table></figure><h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IDBRequest request = objectStore.add(value);</span><br><span class="line">IDBRequest request = objectStore.add(value, key);</span><br></pre></td></tr></table></figure><p>拿到<code>IDBRequest</code>对象，可以通过<code>onerror</code>和<code>onsuccess</code>两个回调来监听操作是否成功或者失败。</p><p>如果object store没有使用key path，则需要指定数据的键，即使用<code>objectStore.add(value, key)</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> objectStore = transaction.objectStore(<span class="string">"user"</span>);</span><br><span class="line"><span class="keyword">let</span> r = objectStore.add(&#123;...&#125;, <span class="string">"name"</span>);</span><br><span class="line">r.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'add request success'</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">r.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'add request error'</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IDBRequest request = objectStore.delete(Key);</span><br><span class="line">IDBRequest request = objectStore.delete(KeyRange);</span><br><span class="line"></span><br><span class="line">IDBRequest request = objectStore.clear();</span><br></pre></td></tr></table></figure><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IDBRequest request = objectStore.put(item);</span><br><span class="line">IDBRequest request = objectStore.put(item, key);</span><br></pre></td></tr></table></figure><h2 id="统计数据数量"><a href="#统计数据数量" class="headerlink" title="统计数据数量"></a>统计数据数量</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IDBRequest request = ObjectStore.count();</span><br><span class="line">IDBRequest request = ObjectStore.count(query);</span><br></pre></td></tr></table></figure><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IDBRequest request = objectStore.get(key);</span><br><span class="line">IDBRequest request = objectStore.getKey(key);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> request = db.transaction(<span class="string">"user"</span>)</span><br><span class="line">    .objectStore(<span class="string">"user"</span>)</span><br><span class="line">    .get(<span class="string">"mushan"</span>);</span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(request.result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为传入的event对象的target属性会被设置为对应的request，所以还可以进一步简化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.transaction(<span class="string">"user"</span>)</span><br><span class="line">    .objectStore(<span class="string">"user"</span>)</span><br><span class="line">    .get(<span class="string">"mushan"</span>);</span><br><span class="line">    .onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(request.result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Key-Range"><a href="#Key-Range" class="headerlink" title="Key Range"></a>Key Range</h2><p>IndexedDB除了对一个特定值进行查找，可以针对一个范围进行查找，使用到IDBKeyRange：</p><table><thead><tr><th>Range</th><th>Code</th></tr></thead><tbody><tr><td>All keys ≤ x</td><td>IDBKeyRange.upperBound(x)</td></tr><tr><td>All keys &lt; x</td><td>IDBKeyRange.upperBound(x, true)</td></tr><tr><td>All keys ≥ y</td><td>IDBKeyRange.lowerBound(y)</td></tr><tr><td>All keys &gt; y</td><td>IDBKeyRange.lowerBound(y, true)</td></tr><tr><td>All keys ≥ x &amp;&amp; ≤ y</td><td>IDBKeyRange.bound(x, y)</td></tr><tr><td>All keys &gt; x &amp;&amp;&lt; y</td><td>IDBKeyRange.bound(x, y, true, true)</td></tr><tr><td>All keys &gt; x &amp;&amp; ≤ y</td><td>IDBKeyRange.bound(x, y, true, false)</td></tr><tr><td>All keys ≥ x &amp;&amp;&lt; y</td><td>IDBKeyRange.bound(x, y, false, true)</td></tr><tr><td>The key = z</td><td>IDBKeyRange.only(z)</td></tr></tbody></table><h2 id="使用Cursor查询数据"><a href="#使用Cursor查询数据" class="headerlink" title="使用Cursor查询数据"></a>使用Cursor查询数据</h2><p>使用<code>get</code>方法只能获取到特定键对应的数据，如果要查询一个区间内的所有键对应的值，则需要使用Cursor对象来遍历。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IDBRequest request = ObjectStore.openCursor();</span><br><span class="line">IDBRequest request = ObjectStore.openCursor(query);</span><br><span class="line">IDBRequest request = ObjectStore.openCursor(query, direction);</span><br><span class="line"></span><br><span class="line">IDBRequest request = objectStore.openKeyCursor();</span><br><span class="line">IDBRequest request = objectStore.openKeyCursor(query);</span><br><span class="line">IDBRequest request = objectStore.openKeyCursor(query, direction);</span><br></pre></td></tr></table></figure><p><code>query</code>可以是key或者key range。</p><p><code>direction</code>的取值有：”next”, “nextunique”, “prev”, “prevunique”。默认为 “next”，即正向遍历。”prev”为反向遍历。”nextunique”表示正向遍历，同时对于一个key有多个值的情况，只会获取第一个出现的值。”prevunique”同理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.transaction(objectStoreName).objectStore(objectStoreName).openCursor().onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cursor = e.target.result;</span><br><span class="line">    <span class="keyword">if</span> (cursor) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(cursor.key, cursor.value);</span><br><span class="line">        cursor.continue();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以用IndexedDB遍历数据还是非常麻烦的，把结果放入一个数组中可以这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> customers = [];</span><br><span class="line"></span><br><span class="line">objectStore.openCursor().onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cursor = event.target.result;</span><br><span class="line">  <span class="keyword">if</span> (cursor) &#123;</span><br><span class="line">    customers.push(cursor.value);</span><br><span class="line">    cursor.continue();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">"Got all customers: "</span> + customers);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="索引查询"><a href="#索引查询" class="headerlink" title="索引查询"></a>索引查询</h2><p>IndexedDB除了支持主键搜索还支持索引搜索，使用<code>objectStore.index(name)</code>获得<code>IDBIndex</code>对象，就可以在索引上进行查找搜索操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IDBIndex index = objectStore.index(name);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IDBIndex.count()</span><br><span class="line">IDBIndex.get()</span><br><span class="line">IDBIndex.getKey()</span><br><span class="line">IDBIndex.getAll()</span><br><span class="line">IDBIndex.getAllKeys()</span><br><span class="line">IDBIndex.openCursor()</span><br><span class="line">IDBIndex.openKeyCursor()</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API/Using_IndexedDB" target="_blank" rel="noopener">使用 IndexedDB - Web API 接口 | MDN</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Web Application，网页应用是大势所趋，网页如果要提供本地应用级别的体验，存储是不可缺少的功能。从最早的Cookie，到LocalStorage，到IndexedDB，前端存储方案从简单的键值对到现在的数据库，功能不断强大。&lt;/p&gt;
&lt;p&gt;IndexedDB是一种可以让你在用户的浏览器内持久化存储数据的方法。IndexedDB为生成Web Application提供了丰富的查询能力，使我们的应用在在线和离线时都可以正常工作。IndexedDB是一个功能完备的NoSQL数据库。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://mushanshitiancai.github.io/categories/JavaScript/"/>
    
    
      <category term="js" scheme="http://mushanshitiancai.github.io/tags/js/"/>
    
      <category term="javascript" scheme="http://mushanshitiancai.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>CURL笔记-基本使用</title>
    <link href="http://mushanshitiancai.github.io/2018/02/27/tools/curl%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://mushanshitiancai.github.io/2018/02/27/tools/curl笔记-基本使用/</id>
    <published>2018-02-27T03:52:12.000Z</published>
    <updated>2018-07-11T12:32:38.360Z</updated>
    
    <content type="html"><![CDATA[<p>CURL命令行使用笔记。</p><a id="more"></a><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>网址需要用引号扩起来，否则其中的一些字符串（比如<code>&amp;</code>）会被Bash解析掉</li></ol><h2 id="设置请求方法"><a href="#设置请求方法" class="headerlink" title="设置请求方法"></a>设置请求方法</h2><ul><li>默认是GET方法</li><li>设置为HEAD方法 <code>-I, --head</code></li><li>设置为特定方法 <code>-X, --request &lt;command&gt;</code></li></ul><h2 id="设置Header"><a href="#设置Header" class="headerlink" title="设置Header"></a>设置Header</h2><ul><li>设置头部 <code>-H, --header &lt;header&gt;</code> </li><li>设置<code>User-Agent</code>头部 <code>-A, --user-agent &lt;agent string&gt;</code> </li><li>设置<code>Cookie</code>头部 <code>-b, --cookie &lt;name=data&gt;</code> </li><li>设置<code>Referer</code>头部 <code>-e, --referer &lt;URL&gt;</code> </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -H &apos;Host: 111.111.11.11&apos;-H &apos;Accept-Language: es&apos; http://test.com</span><br></pre></td></tr></table></figure><p>curl会默认携带一些Header，比如<code>Content-Type</code>，<code>User-Agent</code>，<code>Accept</code>，如果不想要这些头部，可以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 不要携带Content-Type头部</span><br><span class="line">$ curl -H &apos;Content-Type:&apos; http://test.com</span><br></pre></td></tr></table></figure><h2 id="设置请求体"><a href="#设置请求体" class="headerlink" title="设置请求体"></a>设置请求体</h2><ul><li><code>-d, --data &lt;data&gt;</code> 设置请求体。</li><li><code>--data-ascii &lt;data&gt;</code> <code>-d, --data</code>的别名</li><li><code>--data-binary &lt;data&gt;</code> 与与<code>-d, --data</code>类似，如果以<code>@</code>开头，则后面必须跟着文件名，并且文件中的换行符，回车符会保留，也不会做其他的转换</li><li><code>--data-raw &lt;data&gt;</code> 与<code>-d, --data</code>类似，只是不会处理参数中的<code>@</code>符号</li><li><code>--data-urlencode &lt;data&gt;</code></li></ul><p>需要注意，<code>--data</code>系列参数会把请求的<code>Content-Type</code>设置为<code>application/x-www-form-urlencoded</code>。</p><ul><li><code>-F, --form &lt;name=content&gt;</code> 设置表单内容，可以让curl发送和网页中表单一样的请求体，可以用来上传文件，<br><code>Content-Type</code>头部会被设置为<code>multipart/form-data</code>。</li></ul><p>需要注意，<code>--data</code>系列参数和<code>-F</code>参数都会让请求方法变为POST。</p><p>设置请求体是curl中比较复杂的操作，这里做了几个实验：</p><p><code>test.txt</code>的内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">123</span><br><span class="line">456</span><br></pre></td></tr></table></figure><p><code>@</code>开头加文件名会让curl使用文件内容。<code>--data</code>默认会去掉回车和换行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ curl --data &quot;@test.txt&quot; &apos;http://localhost:8080/upload&apos;</span><br><span class="line"></span><br><span class="line">POST /upload HTTP/1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">User-Agent: curl/7.54.0</span><br><span class="line">Accept: */*</span><br><span class="line">Content-Length: 6</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">123456</span><br></pre></td></tr></table></figure><p><code>--data-binary</code>不会去掉文件中的回车和换行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ curl --data-binary &quot;@test.txt&quot; &apos;http://localhost:8080/upload&apos;</span><br><span class="line"></span><br><span class="line">POST /upload HTTP/1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">User-Agent: curl/7.54.0</span><br><span class="line">Accept: */*</span><br><span class="line">Content-Length: 8</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">123</span><br><span class="line">456</span><br></pre></td></tr></table></figure><p><code>--data-raw</code>则不会去解析<code>@</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ curl --data-raw &quot;@test.txt&quot; &apos;http://localhost:8080/upload&apos;</span><br><span class="line"></span><br><span class="line">POST /upload HTTP/1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">User-Agent: curl/7.54.0</span><br><span class="line">Accept: */*</span><br><span class="line">Content-Length: 9</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">@test.txt</span><br></pre></td></tr></table></figure><p><code>--data</code>不会对参数进行url编码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ curl --data &quot;你&quot; &apos;http://localhost:8080/upload&apos;</span><br><span class="line"></span><br><span class="line">POST /upload HTTP/1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">User-Agent: curl/7.54.0</span><br><span class="line">Accept: */*</span><br><span class="line">Content-Length: 2</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">..</span><br></pre></td></tr></table></figure><p>这里的<code>..</code>其实是<code>你</code>这个字的原始编码：</p><p><img src="/img/tools/curl-not-urlencode-body.png" alt=""></p><p><code>--data-urlencode</code>会对参数进行url编码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ curl --data-urlencode &quot;你&quot; &apos;http://localhost:8080/upload&apos;</span><br><span class="line"></span><br><span class="line">POST /upload HTTP/1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">User-Agent: curl/7.54.0</span><br><span class="line">Accept: */*</span><br><span class="line">Content-Length: 6</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">%C4%E3</span><br></pre></td></tr></table></figure><p>一个常见的需求，我们怎么用curl发送JSON请求呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -H &quot;Content-Type: application/json&quot; -X POST -d &apos;&#123;&quot;username&quot;:&quot;xyz&quot;,&quot;password&quot;:&quot;xyz&quot;&#125;&apos; http://localhost:3000/api/login</span><br></pre></td></tr></table></figure><h2 id="控制输出"><a href="#控制输出" class="headerlink" title="控制输出"></a>控制输出</h2><ul><li>在输出中包含Header信息 <code>-i, --include</code>（和<code>-I</code>要区分开，后者是发起HEAD请求）</li><li>只输出Header信息<br>  Linux：<code>curl -s -D - www.test.org -o /dev/null</code><br>  Windows：<code>curl -s -D - www.test.org -o $null</code><br>  另外一种做法：<code>curl -I -X GET www.test.org</code></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>调试模式，输出详细信息 <code>-v, --verbose</code></li><li>自动跳转（跟踪302） <code>-L, --location</code></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.linuxidc.com/Linux/2015-02/114220.htm" target="_blank" rel="noopener">Linux系统入门学习：在curl中设置自定义的HTTP头_Linux教程_Linux公社-Linux系统门户网站</a></li><li><a href="https://curl.haxx.se/docs/manpage.html" target="_blank" rel="noopener">curl - How To Use</a></li><li><a href="https://stackoverflow.com/questions/7172784/how-to-post-json-data-with-curl-from-terminal-commandline-to-test-spring-rest" target="_blank" rel="noopener">How to POST JSON data with Curl from Terminal/Commandline to Test Spring REST? - Stack Overflow</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CURL命令行使用笔记。&lt;/p&gt;
    
    </summary>
    
    
      <category term="curl" scheme="http://mushanshitiancai.github.io/tags/curl/"/>
    
  </entry>
  
</feed>
