<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="这是木杉的个人博客"><title>Tomcat笔记-上传的请求体Tomcat是否会全部消费掉？ | 木杉的博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?ec7ecb4616a008addeb60c9709230453";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Tomcat笔记-上传的请求体Tomcat是否会全部消费掉？</h1><a id="logo" href="/.">木杉的博客</a><p class="description">要么精通，要么死</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Tomcat笔记-上传的请求体Tomcat是否会全部消费掉？</h1><div class="post-meta">Feb 13, 2018<span> | </span><span class="category"><a href="/categories/Tomcat/">Tomcat</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a data-disqus-identifier="2018/02/13/java/language/tomcat/Tomcat笔记-上传的请求体Tomcat是否会全部消费掉？/" href="/2018/02/13/java/language/tomcat/Tomcat笔记-上传的请求体Tomcat是否会全部消费掉？/#disqus_thread" class="disqus-comment-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP层面"><span class="toc-number">1.</span> <span class="toc-text">TCP层面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tomcat层面"><span class="toc-number">2.</span> <span class="toc-text">Tomcat层面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#抓包分析"><span class="toc-number">2.1.</span> <span class="toc-text">抓包分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#源码分析"><span class="toc-number">2.2.</span> <span class="toc-text">源码分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">4.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="post-content"><p>同事提了这样一个问题：上传一个100M文件，但是请求逻辑并没有消费这个文件，那这个文件会上传到服务器上么？</p>
<a id="more"></a>
<p>第一个反应是不会，因为这种情况下这个文件还上传上来的话，是很笨的做法，明明不需要这个请求体的数据，为什么还要读取到服务器上。不过同事的实验结果是，越大的文件调用这个没有任何处理逻辑的接口，速度越慢，也就是说因为服务器接收了完整的文件，所以才会有这个现象。</p>
<p>而另外一个同事在实验时，发现了更诡异的问题，上传0-2M的文件可以成功，但是上传大于2M的文件，会提示错误，信息为连接中断了。</p>
<h2 id="TCP层面"><a href="#TCP层面" class="headerlink" title="TCP层面"></a>TCP层面</h2><p>首先这个问题从底层来看的话，有一个前置问题，即客户端向服务端发送请求时，服务端会一直接收报文到缓冲区中吗？会导致占满服务端资源而无法响应码？会导致占满缓冲区后丢失后续报文的数据吗？</p>
<p>然后TCP有一个流量控制机制，用于控制发送端发送数据的速率，以便接收端来得及接收。这个逻辑大致是：</p>
<p>TCP在ACK报文中会携带窗口大小，说明接收端缓存的的剩余空间大小，发送端发送的数据不会大于这个窗口大小，所以如果接收方来不及消费数据，则接下来的ACK报文中窗口大小会逐渐减小，以限制发送端发送速率。如果接收端缓冲区满了，ACK报文中的窗口大小为0，则发送方不会再发送数据。那发送端怎么知道何时该继续发送呢？方法是启动一个计时器，计时器时间到后发送一个1字节的零窗口检测报文，直到返回的窗口不再为零然后继续发送数据。</p>
<p>所以回到用户通过HTTP协议上传大文件的问题，在TCP这一层，缓冲区会满了后，客户端就不会继续发送了，直到服务端程序读取了数据后，才会继续发送。</p>
<h2 id="Tomcat层面"><a href="#Tomcat层面" class="headerlink" title="Tomcat层面"></a>Tomcat层面</h2><p>TCP层面，通过流量控制，用户发送的文件不会无限制的发送到服务器上。那在Tomcat层面，Tomcat会把请求体完全读取到内存中吗？</p>
<p>这个分两个阶段考虑，一个是在Servlet逻辑执行前，Tomcat是否会把请求读取到内存中，一个是业务逻辑执行后，Tomcat是否还会继续消费掉业务逻辑没有消费的请求体？</p>
<h3 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h3><p>先抓包分析看看网络流量是如何传输的，可以大致看出来服务端是否消费了客户端的请求体。写一个简单的上传程序：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Upload&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=<span class="string">"/upload"</span> method=<span class="string">"post"</span> enctype=<span class="string">"multipart/form-data"</span>&gt;</span><br><span class="line">    &lt;label for="file"&gt;请选择文件: &lt;/label&gt;&lt;input id="file" type="file" name="file"&gt;</span><br><span class="line">    &lt;input type=<span class="string">"submit"</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"UploadServlet begin service"</span>);</span><br><span class="line">        System.out.println(<span class="string">"UploadServlet finish service"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后运行Wireshark进行抓包，这里需要注意，Windows下Wireshark默认无法抓取本机发给本机的请求，解决方法见<a href="http://mushanshitiancai.github.io/2018/02/13/tools/Wireshark%E7%AC%94%E8%AE%B0-%E6%8A%93%E5%8F%96%E6%9C%AC%E6%9C%BA%E5%8F%91%E7%BB%99%E6%9C%AC%E6%9C%BA%E7%9A%84%E8%AF%B7%E6%B1%82/">Wireshark笔记-抓取本机发给本机的请求</a>。</p>
<p>断点先设置在UploadServlet#doPost上，看下业务逻辑请求之前，网络请求是如何的：</p>
<p><img src="/img/tomcat/wireshark-before-servlet-1.png" alt=""></p>
<p><img src="/img/tomcat/wireshark-before-servlet-2.png" alt=""></p>
<p>可以看出客户端会一直发送TCP报文，直到服务端的缓冲区满。然后客户端启动定时器判断是否可以继续发送剩下的数据。从上面的数据，还无法推论出Tomcat在让Servlet执行请求前是否读取了数据。</p>
<p>接着继续运行程序，看下Servlet逻辑执行后，会有什么网络请求：</p>
<p><img src="/img/tomcat/wireshark-after-servlet-1.png" alt=""></p>
<p><img src="/img/tomcat/wireshark-after-servlet-2.png" alt=""></p>
<p><img src="/img/tomcat/wireshark-after-servlet-3.png" alt=""></p>
<p>可以看到在Servlet逻辑执行完毕后，服务端依然读取了全部的请求报文，然后才关闭连接的。为什么会有这种行为？Servlet执行完毕后，请求报文应该是没有意义了，再去读取，耗时耗力。还是得从源码层面来分析看看Tomcat在Servlet执行前后的具体行为。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>调试Tomcat的源码的方法可以参考：<a href="http://mushanshitiancai.github.io/2018/02/13/java/tomcat/Tomcat%E7%AC%94%E8%AE%B0-IDE%E4%B8%AD%E8%B0%83%E8%AF%95Tomcat%E6%BA%90%E7%A0%81/">Tomcat笔记-IDE中调试Tomcat源码</a>，我这里使用的Tomcat版本是<code>7.0.84</code>。</p>
<p><code>org.apache.coyote.http11.AbstractHttp11Processor#process</code>这个函数是Tomcat处理请求的一个主循环：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SocketState <span class="title">process</span><span class="params">(SocketWrapper&lt;S&gt; socketWrapper)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!getErrorState().isError() &amp;&amp; keepAlive &amp;&amp; !comet &amp;&amp; !isAsync() &amp;&amp;</span><br><span class="line">            upgradeInbound == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            httpUpgradeHandler == <span class="keyword">null</span> &amp;&amp; !endpoint.isPaused()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析HTTP头部</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            setRequestLineReadTimeout();</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让Adapter处理请求，也就是让Servlet处理请求</span></span><br><span class="line">        <span class="keyword">if</span> (!getErrorState().isError()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);</span><br><span class="line">                adapter.service(request, response);</span><br><span class="line">                </span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">               ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isAsync() &amp;&amp; !comet) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 结束请求</span></span><br><span class="line">            endRequest();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出Tomcat处理请求的主流程是：</p>
<ol>
<li>解析HTTP头部</li>
<li>执行Servlet逻辑</li>
<li>结束请求</li>
</ol>
<p>结合抓包分析发现，在<code>setRequestLineReadTimeout()</code>和<code>endRequest()</code>这两个地方，服务端读取了TCP报文，接下来重点分析下此两处为何需要读取数据</p>
<p><code>org.apache.coyote.http11.Http11Processor#setRequestLineReadTimeout</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setRequestLineReadTimeout</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (inputBuffer.lastValid == <span class="number">0</span> &amp;&amp; socketWrapper.getLastAccess() &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从socket读取数据到inputBuffer中</span></span><br><span class="line">        <span class="keyword">if</span> (!inputBuffer.fill()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EOFException(sm.getString(<span class="string">"iib.eof.error"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>org.apache.coyote.http11.InternalInputBuffer#fill(boolean)</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">fill</span><span class="params">(<span class="keyword">boolean</span> block)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nRead = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parsingHeader) &#123;</span><br><span class="line">        <span class="comment">// 如果已经读取的数据大小等于buf大小（并且外部逻辑还在尝试读取）</span></span><br><span class="line">        <span class="comment">// 说明请求的头部太大了，无法处理抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (lastValid == buf.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException</span><br><span class="line">                (sm.getString(<span class="string">"iib.requestheadertoolarge.error"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从socket的inputStream读取数据到buf中，读取的长度为buf.length - lastValid</span></span><br><span class="line">        <span class="comment">// lastValid为buf中已经读取数据偏移量，对于第一次读取头部时，为0</span></span><br><span class="line">        nRead = inputStream.read(buf, pos, buf.length - lastValid);</span><br><span class="line">        <span class="keyword">if</span> (nRead &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            lastValid = pos + nRead;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (nRead &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从<code>fill()</code>的代码可以看出，请求到达Tomcat后，Tomcat为了处理HTTP的Header信息，会读取数据到buffer数组中，而所能处理的Header的最大长度，也就是这个数据的大小。我们可以跟一下看看这个数组是如何初始化的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InternalInputBuffer</span><span class="params">(Request request, <span class="keyword">int</span> headerBufferSize,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> rejectIllegalHeaderName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.request = request;</span><br><span class="line">    headers = request.getMimeHeaders();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置数组的容量为headerBufferSize</span></span><br><span class="line">    buf = <span class="keyword">new</span> <span class="keyword">byte</span>[headerBufferSize];</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认值为8k</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxHttpHeaderSize = <span class="number">8</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxHttpHeaderSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> maxHttpHeaderSize; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxHttpHeaderSize</span><span class="params">(<span class="keyword">int</span> valueI)</span> </span>&#123; maxHttpHeaderSize = valueI; &#125;</span><br></pre></td></tr></table></figure>
<p>最终可以看到在<code>org.apache.coyote.http11.AbstractHttp11Protocol</code>这个类中定义了maxHttpHeaderSize这个变量，默认值为8K，也就是说Tomcat默认支持的最长Header为8K，再大就会报错了。</p>
<p>同时我们可以从Tomcat的<a href="https://tomcat.apache.org/tomcat-7.0-doc/config/http.html" target="_blank" rel="noopener">配置文档</a>上看到这个配置项：</p>
<p><img src="/img/tomcat/max-http-header-size.png" alt=""></p>
<p>上面分析了Tomcat在预处理请求时，会解析HTTP头部，所以这个时候会读取一次请求，最大会读取8K。那为啥在结束请求时，Tomcat还会去读取请求体呢？分析一下结束请求的流程：</p>
<p><code>org.apache.coyote.http11.AbstractHttp11Processor#endRequest</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结束请求</span></span><br><span class="line">    <span class="keyword">if</span> (getErrorState().isIoAllowed()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            getInputBuffer().endRequest();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getErrorState().isIoAllowed()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            getOutputBuffer().endRequest();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>org.apache.coyote.http11.AbstractInputBuffer#endRequest</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * End request (consumes leftover bytes).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (swallowInput &amp;&amp; (lastActiveFilter != -<span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">int</span> extraBytes = (<span class="keyword">int</span>) activeFilters[lastActiveFilter].end();</span><br><span class="line">        pos = pos - extraBytes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>org.apache.coyote.http11.filters.IdentityInputFilter#end</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">end</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> maxSwallowSizeExceeded = (maxSwallowSize &gt; -<span class="number">1</span> &amp;&amp; remaining &gt; maxSwallowSize);</span><br><span class="line">    <span class="keyword">long</span> swallowed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求体剩余的没有读取的大小大于零，则Tomcat吃掉它</span></span><br><span class="line">    <span class="keyword">while</span> (remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nread = buffer.doRead(endChunk, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (nread &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">            swallowed += nread;</span><br><span class="line">            remaining = remaining - nread;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果读取了太多了字节，则抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (maxSwallowSizeExceeded &amp;&amp; swallowed &gt; maxSwallowSize) &#123;</span><br><span class="line">                <span class="comment">// Note: We do not fail early so the client has a chance to</span></span><br><span class="line">                <span class="comment">// read the response before the connection is closed. See:</span></span><br><span class="line">                <span class="comment">// http://httpd.apache.org/docs/2.0/misc/fin_wait_2.html#appendix</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(sm.getString(<span class="string">"inputFilter.maxSwallow"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// errors are handled higher up.</span></span><br><span class="line">            remaining = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If too many bytes were read, return the amount.</span></span><br><span class="line">    <span class="keyword">return</span> -remaining;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看出，Tomcat在结束请求时，有一种Swallow机制，也就是把客户端发上来的，Servlet业务逻辑没有消费的请求体继续消费掉，或者称为吞掉。</p>
<p>可以从字节级别上验证：客户端上传的请求体大小为Content-Length表示的1048756字节：</p>
<p><img src="/img/tomcat/remaining-1.png" alt=""></p>
<p>当我的Servlet没有任何读取request.inputStream的操作时，Tomcat结束请求的remaining的大小等于1048756，也就是完整的请求体大小：</p>
<p><img src="/img/tomcat/remaining-2.png" alt=""></p>
<p>当我的Servlet程序读取全部的输入流时，Tomcat的结束请求流程中remaining=0，所以也就不会去执行swallow的流程了：</p>
<p><img src="/img/tomcat/remaining-3.png" alt=""></p>
<p>同时通过代码看出，Tomcat也不是客户端发多少它就吞多少，而是有一个变量<code>maxSwallowSize</code>控制，如果Tomcat吞的字节大于这个变量，则会抛出IOException。</p>
<p>这个<code>maxSwallowSize</code>的初始值也定义在<code>org.apache.coyote.http11.AbstractHttp11Protocol</code>中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认值是2M</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxSwallowSize = <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxSwallowSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> maxSwallowSize; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxSwallowSize</span><span class="params">(<span class="keyword">int</span> maxSwallowSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.maxSwallowSize = maxSwallowSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>maxSwallowSize</code>的默认值是2M，所以如果请求体大于2M，Tomcat不会继续消费，而是抛出异常并关闭连接。Tomcat官网上关于这个配置项的描述：</p>
<p><img src="/img/tomcat/max-swallow-size.png" alt=""></p>
<p>看到这个配置还是非常激动的，因为这个和实验时发现上传2M文件会失败的同事的现象吻合了。我试着上传大于2M的文件，的确浏览器提示连接被中断：</p>
<p><img src="/img/tomcat/chrome-err-connection-aborted.png" alt=""></p>
<p>当然，这种情况会发生是因为业务逻辑没有消费掉这个上传的文件，如果业务逻辑正常消费掉这个文件，是不会发生这种异常的。</p>
<p>知道了Tomcat的这个逻辑，现在的问题是，为何Tomcat要去消费掉业务逻辑都不管的请求体呢？对于上传文件这种请求体很大的场景，这一步可能消费掉不少资源和时间。</p>
<p>目前的推论是：虽然TCP是全双工的，也就是在服务端没有读取客户端发来的消息时，也依然可以给客户端发送响应，但是如果没有接收完客户端发来的消息就关闭连接，客户端是会报错的（连接被中断），所以Tomcat为了保证客户端不报错所以尝试读取剩余的请求体，但是出于资源考虑，限制了最大读取的字节数默认为2M。对于大部分非文件上传请求，这个大小也足够了。</p>
<p>同时注意下上面贴出的代码中有这么一段注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Note: We do not fail early so the client has a chance to</span><br><span class="line">// read the response before the connection is closed. See:</span><br><span class="line">// http://httpd.apache.org/docs/2.0/misc/fin_wait_2.html#appendix</span><br></pre></td></tr></table></figure>
<p>主要是一段Roy Fielding的关于为什么HTTP需要拖延关闭（lingering）功能，Roy Fielding是HTTP/1.1的作者之一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Below is a message from Roy Fielding, one of the authors of HTTP/1.1.</span><br><span class="line"></span><br><span class="line">Why the lingering close functionality is necessary with HTTP</span><br><span class="line">The need for a server to linger on a socket after a close is noted a couple times in the HTTP specs, but not explained. This explanation is based on discussions between myself, Henrik Frystyk, Robert S. Thau, Dave Raggett, and John C. Mallery in the hallways of MIT while I was at W3C.</span><br><span class="line"></span><br><span class="line">If a server closes the input side of the connection while the client is sending data (or is planning to send data), then the server&apos;s TCP stack will signal an RST (reset) back to the client. Upon receipt of the RST, the client will flush its own incoming TCP buffer back to the un-ACKed packet indicated by the RST packet argument. If the server has sent a message, usually an error response, to the client just before the close, and the client receives the RST packet before its application code has read the error message from its incoming TCP buffer and before the server has received the ACK sent by the client upon receipt of that buffer, then the RST will flush the error message before the client application has a chance to see it. The result is that the client is left thinking that the connection failed for no apparent reason.</span><br><span class="line"></span><br><span class="line">There are two conditions under which this is likely to occur:</span><br><span class="line"></span><br><span class="line">sending POST or PUT data without proper authorization</span><br><span class="line">sending multiple requests before each response (pipelining) and one of the middle requests resulting in an error or other break-the-connection result.</span><br><span class="line">The solution in all cases is to send the response, close only the write half of the connection (what shutdown is supposed to do), and continue reading on the socket until it is either closed by the client (signifying it has finally read the response) or a timeout occurs. That is what the kernel is supposed to do if SO_LINGER is set. Unfortunately, SO_LINGER has no effect on some systems; on some other systems, it does not have its own timeout and thus the TCP memory segments just pile-up until the next reboot (planned or not).</span><br><span class="line"></span><br><span class="line">Please note that simply removing the linger code will not solve the problem -- it only moves it to a different and much harder one to detect.</span><br></pre></td></tr></table></figure>
<p>这段说明的大致意思是：</p>
<p>如果服务端要关闭一个正在发送或者正打算发送数据的客户端连接，TCP栈会发出一个RST（Reset）包给客户端，客户端一旦收到RST包，则会根据RST包中的信息重置其接收缓冲区的报文为un-ACKed。如果服务端发送了响应数据给客户端，但是在客户端代码读取这个响应信息前收到了RST报文，那么这个RST报文会在客户端代码读取这个响应信息前刷掉这个服务端发来的响应信息，导致客户端代码再也无法读取到这个响应。结果就是客户端认为连接不明不白的失败了。</p>
<p>解决方法就是服务端发送了响应后，只关闭连接的写部分（shutdown就是这个功能），然后继续读取客户端发来的数据，直到它也被客户端关闭了，或者是连接超时了。内核的SO_LINGER标志位就是这个效果，但是不幸的是不是所有系统都有效。</p>
<p>RST包的说明可以参考：<a href="http://blog.csdn.net/eric0318/article/details/51113018" target="_blank" rel="noopener">简单说说TCP(5) — RST</a>，这篇文章提到的出现RST包的场景，就包含上面描述的场景：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4. 当recv buffer还有数据时应用程序关闭连接 </span><br><span class="line">A、B建立连接后，A发送5000字节的数据给B，但是B只读了4096字节，之后就调用closesocket()，此时，B会向A发送一个RST包。</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>TCP的流量控制可以保障发送方的报文不会淹没接收方，当接收方的接收窗口大小为0时，发送方就不会继续发送了</li>
<li>Tomcat在调用Servlet处理请求前，会处理HTTP请求中的头部信息，会读取数据，最多会读取<code>maxHttpHeaderSize</code>（默认8k）长度的内容</li>
<li>Tomcat在调用Servlet处理请求后，会判断是否有剩余的未消费的请求体数据，如果有则消费掉，最多消费<code>maxSwallowSize</code>（默认2M）长度的数据，如果用户发送的请求体大于<code>maxSwallowSize</code>，则强行关闭连接。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://blog.csdn.net/yechaodechuntian/article/details/25429143" target="_blank" rel="noopener">TCP的流量控制和拥塞控制 - CSDN博客</a></li>
<li><a href="https://www.zhihu.com/question/32255109" target="_blank" rel="noopener">TCP协议的滑动窗口具体是怎样控制流量的？ - 知乎</a></li>
<li><a href="http://blog.csdn.net/witsmakemen/article/details/27319951" target="_blank" rel="noopener">TCP的接收缓冲区满了，收到数据后会向发送方发送ACK吗？该怎么解决 - CSDN博客</a></li>
<li><a href="https://tomcat.apache.org/tomcat-7.0-doc/config/http.html" target="_blank" rel="noopener">Apache Tomcat 7 Configuration Reference (7.0.84) - The HTTP Connector</a></li>
</ul>
</div><div class="reward"><hr><div class="text">如果觉得文章对你有帮助，就打赏杯咖啡钱呗😊</div><img src="/img/reward/weixin.png"><img src="/img/reward/alipay.png"></div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://mushanshitiancai.github.io/2018/02/13/java/language/tomcat/Tomcat笔记-上传的请求体Tomcat是否会全部消费掉？/" data-id="cjkb9otaw00qmb3319dfabfyh" class="article-share-link">分享</a><div class="tags"><a href="/tags/java/">java</a><a href="/tags/tomcat/">tomcat</a></div><div class="post-nav"><a href="/2018/02/27/tools/curl笔记-基本使用/" class="pre">CURL笔记-基本使用</a><a href="/2018/02/13/java/language/tomcat/Tomcat笔记-IDE中调试Tomcat源码/" class="next">Tomcat笔记-IDE中调试Tomcat源码</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'mushan';
var disqus_identifier = '2018/02/13/java/language/tomcat/Tomcat笔记-上传的请求体Tomcat是否会全部消费掉？/';
var disqus_title = 'Tomcat笔记-上传的请求体Tomcat是否会全部消费掉？';
var disqus_url = 'http://mushanshitiancai.github.io/2018/02/13/java/language/tomcat/Tomcat笔记-上传的请求体Tomcat是否会全部消费掉？/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/favicon.ico',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//mushan.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://mushanshitiancai.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Groovy/">Groovy</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/JDK源码阅读/">JDK源码阅读</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/掌握Java/">掌握Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/调试/">调试</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/TypeScript/">TypeScript</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MongoDB/">MongoDB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/RabbitMQ/">RabbitMQ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tomcat/">Tomcat</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/electron/">electron</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/自动化/">自动化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/自己动手写操作系统/">自己动手写操作系统</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/php/" style="font-size: 15px;">php</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/log/" style="font-size: 15px;">log</a> <a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/angularjs/" style="font-size: 15px;">angularjs</a> <a href="/tags/db/" style="font-size: 15px;">db</a> <a href="/tags/mongodb/" style="font-size: 15px;">mongodb</a> <a href="/tags/react/" style="font-size: 15px;">react</a> <a href="/tags/mmnote/" style="font-size: 15px;">mmnote</a> <a href="/tags/architecture/" style="font-size: 15px;">architecture</a> <a href="/tags/protocol-buffers/" style="font-size: 15px;">protocol-buffers</a> <a href="/tags/mq/" style="font-size: 15px;">mq</a> <a href="/tags/blog/" style="font-size: 15px;">blog</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/tools/" style="font-size: 15px;">tools</a> <a href="/tags/emacs/" style="font-size: 15px;">emacs</a> <a href="/tags/管理后台/" style="font-size: 15px;">管理后台</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/os/" style="font-size: 15px;">os</a> <a href="/tags/shell/" style="font-size: 15px;">shell</a> <a href="/tags/vagrant/" style="font-size: 15px;">vagrant</a> <a href="/tags/tmux/" style="font-size: 15px;">tmux</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/automation/" style="font-size: 15px;">automation</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/work/" style="font-size: 15px;">work</a> <a href="/tags/bochs/" style="font-size: 15px;">bochs</a> <a href="/tags/project/" style="font-size: 15px;">project</a> <a href="/tags/test/" style="font-size: 15px;">test</a> <a href="/tags/software/" style="font-size: 15px;">software</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/ffmpeg/" style="font-size: 15px;">ffmpeg</a> <a href="/tags/gm/" style="font-size: 15px;">gm</a> <a href="/tags/graphicsmagick/" style="font-size: 15px;">graphicsmagick</a> <a href="/tags/wireshark/" style="font-size: 15px;">wireshark</a> <a href="/tags/curl/" style="font-size: 15px;">curl</a> <a href="/tags/vscode/" style="font-size: 15px;">vscode</a> <a href="/tags/javafx/" style="font-size: 15px;">javafx</a> <a href="/tags/jvm/" style="font-size: 15px;">jvm</a> <a href="/tags/guava/" style="font-size: 15px;">guava</a> <a href="/tags/junit/" style="font-size: 15px;">junit</a> <a href="/tags/groovy/" style="font-size: 15px;">groovy</a> <a href="/tags/idea/" style="font-size: 15px;">idea</a> <a href="/tags/tomcat/" style="font-size: 15px;">tomcat</a> <a href="/tags/maven/" style="font-size: 15px;">maven</a> <a href="/tags/doclet/" style="font-size: 15px;">doclet</a> <a href="/tags/log4j/" style="font-size: 15px;">log4j</a> <a href="/tags/dubbo/" style="font-size: 15px;">dubbo</a> <a href="/tags/servlet/" style="font-size: 15px;">servlet</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/electron/" style="font-size: 15px;">electron</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/jquery/" style="font-size: 15px;">jquery</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/typescript/" style="font-size: 15px;">typescript</a> <a href="/tags/webpack/" style="font-size: 15px;">webpack</a> <a href="/tags/ts/" style="font-size: 15px;">ts</a> <a href="/tags/gulp/" style="font-size: 15px;">gulp</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/java/language/JDK源码阅读-InterruptibleChannel与可中断IO/">JDK源码阅读-InterruptibleChannel与可中断IO</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/28/java/language/Java日志-Log4j实现运行时修改日志级别/">Java日志-Log4j实现运行时修改日志级别</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/28/java/language/Java日志-Log4j源码分析/">Java日志-Log4j源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/22/java/language/Java日志-SLF4J使用与源码分析/">Java日志-SLF4J使用与源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/11/os/自己动手写操作系统-计算机通电之后的操作/">自己动手写操作系统-计算机通电之后的操作</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/11/os/Bochs学习-安装配置篇/">Bochs学习-安装配置篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/18/java/language/Java如何保证文件落盘？/">Java如何保证文件落盘？</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/17/linux/Linux-UNIX编程如何保证文件落盘/">Linux/UNIX编程如何保证文件落盘</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/db/MongoDB遍历方式对比/">MongoDB遍历方式对比</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/java/language/JDK源码阅读-RandomAccessFile/">JDK源码阅读-RandomAccessFile</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//mushan.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://anotom.com/" title="鑫哥的博客" target="_blank">鑫哥的博客</a><ul></ul><a href="https://www.caylor.cc/" title="乐哥的博客" target="_blank">乐哥的博客</a><ul></ul><a href="http://zach41.github.io/" title="小美的博客" target="_blank">小美的博客</a><ul></ul><a href="http://blog.csdn.net/sinat_25127047" title="瀚文的博客" target="_blank">瀚文的博客</a><ul></ul><a href="http://blog.csdn.net/xiaohangblog?viewmode=contents)" title="小杭的博客" target="_blank">小杭的博客</a><ul></ul><a href="http://bettercuicui.github.io/" title="夏侯的博客" target="_blank">夏侯的博客</a><ul></ul><a href="http://damye.github.io/" title="符尧的博客" target="_blank">符尧的博客</a><ul></ul><a href="http://blog.shrp.me/" title="尚弟的博客" target="_blank">尚弟的博客</a><ul></ul><a href="http://imethan.cn" title="应锋的博客" target="_blank">应锋的博客</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">木杉的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>