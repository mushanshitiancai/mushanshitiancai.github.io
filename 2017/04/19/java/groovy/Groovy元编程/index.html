<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="这是木杉的个人博客"><title>Groovy元编程-运行时元编程 | 木杉的博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?ec7ecb4616a008addeb60c9709230453";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Groovy元编程-运行时元编程</h1><a id="logo" href="/.">木杉的博客</a><p class="description">要么精通，要么死</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Groovy元编程-运行时元编程</h1><div class="post-meta">Apr 19, 2017<span> | </span><span class="category"><a href="/categories/Java/">Java</a><a href="/categories/Java/Groovy/">Groovy</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a data-disqus-identifier="2017/04/19/java/groovy/Groovy元编程/" href="/2017/04/19/java/groovy/Groovy元编程/#disqus_thread" class="disqus-comment-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-运行时元编程"><span class="toc-number">1.</span> <span class="toc-text">1. 运行时元编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-GroovyObject接口"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 GroovyObject接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-invokeMethod"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1.1 invokeMethod</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-get-setProperty"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.1.2 get/setProperty</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3-get-setMetaClass"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.1.3 get/setMetaClass</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-get-setAttribute"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 get/setAttribute</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-methodMissing"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 methodMissing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-propertyMissing"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 propertyMissing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-GroovyInterceptable"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 GroovyInterceptable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-Categories"><span class="toc-number">1.6.</span> <span class="toc-text">1.6 Categories</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-Metaclasses"><span class="toc-number">1.7.</span> <span class="toc-text">1.7 Metaclasses</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-1-Custom-metaclasses"><span class="toc-number">1.7.1.</span> <span class="toc-text">1.7.1. Custom metaclasses</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-2-Per-instance-metaclass"><span class="toc-number">1.7.2.</span> <span class="toc-text">1.7.2. Per instance metaclass</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-3-ExpandoMetaClass"><span class="toc-number">1.7.3.</span> <span class="toc-text">1.7.3. ExpandoMetaClass</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Methods"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">Methods</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Properties"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">Properties</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Constructors"><span class="toc-number">1.7.3.3.</span> <span class="toc-text">Constructors</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Static-Methods"><span class="toc-number">1.7.3.4.</span> <span class="toc-text">Static Methods</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Borrowing-Methods-方法借用"><span class="toc-number">1.7.3.5.</span> <span class="toc-text">Borrowing Methods 方法借用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Dynamic-Method-Names-动态方法名"><span class="toc-number">1.7.3.6.</span> <span class="toc-text">Dynamic Method Names 动态方法名</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Runtime-Discovery-动态发现"><span class="toc-number">1.7.3.7.</span> <span class="toc-text">Runtime Discovery 动态发现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#GroovyObject-Methods"><span class="toc-number">1.7.3.8.</span> <span class="toc-text">GroovyObject Methods</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Overriding-Static-invokeMethod-覆盖静态invokeMethod"><span class="toc-number">1.7.3.9.</span> <span class="toc-text">Overriding Static invokeMethod 覆盖静态invokeMethod</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Extending-Interfaces-扩展接口"><span class="toc-number">1.7.3.10.</span> <span class="toc-text">Extending Interfaces 扩展接口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-Extension-modules-扩展模块"><span class="toc-number">1.8.</span> <span class="toc-text">1.8 Extension modules 扩展模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8-1-Extending-existing-classes-扩展现有的类"><span class="toc-number">1.8.1.</span> <span class="toc-text">1.8.1 Extending existing classes 扩展现有的类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8-4-Module-descriptor-模块描述文件"><span class="toc-number">1.8.2.</span> <span class="toc-text">1.8.4 Module descriptor 模块描述文件</span></a></li></ol></li></ol></li></ol></div></div><div class="post-content"><p>原文地址：<a href="http://www.groovy-lang.org/metaprogramming.html" target="_blank" rel="noopener">Groovy - Runtime and compile-time metaprogramming</a></p>
<h2 id="1-运行时元编程"><a href="#1-运行时元编程" class="headerlink" title="1. 运行时元编程"></a>1. 运行时元编程</h2><p>有了运行时元编程，我们可以推迟到运行的时候再决定如何拦截，注入，设置是装配类和接口的方法。要想深入理解Groovy MOP，我们需要理解Groovy对象和Groovy的方法处理机制。在Groovy，我们使用三种类型的对象：POJO，POGO和Groovy Interceptors。Groovy支持在这三种对象上用不同的方式进行元编程。</p>
<ul>
<li>POJO - 传统Java对象，可以是用Java或者是任何其他JVM上的语言编写的</li>
<li>POGO - Groovy对象，使用Groovy编写。它继承自<code>java.lang.Object</code>并且默认实现了<code>groovy.lang.GroovyObject</code></li>
<li>Groovy Interceptor - 一个Groovy对象，实现了<code>groovy.lang.GroovyInterceptable</code>接口，拥有方法拦截的能力</li>
</ul>
<p>对于每一个方法调用，Groovy都检查所在方法是POJO还是POGO。如果是POJO，Groovy从<code>groovy.lang.MetaClassRegistry</code>获取它的<code>MetaClass</code>，然后把方法的调用代理到这个MetaClass实例。如果是POGO，Groovy会执行更复杂的判断流程，如下图：</p>
<p><img src="http://docs.groovy-lang.org/latest/html/documentation/assets/img/GroovyInterceptions.png" alt=""></p>
<h3 id="1-1-GroovyObject接口"><a href="#1-1-GroovyObject接口" class="headerlink" title="1.1 GroovyObject接口"></a>1.1 GroovyObject接口</h3><p><code>groovy.lang.GroovyObject</code>是Groovy中最主要的接口，其地位就行Object在Java中的地位。<code>groovy.lang.GroovyObjectSupport</code>实现了GroovyObject接口的方法，主要内容是把对应的方法调用转发到<code>groovy.lang.MetaClass</code>对象上。<code>GroovyObject</code>源码如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> groovy.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GroovyObject</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    Object invokeMethod(String name, Object args);</span><br><span class="line"></span><br><span class="line">    Object getProperty(String propertyName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> setProperty(String propertyName, Object newValue);</span><br><span class="line"></span><br><span class="line">    MetaClass getMetaClass();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> setMetaClass(MetaClass metaClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-1-1-invokeMethod"><a href="#1-1-1-invokeMethod" class="headerlink" title="1.1.1 invokeMethod"></a>1.1.1 invokeMethod</h4><p>根据上面的流程图，这个方法会在调用的方法在对象中不存在时触发，下面是一个例子：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeGroovyClass</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> invokeMethod(String name, Object args) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"called invokeMethod $name $args"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> test() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'method exists'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> someGroovyClass = <span class="keyword">new</span> SomeGroovyClass()</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> someGroovyClass.test() == <span class="string">'method exists'</span></span><br><span class="line"><span class="keyword">assert</span> someGroovyClass.someMethod() == <span class="string">'called invokeMethod someMethod []'</span></span><br></pre></td></tr></table></figure>
<h4 id="1-1-2-get-setProperty"><a href="#1-1-2-get-setProperty" class="headerlink" title="1.1.2 get/setProperty"></a>1.1.2 get/setProperty</h4><p>对于属性的每次读取操作，都会被当前对象的<code>getProperty()</code>方法拦截。下面是一个例子：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeGroovyClass</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> property1 = <span class="string">'ha'</span></span><br><span class="line">    <span class="keyword">def</span> field2 = <span class="string">'ho'</span></span><br><span class="line">    <span class="keyword">def</span> field4 = <span class="string">'hu'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> getField1() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'getHa'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> getProperty(String name) &#123;</span><br><span class="line">        <span class="keyword">if</span> (name != <span class="string">'field3'</span>)</span><br><span class="line">            <span class="keyword">return</span> metaClass.getProperty(<span class="keyword">this</span>, name) </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">'field3'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> someGroovyClass = <span class="keyword">new</span> SomeGroovyClass()</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> someGroovyClass.field1 == <span class="string">'getHa'</span></span><br><span class="line"><span class="keyword">assert</span> someGroovyClass.field2 == <span class="string">'ho'</span></span><br><span class="line"><span class="keyword">assert</span> someGroovyClass.field3 == <span class="string">'field3'</span></span><br><span class="line"><span class="keyword">assert</span> someGroovyClass.field4 == <span class="string">'hu'</span></span><br></pre></td></tr></table></figure>
<p>对应的，对于属性的写操作都会被<code>setProperty()</code>方法拦截：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">POGO</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    String property</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> setProperty(String name, Object value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.@<span class="string">"$name"</span> = <span class="string">'overridden'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> pogo = <span class="keyword">new</span> POGO()</span><br><span class="line">pogo.property = <span class="string">'a'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> pogo.property == <span class="string">'overridden'</span></span><br></pre></td></tr></table></figure>
<h4 id="1-1-3-get-setMetaClass"><a href="#1-1-3-get-setMetaClass" class="headerlink" title="1.1.3 get/setMetaClass"></a>1.1.3 get/setMetaClass</h4><p>你可以获取一个对象的<code>metaClass</code>或者是设置为你自己实现的<code>MetaClass</code>来覆盖默认的方法拦截机制:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getMetaclass</span></span><br><span class="line">someObject.metaClass</span><br><span class="line"></span><br><span class="line"><span class="comment">// setMetaClass</span></span><br><span class="line">someObject.metaClass = <span class="keyword">new</span> OwnMetaClassImplementation()</span><br></pre></td></tr></table></figure>
<h3 id="1-2-get-setAttribute"><a href="#1-2-get-setAttribute" class="headerlink" title="1.2 get/setAttribute"></a>1.2 get/setAttribute</h3><p>这是<code>MetaClass</code>实现上的方法。默认的实现是你可以直接访问属性，而不会触发getter/setter：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeGroovyClass</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> field1 = <span class="string">'ha'</span></span><br><span class="line">    <span class="keyword">def</span> field2 = <span class="string">'ho'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> getField1() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'getHa'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> someGroovyClass = <span class="keyword">new</span> SomeGroovyClass()</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> someGroovyClass.metaClass.getAttribute(someGroovyClass, <span class="string">'field1'</span>) == <span class="string">'ha'</span></span><br><span class="line"><span class="keyword">assert</span> someGroovyClass.metaClass.getAttribute(someGroovyClass, <span class="string">'field2'</span>) == <span class="string">'ho'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">POGO</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String field</span><br><span class="line">    String property1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> setProperty1(String property1) &#123;</span><br><span class="line">        <span class="keyword">this</span>.property1 = <span class="string">"setProperty1"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> pogo = <span class="keyword">new</span> POGO()</span><br><span class="line">pogo.metaClass.setAttribute(pogo, <span class="string">'field'</span>, <span class="string">'ha'</span>)</span><br><span class="line">pogo.metaClass.setAttribute(pogo, <span class="string">'property1'</span>, <span class="string">'ho'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> pogo.field == <span class="string">'ha'</span></span><br><span class="line"><span class="keyword">assert</span> pogo.property1 == <span class="string">'ho'</span></span><br></pre></td></tr></table></figure>
<h3 id="1-3-methodMissing"><a href="#1-3-methodMissing" class="headerlink" title="1.3 methodMissing"></a>1.3 methodMissing</h3><p>Groovy支持<code>methodMissing</code>的概念。和<code>invokeMethod</code>的区别是<code>methodMissing</code>只会在方法不存在时调用（更详细的解释见<a href="http://blog.csdn.net/hivon/article/details/3019631" target="_blank" rel="noopener">Groovy探索之MOP 一 invokeMethod和methodMissing方法</a>）</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> methodMissing(String name, <span class="keyword">def</span> args) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"this is me"</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">new</span> Foo().someUnknownMethod(<span class="number">42</span>l) == <span class="string">'this is me'</span></span><br></pre></td></tr></table></figure>
<p>使用<code>methodMissing</code>的典型场景是用于缓存函数调用的结果。</p>
<p>举个GORM中dynamic finders的例子，这个特性就是使用<code>methodMissing</code>实现的。代码大致是这样：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GORM</span> &#123;</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> dynamicMethods = [...] <span class="comment">// an array of dynamic methods that use regex</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> methodMissing(String name, args) &#123;</span><br><span class="line">       <span class="keyword">def</span> method = dynamicMethods.find &#123; it.match(name) &#125;</span><br><span class="line">       <span class="keyword">if</span>(method) &#123;</span><br><span class="line">          GORM.metaClass.<span class="string">"$name"</span> = &#123; Object[] varArgs -&gt;</span><br><span class="line">             method.invoke(delegate, name, varArgs)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> method.invoke(delegate,name, args)</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> MissingMethodException(name, delegate, args)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看是如何实现的，如果我们找到符合的方法进行调用，我们使用<code>ExpandoMetaClass</code>动态地注册这个新方法。这样，下次调用同一个方法时，就会直接调用这个方法，避免了再次搜索，提高了效率。这种使用<code>methodMissing</code>的方法，不需要覆盖<code>invokeMethod</code>，并且后续调用会快很多。</p>
<h3 id="1-4-propertyMissing"><a href="#1-4-propertyMissing" class="headerlink" title="1.4 propertyMissing"></a>1.4 propertyMissing</h3><p>Groovy支持<code>propertyMissing</code>的特性，当访问不存在的属性时，会触发这个方法。对于读访问，<code>propertyMissing</code>包含一个表示属性名的String类型的参数：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">   <span class="keyword">def</span> propertyMissing(String name) &#123; name &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">new</span> Foo().boo == <span class="string">'boo'</span></span><br></pre></td></tr></table></figure>
<p><code>propertyMissing(String)</code>只会运行时找不到属性的getter方法时调用。</p>
<p>如果为不存在的属性赋值，可以使用包含一个额外value参数的<code>propertyMissing</code>来拦截：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">   <span class="keyword">def</span> storage = [:]</span><br><span class="line">   <span class="keyword">def</span> propertyMissing(String name, value) &#123; storage[name] = value &#125;</span><br><span class="line">   <span class="keyword">def</span> propertyMissing(String name) &#123; storage[name] &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> f = <span class="keyword">new</span> Foo()</span><br><span class="line">f.foo = <span class="string">"bar"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> f.foo == <span class="string">"bar"</span></span><br></pre></td></tr></table></figure>
<p>和<code>methodMissing</code>一样，使用它来动态注册新的属性到类上来加速之后的访问是最佳实践。</p>
<p><code>methodMissing</code>和<code>propertyMissing</code>方法可以通过<code>ExpandoMetaClass</code>来添加静态方法和属性。</p>
<h3 id="1-5-GroovyInterceptable"><a href="#1-5-GroovyInterceptable" class="headerlink" title="1.5 GroovyInterceptable"></a>1.5 GroovyInterceptable</h3><p><code>groovy.lang.GroovyInterceptable</code>接口是一个没有方法的标记接口，他用于让Groovy运行时在运行这个对象时，所有这个对象上的方法，都要被方法派发机制拦截。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> groovy.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GroovyInterceptable</span> <span class="keyword">extends</span> <span class="title">GroovyObject</span> &#123;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个Groovy对象实现了<code>GroovyInterceptable</code>接口，他的<code>invokeMethod()</code>会在所有方法调用时被触发。看例子：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interception</span> <span class="keyword">implements</span> <span class="title">GroovyInterceptable</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> definedMethod() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> invokeMethod(String name, Object args) &#123;</span><br><span class="line">        <span class="string">'invokedMethod'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的测试可以发现，不管是存在的方法还是不存在的方法都被<code>invokeMethod</code>方法拦截了：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterceptableTest</span> <span class="keyword">extends</span> <span class="title">GroovyTestCase</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> testCheckInterception() &#123;</span><br><span class="line">        <span class="keyword">def</span> interception = <span class="keyword">new</span> Interception()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> interception.definedMethod() == <span class="string">'invokedMethod'</span></span><br><span class="line">        <span class="keyword">assert</span> interception.someMethod() == <span class="string">'invokedMethod'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们不能使用默认的groovy方法，比如<code>println</code>，因为这些方法被注入到了所有的groovy对象中，所以他们也会被拦截。</p>
<p>如果我们想拦截所有方法但是不想实现<code>GroovyInterceptable</code>接口，我们可以在一个对象上的<code>MetaClass</code>中实现<code>invokeMethod()</code>方法。这个方法在POGO和POJO上都有效：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterceptionThroughMetaClassTest</span> <span class="keyword">extends</span> <span class="title">GroovyTestCase</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> testPOJOMetaClassInterception() &#123;</span><br><span class="line">        String invoking = <span class="string">'ha'</span></span><br><span class="line">        invoking.metaClass.invokeMethod = &#123; String name, Object args -&gt;</span><br><span class="line">            <span class="string">'invoked'</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> invoking.length() == <span class="string">'invoked'</span></span><br><span class="line">        <span class="keyword">assert</span> invoking.someMethod() == <span class="string">'invoked'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> testPOGOMetaClassInterception() &#123;</span><br><span class="line">        Entity entity = <span class="keyword">new</span> Entity(<span class="string">'Hello'</span>)</span><br><span class="line">        entity.metaClass.invokeMethod = &#123; String name, Object args -&gt;</span><br><span class="line">            <span class="string">'invoked'</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> entity.build(<span class="keyword">new</span> Object()) == <span class="string">'invoked'</span></span><br><span class="line">        <span class="keyword">assert</span> entity.someMethod() == <span class="string">'invoked'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-6-Categories"><a href="#1-6-Categories" class="headerlink" title="1.6 Categories"></a>1.6 Categories</h3><p>有时候让对象失控或者是拥有额外的方法是特别有用的。为了能够提供这种能力，Groovy实现了一种向Object-C学来的特性：<code>Categories</code>。</p>
<p>Categories是使用所谓的<code>category classes</code>来实现的。</p>
<p>Groovy内置了一些categories，这些categories为现有类添加了一些有用的方法，让他们在Groovy环境下更加有用：</p>
<ul>
<li>groovy.time.TimeCategory</li>
<li>groovy.servlet.ServletCategory</li>
<li>groovy.xml.dom.DOMCategory</li>
</ul>
<p>Category类默认是不启用的。为了使用定义在Category中的方法，需要使用<code>use</code>方法：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">use(TimeCategory)  &#123;</span><br><span class="line">    println <span class="number">1.</span>minute.from.now  <span class="comment">// TimeCategory adds methods to Integer</span></span><br><span class="line">    println <span class="number">10.</span>hours.ago</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> someDate = <span class="keyword">new</span> Date()       </span><br><span class="line">    println someDate - <span class="number">3.</span>months  <span class="comment">// TimeCategory adds methods to Date</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>use</code>方法的第一个参数是category类，第二个参数是闭包。在闭包中的代码可以使用category类中定义的方法。比如上面的例子，TimeCategory类在<code>java.lang.Integer</code>和<code>java.util.Date</code>上添加了一些方便的时间操作函数，在use的闭包参数中，我们就可以调用这些方法。</p>
<p>一个Category不一定要直接暴露到用户代码中，看下面这个例子：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JPACategory</span>&#123;</span></span><br><span class="line">  <span class="comment">// Let's enhance JPA EntityManager without getting into the JSR committee</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> persistAll(EntityManager em , Object[] entities) &#123; <span class="comment">//add an interface to save all</span></span><br><span class="line">    entities?.each &#123; em.persist(it) &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def transactionContext = &#123;</span><br><span class="line">  EntityManager em, Closure c -&gt;</span><br><span class="line">  def tx = em.transaction</span><br><span class="line">  try &#123;</span><br><span class="line">    tx.begin()</span><br><span class="line">    use(JPACategory) &#123;</span><br><span class="line">      c()</span><br><span class="line">    &#125;</span><br><span class="line">    tx.commit()</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    tx.rollback()</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    //cleanup your resource here</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// user code, they always forget to close resource in exception, some even forget to commit, let's not rely on them.</span><br><span class="line">EntityManager em; //probably injected</span><br><span class="line">transactionContext (em) &#123;</span><br><span class="line"> em.persistAll(obj1, obj2, obj3)</span><br><span class="line"> // let's do some logics here to make the example sensible</span><br><span class="line"> em.persistAll(obj2, obj4, obj6)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看<code>groovy.time.TimeCategory</code>的源码会发现所有的扩展方法都是static方法。这是Category扩展方法必须遵守的：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeCategory</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Date plus(<span class="keyword">final</span> Date date, <span class="keyword">final</span> BaseDuration duration) &#123;</span><br><span class="line">        <span class="keyword">return</span> duration.plus(date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Date minus(<span class="keyword">final</span> Date date, <span class="keyword">final</span> BaseDuration duration) &#123;</span><br><span class="line">        <span class="keyword">final</span> Calendar cal = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">        cal.setTime(date);</span><br><span class="line">        cal.add(Calendar.YEAR, -duration.getYears());</span><br><span class="line">        cal.add(Calendar.MONTH, -duration.getMonths());</span><br><span class="line">        cal.add(Calendar.DAY_OF_YEAR, -duration.getDays());</span><br><span class="line">        cal.add(Calendar.HOUR_OF_DAY, -duration.getHours());</span><br><span class="line">        cal.add(Calendar.MINUTE, -duration.getMinutes());</span><br><span class="line">        cal.add(Calendar.SECOND, -duration.getSeconds());</span><br><span class="line">        cal.add(Calendar.MILLISECOND, -duration.getMillis());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cal.getTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>另外一个要求是，静态方法的第一个参数是想要扩展的目标对象实例，剩下的参数是调用时传入的普通参数。</p>
<p>因为参数和静态方法的这些规定，导致category方法可能不太像普通方法一样符合直觉。对此，Groovy提供了一个<code>@Category</code>注解来在编译时转换一个普通对象为category对象。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Distance</span> &#123;</span></span><br><span class="line">    <span class="keyword">def</span> number</span><br><span class="line">    String toString() &#123; <span class="string">"$&#123;number&#125;m"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Category</span>(Number)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberCategory</span> &#123;</span></span><br><span class="line">    Distance getMeters() &#123;</span><br><span class="line">        <span class="keyword">new</span> Distance(<span class="string">number:</span> <span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">use (NumberCategory)  &#123;</span><br><span class="line">    <span class="keyword">assert</span> <span class="number">42.</span>meters.toString() == <span class="string">'42m'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>@Category</code>注解的好处是不用让每个扩展方法的第一个参数是被扩展对象了，被扩展对象作为注解的参数出传入。</p>
<h3 id="1-7-Metaclasses"><a href="#1-7-Metaclasses" class="headerlink" title="1.7 Metaclasses"></a>1.7 Metaclasses</h3><p>(官方文档未完成)</p>
<h4 id="1-7-1-Custom-metaclasses"><a href="#1-7-1-Custom-metaclasses" class="headerlink" title="1.7.1. Custom metaclasses"></a>1.7.1. Custom metaclasses</h4><p>(官方文档未完成)</p>
<h4 id="1-7-2-Per-instance-metaclass"><a href="#1-7-2-Per-instance-metaclass" class="headerlink" title="1.7.2. Per instance metaclass"></a>1.7.2. Per instance metaclass</h4><p>(官方文档未完成)</p>
<h4 id="1-7-3-ExpandoMetaClass"><a href="#1-7-3-ExpandoMetaClass" class="headerlink" title="1.7.3. ExpandoMetaClass"></a>1.7.3. ExpandoMetaClass</h4><p>Groovy提供了一个特殊的<code>MetaClass</code>叫做<code>ExpandoMetaClass</code>。这个类特殊在他可以动态地添加或者修改方法，构造函数，属性，甚至是静态方法。</p>
<p>这个特性在mocking和stubbing时是非常有用的。</p>
<p>甚至<code>java.lang.Class</code>，Groovy都提供了一个<code>metaClass</code>属性，这个属性是指向<code>ExpandoMetaClass</code>的引用。这个实例可以用于修改现有对象的行为。</p>
<p>默认<code>ExpandoMetaClass</code>不会继承。如果想要开启这个特性，需要正在程序启动时调用<code>ExpandoMetaClass#enableGlobally()</code>。</p>
<p>下面介绍<code>ExpandoMetaClass</code>在不同场景下的使用。</p>
<h5 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h5><p>使用<code>metaClass</code>属性获取<code>ExpandoMetaClass</code>引用后，就可以使用左移<code>&lt;&lt;</code>或者是<code>=</code>来添加方法。</p>
<p>注意，左移用于“追加”新方法。如果一个拥有相同名字，参数的public方法已经在class或者interface中定义了，包括在父class和父interface中定义的，但是不包括运行时添加到<code>metaClass</code>上的，那么在使用<code>&lt;&lt;</code>时会抛出一个异常。如果你想要“替换”已经存在的方法，可以使用<code>=</code>操作符。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> &#123;</span></span><br><span class="line">   String title</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Book.metaClass.titleInUpperCase &lt;&lt; &#123;-&gt; title.toUpperCase() &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> b = <span class="keyword">new</span> Book(<span class="string">title:</span><span class="string">"The Stand"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> <span class="string">"THE STAND"</span> == b.titleInUpperCase()</span><br></pre></td></tr></table></figure>
<h5 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h5><p><code>ExpandoMetaClass</code>支持两种添加或者覆盖属性的机制。</p>
<p>第一种，通过直接给<code>metaClass</code>的属性赋值来声明一个可变属性：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> &#123;</span></span><br><span class="line">   String title</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Book.metaClass.author = <span class="string">"Stephen King"</span></span><br><span class="line"><span class="keyword">def</span> b = <span class="keyword">new</span> Book()</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> <span class="string">"Stephen King"</span> == b.author</span><br></pre></td></tr></table></figure>
<p>另外一种方法是使用上面提到的添加方法的方式添加getter/setter方法：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> &#123;</span></span><br><span class="line">  String title</span><br><span class="line">&#125;</span><br><span class="line">Book.metaClass.getAuthor &lt;&lt; &#123;-&gt; <span class="string">"Stephen King"</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> b = <span class="keyword">new</span> Book()</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> <span class="string">"Stephen King"</span> == b.author</span><br></pre></td></tr></table></figure>
<p>上面这个例子通过添加getter方法声明了一个属性，这个属性是只读的。你可以添加对应的setter方法。</p>
<h5 id="Constructors"><a href="#Constructors" class="headerlink" title="Constructors"></a>Constructors</h5><p>可以使用特殊的<code>constructor</code>属性来添加构造函数。可以用<code>&lt;&lt;</code>或<code>=</code>操作符来添加闭包，闭包的参数会作为构造函数的参数。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> &#123;</span></span><br><span class="line">    String title</span><br><span class="line">&#125;</span><br><span class="line">Book.metaClass.constructor &lt;&lt; &#123; String title -&gt; <span class="keyword">new</span> Book(<span class="string">title:</span>title) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> book = <span class="keyword">new</span> Book(<span class="string">'Groovy in Action - 2nd Edition'</span>)</span><br><span class="line"><span class="keyword">assert</span> book.title == <span class="string">'Groovy in Action - 2nd Edition'</span></span><br></pre></td></tr></table></figure>
<p>在添加构造函数时要注意，因为他容易陷入stack overflow问题。（不太懂）</p>
<h5 id="Static-Methods"><a href="#Static-Methods" class="headerlink" title="Static Methods"></a>Static Methods</h5><p>添加静态方法和添加普通方法是一样的，不过需要添加在<code>static</code>这个限定符下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> &#123;</span></span><br><span class="line">   String title</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Book.metaClass.<span class="keyword">static</span>.create &lt;&lt; &#123; String title -&gt; <span class="keyword">new</span> Book(<span class="string">title:</span>title) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> b = Book.create(<span class="string">"The Stand"</span>)</span><br></pre></td></tr></table></figure>
<h5 id="Borrowing-Methods-方法借用"><a href="#Borrowing-Methods-方法借用" class="headerlink" title="Borrowing Methods 方法借用"></a>Borrowing Methods 方法借用</h5><p>集合Groovy的方法指针语法，ExpandoMetaClass可以从别的类上“借用”方法：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    String name</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MortgageLender</span> &#123;</span></span><br><span class="line">   <span class="keyword">def</span> borrowMoney() &#123;</span><br><span class="line">      <span class="string">"buy house"</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> lender = <span class="keyword">new</span> MortgageLender()</span><br><span class="line"></span><br><span class="line">Person.metaClass.buyHouse = lender.&amp;borrowMoney</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> p = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> <span class="string">"buy house"</span> == p.buyHouse()</span><br></pre></td></tr></table></figure>
<h5 id="Dynamic-Method-Names-动态方法名"><a href="#Dynamic-Method-Names-动态方法名" class="headerlink" title="Dynamic Method Names 动态方法名"></a>Dynamic Method Names 动态方法名</h5><p>因为Groovy支持使用字符串作为属性的名称，因此也支持在运行时动态的新建方法和属性名称：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">   String name = <span class="string">"Fred"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> methodName = <span class="string">"Bob"</span></span><br><span class="line"></span><br><span class="line">Person.metaClass.<span class="string">"changeNameTo$&#123;methodName&#125;"</span> = &#123;-&gt; delegate.name = <span class="string">"Bob"</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> p = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> <span class="string">"Fred"</span> == p.name</span><br><span class="line"></span><br><span class="line">p.changeNameToBob()</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> <span class="string">"Bob"</span> == p.name</span><br></pre></td></tr></table></figure>
<h5 id="Runtime-Discovery-动态发现"><a href="#Runtime-Discovery-动态发现" class="headerlink" title="Runtime Discovery 动态发现"></a>Runtime Discovery 动态发现</h5><p>在运行时检查是否有其他属性或者方法存在是非常有用的特性，<code>ExpandoMetaClass</code>提供了一下方法来实现这个功能：</p>
<ul>
<li>getMetaMethod</li>
<li>hasMetaMethod</li>
<li>getMetaProperty</li>
<li>hasMetaProperty</li>
</ul>
<p>为什么不能直接用反射呢？因为Groovy是不一样的，他可以有只有在运行时才存在的方法。运行时能调用的方法被称为MetaMethods。</p>
<h5 id="GroovyObject-Methods"><a href="#GroovyObject-Methods" class="headerlink" title="GroovyObject Methods"></a>GroovyObject Methods</h5><p><code>ExpandoMetaClass</code>的另外一个特性是他允许你覆盖方法<code>invokeMethod</code>,<code>getProperty</code>和<code>setProperty</code>，这些方法都是<code>groovy.lang.GroovyObject</code>中的方法。</p>
<p>下面是覆盖<code>invokeMethod</code>方法的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stuff</span> </span>&#123;</span><br><span class="line">   <span class="function">def <span class="title">invokeMe</span><span class="params">()</span> </span>&#123; <span class="string">"foo"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stuff.metaClass.invokeMethod = &#123; String name, args -&gt;</span><br><span class="line">   def metaMethod = Stuff.metaClass.getMetaMethod(name, args)</span><br><span class="line">   def result</span><br><span class="line">   <span class="keyword">if</span>(metaMethod) result = metaMethod.invoke(delegate,args)</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      result = <span class="string">"bar"</span></span><br><span class="line">   &#125;</span><br><span class="line">   result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def stf = <span class="keyword">new</span> Stuff()</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> <span class="string">"foo"</span> == stf.invokeMe()</span><br><span class="line"><span class="keyword">assert</span> <span class="string">"bar"</span> == stf.doStuff()</span><br></pre></td></tr></table></figure>
<p><code>MetaMethod</code>是存在<code>MetaClass</code>上的方法，无论是运行时还是编译时添加的。</p>
<p>同样的逻辑可以用于覆盖<code>setProperty</code>或者<code>getProperty</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   String name = <span class="string">"Fred"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.metaClass.getProperty = &#123; String name -&gt;</span><br><span class="line">   def metaProperty = Person.metaClass.getMetaProperty(name)</span><br><span class="line">   def result</span><br><span class="line">   <span class="keyword">if</span>(metaProperty) result = metaProperty.getProperty(delegate)</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      result = <span class="string">"Flintstone"</span></span><br><span class="line">   &#125;</span><br><span class="line">   result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def p = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> <span class="string">"Fred"</span> == p.name</span><br><span class="line"><span class="keyword">assert</span> <span class="string">"Flintstone"</span> == p.other</span><br></pre></td></tr></table></figure>
<h5 id="Overriding-Static-invokeMethod-覆盖静态invokeMethod"><a href="#Overriding-Static-invokeMethod-覆盖静态invokeMethod" class="headerlink" title="Overriding Static invokeMethod 覆盖静态invokeMethod"></a>Overriding Static invokeMethod 覆盖静态invokeMethod</h5><p><code>ExpandoMetaClass</code>甚至允许你覆盖静态方法，方法是使用特殊的<code>invokeMethod</code>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stuff</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="title">invokeMe</span><span class="params">()</span> </span>&#123; <span class="string">"foo"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stuff.metaClass.<span class="string">'static'</span>.invokeMethod = &#123; String name, args -&gt;</span><br><span class="line">   def metaMethod = Stuff.metaClass.getStaticMetaMethod(name, args)</span><br><span class="line">   def result</span><br><span class="line">   <span class="keyword">if</span>(metaMethod) result = metaMethod.invoke(delegate,args)</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      result = <span class="string">"bar"</span></span><br><span class="line">   &#125;</span><br><span class="line">   result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> <span class="string">"foo"</span> == Stuff.invokeMe()</span><br><span class="line"><span class="keyword">assert</span> <span class="string">"bar"</span> == Stuff.doStuff()</span><br></pre></td></tr></table></figure>
<p>和覆盖普通方法基本一样，不一样的地方是访问<code>metaClass.static</code>和调用<code>getStaticMethodName</code>方法。</p>
<h5 id="Extending-Interfaces-扩展接口"><a href="#Extending-Interfaces-扩展接口" class="headerlink" title="Extending Interfaces 扩展接口"></a>Extending Interfaces 扩展接口</h5><p>使用<code>ExpandoMetaClass</code>可以添加方法到接口上。不过你需要开启这个特性，开启的方法是在程序运行的入口处调用<code>ExpandoMetaClass.enableGlobally()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List.metaClass.sizeDoubled = &#123;-&gt; delegate.size() * <span class="number">2</span> &#125;</span><br><span class="line"></span><br><span class="line">def list = []</span><br><span class="line"></span><br><span class="line">list &lt;&lt; <span class="number">1</span></span><br><span class="line">list &lt;&lt; <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> <span class="number">4</span> == list.sizeDoubled()</span><br></pre></td></tr></table></figure>
<h3 id="1-8-Extension-modules-扩展模块"><a href="#1-8-Extension-modules-扩展模块" class="headerlink" title="1.8 Extension modules 扩展模块"></a>1.8 Extension modules 扩展模块</h3><h4 id="1-8-1-Extending-existing-classes-扩展现有的类"><a href="#1-8-1-Extending-existing-classes-扩展现有的类" class="headerlink" title="1.8.1 Extending existing classes 扩展现有的类"></a>1.8.1 Extending existing classes 扩展现有的类</h4><p>使用扩展模块可以在现有的类上添加方法，包含那些已经编译好的类，比如JDK中的类。这些新方法，不像定义在metaclass或者category上的类，这些新方法是在全局有效的，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def file = <span class="keyword">new</span> File(...)</span><br><span class="line">def contents = file.getText(<span class="string">'utf-8'</span>)</span><br></pre></td></tr></table></figure>
<p>这里的<code>getText</code>方法是不存在在File类上的。但是Groovy知道他的存在，因为有一个特殊的类<code>ResourceGroovyMethods</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getText</span><span class="params">(File file, String charset)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> IOGroovyMethods.getText(newReader(file, charset));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以发现，一个扩展方法是被定义为static的，被定义在一个帮助类里，方法的第一个参数是被扩展的类，剩下的方法是传入扩展方法的参数。</p>
<p>定义一个扩展模块是非常简单的：</p>
<ul>
<li>编写一个扩展类</li>
<li>编写模块描述文件</li>
</ul>
<p>然后你要让Groovy能感知到你的扩展模块，这只要让你的扩展模块类和描述文件在classpath中即可，所以你有两个选择：</p>
<ul>
<li>让扩展模块类和描述文件在classpath中</li>
<li>打包扩展模块到jar中以便于使用</li>
</ul>
<p>扩展模块可以为类添加两种方法：</p>
<ul>
<li>实例方法</li>
<li>静态方法</li>
</ul>
<h4 id="1-8-4-Module-descriptor-模块描述文件"><a href="#1-8-4-Module-descriptor-模块描述文件" class="headerlink" title="1.8.4 Module descriptor 模块描述文件"></a>1.8.4 Module descriptor 模块描述文件</h4><p>为了让Groovy能加载你的扩展方法，你需要声明你的扩展帮助类，你需要定义一个名为<code>org.codehaus.groovy.runtime.ExtensionModule</code>到<code>META-INF/services</code>目录下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">moduleName=Test module for specifications</span><br><span class="line">moduleVersion=1.0-test</span><br><span class="line">extensionClasses=support.MaxRetriesExtension</span><br><span class="line">staticExtensionClasses=support.StaticStringExtension</span><br></pre></td></tr></table></figure>
<p>模块描述文件需要4个字段：</p>
<ul>
<li>moduleName：模块的名字</li>
<li>moduleVersion：模块的版本</li>
<li>extensionClasses：扩展版主类的列表，这些类提供的扩展方法是实例方法</li>
<li>staticExtensionClasses：扩展版主类的列表，这些类提供的扩展方法是静态方法</li>
</ul>
</div><div class="reward"><hr><div class="text">如果觉得文章对你有帮助，就打赏杯咖啡钱呗😊</div><img src="/img/reward/weixin.png"><img src="/img/reward/alipay.png"></div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://mushanshitiancai.github.io/2017/04/19/java/groovy/Groovy元编程/" data-id="cjkbb0fps00c2zo310bh3t7xc" class="article-share-link">分享</a><div class="tags"><a href="/tags/java/">java</a><a href="/tags/groovy/">groovy</a></div><div class="post-nav"><a href="/2017/05/17/web/Postman技巧-互相依赖的请求实现链式调用/" class="pre">Postman技巧-互相依赖的请求实现链式调用</a><a href="/2017/04/14/java/groovy/Groovy学习笔记/" class="next">Groovy学习笔记</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'mushan';
var disqus_identifier = '2017/04/19/java/groovy/Groovy元编程/';
var disqus_title = 'Groovy元编程-运行时元编程';
var disqus_url = 'http://mushanshitiancai.github.io/2017/04/19/java/groovy/Groovy元编程/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/favicon.ico',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//mushan.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://mushanshitiancai.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Groovy/">Groovy</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/JDK源码阅读/">JDK源码阅读</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/掌握Java/">掌握Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/调试/">调试</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/TypeScript/">TypeScript</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MongoDB/">MongoDB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/RabbitMQ/">RabbitMQ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tomcat/">Tomcat</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/electron/">electron</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/自动化/">自动化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/自己动手写操作系统/">自己动手写操作系统</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/bochs/" style="font-size: 15px;">bochs</a> <a href="/tags/work/" style="font-size: 15px;">work</a> <a href="/tags/log/" style="font-size: 15px;">log</a> <a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/angularjs/" style="font-size: 15px;">angularjs</a> <a href="/tags/db/" style="font-size: 15px;">db</a> <a href="/tags/mongodb/" style="font-size: 15px;">mongodb</a> <a href="/tags/react/" style="font-size: 15px;">react</a> <a href="/tags/mmnote/" style="font-size: 15px;">mmnote</a> <a href="/tags/architecture/" style="font-size: 15px;">architecture</a> <a href="/tags/protocol-buffers/" style="font-size: 15px;">protocol-buffers</a> <a href="/tags/mq/" style="font-size: 15px;">mq</a> <a href="/tags/blog/" style="font-size: 15px;">blog</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/tools/" style="font-size: 15px;">tools</a> <a href="/tags/emacs/" style="font-size: 15px;">emacs</a> <a href="/tags/管理后台/" style="font-size: 15px;">管理后台</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/shell/" style="font-size: 15px;">shell</a> <a href="/tags/tmux/" style="font-size: 15px;">tmux</a> <a href="/tags/vagrant/" style="font-size: 15px;">vagrant</a> <a href="/tags/os/" style="font-size: 15px;">os</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/automation/" style="font-size: 15px;">automation</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/php/" style="font-size: 15px;">php</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/project/" style="font-size: 15px;">project</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/software/" style="font-size: 15px;">software</a> <a href="/tags/test/" style="font-size: 15px;">test</a> <a href="/tags/ffmpeg/" style="font-size: 15px;">ffmpeg</a> <a href="/tags/gm/" style="font-size: 15px;">gm</a> <a href="/tags/graphicsmagick/" style="font-size: 15px;">graphicsmagick</a> <a href="/tags/wireshark/" style="font-size: 15px;">wireshark</a> <a href="/tags/vscode/" style="font-size: 15px;">vscode</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/curl/" style="font-size: 15px;">curl</a> <a href="/tags/javafx/" style="font-size: 15px;">javafx</a> <a href="/tags/jvm/" style="font-size: 15px;">jvm</a> <a href="/tags/guava/" style="font-size: 15px;">guava</a> <a href="/tags/junit/" style="font-size: 15px;">junit</a> <a href="/tags/groovy/" style="font-size: 15px;">groovy</a> <a href="/tags/idea/" style="font-size: 15px;">idea</a> <a href="/tags/tomcat/" style="font-size: 15px;">tomcat</a> <a href="/tags/maven/" style="font-size: 15px;">maven</a> <a href="/tags/doclet/" style="font-size: 15px;">doclet</a> <a href="/tags/log4j/" style="font-size: 15px;">log4j</a> <a href="/tags/dubbo/" style="font-size: 15px;">dubbo</a> <a href="/tags/servlet/" style="font-size: 15px;">servlet</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/electron/" style="font-size: 15px;">electron</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/jquery/" style="font-size: 15px;">jquery</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/webpack/" style="font-size: 15px;">webpack</a> <a href="/tags/typescript/" style="font-size: 15px;">typescript</a> <a href="/tags/ts/" style="font-size: 15px;">ts</a> <a href="/tags/gulp/" style="font-size: 15px;">gulp</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/java/language/JDK源码阅读-InterruptibleChannel与可中断IO/">JDK源码阅读-InterruptibleChannel与可中断IO</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/28/java/language/Java日志-Log4j实现运行时修改日志级别/">Java日志-Log4j实现运行时修改日志级别</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/28/java/language/Java日志-Log4j源码分析/">Java日志-Log4j源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/22/java/language/Java日志-SLF4J使用与源码分析/">Java日志-SLF4J使用与源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/11/os/自己动手写操作系统-计算机通电之后的操作/">自己动手写操作系统-计算机通电之后的操作</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/11/os/Bochs学习-安装配置篇/">Bochs学习-安装配置篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/18/java/language/Java如何保证文件落盘？/">Java如何保证文件落盘？</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/17/linux/Linux-UNIX编程如何保证文件落盘/">Linux/UNIX编程如何保证文件落盘</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/db/MongoDB遍历方式对比/">MongoDB遍历方式对比</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/java/language/JDK源码阅读-RandomAccessFile/">JDK源码阅读-RandomAccessFile</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//mushan.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://anotom.com/" title="鑫哥的博客" target="_blank">鑫哥的博客</a><ul></ul><a href="https://www.caylor.cc/" title="乐哥的博客" target="_blank">乐哥的博客</a><ul></ul><a href="http://zach41.github.io/" title="小美的博客" target="_blank">小美的博客</a><ul></ul><a href="http://blog.csdn.net/sinat_25127047" title="瀚文的博客" target="_blank">瀚文的博客</a><ul></ul><a href="http://blog.csdn.net/xiaohangblog?viewmode=contents)" title="小杭的博客" target="_blank">小杭的博客</a><ul></ul><a href="http://bettercuicui.github.io/" title="夏侯的博客" target="_blank">夏侯的博客</a><ul></ul><a href="http://damye.github.io/" title="符尧的博客" target="_blank">符尧的博客</a><ul></ul><a href="http://blog.shrp.me/" title="尚弟的博客" target="_blank">尚弟的博客</a><ul></ul><a href="http://imethan.cn" title="应锋的博客" target="_blank">应锋的博客</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">木杉的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>